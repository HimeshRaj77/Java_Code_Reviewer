This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.mvn/
  wrapper/
    maven-wrapper.properties
META-INF/
  MANIFEST.MF
src/
  main/
    java/
      com/
        reviewer/
          codereviewer/
            client/
              dto/
                CodeAnalysisResult.java
                CodeIssue.java
                QuickFix.java
              ApiClientService.java
            controller/
              MainController.java
            ui/
              MainView.java
              ModernMainView.java
            MainApp.java
    resources/
      ai-style.css
      app-theme.css
      application.properties
      logging.properties
      modern-theme.css
  test/
    java/
      com/
        reviewer/
          codereviewer/
            client/
              dto/
                CodeAnalysisResultTest.java
                CodeIssueTest.java
                QuickFixTest.java
              ApiClientServiceTest.java
            controller/
              MainControllerTest.java
.gitattributes
.gitignore
FRONTEND-TRANSFORMATION-COMPLETE.md
HELP.md
INTEGRATION_GUIDE.md
mvnw
pom.xml
README.md
test-frontend-transformation.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".mvn/wrapper/maven-wrapper.properties">
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip
</file>

<file path="META-INF/MANIFEST.MF">
Manifest-Version: 1.0
Created-By: Maven JAR Plugin 3.4.1
Build-Jdk-Spec: 21
Main-Class: com.reviewer.codereviewer.MainApp
</file>

<file path="src/main/java/com/reviewer/codereviewer/client/dto/CodeAnalysisResult.java">
package com.reviewer.codereviewer.client.dto;

import java.util.List;
import java.util.ArrayList;

/**
 * Data Transfer Object for code analysis results from the backend API
 */
public class CodeAnalysisResult {
    private List<CodeIssue> errors;
    private List<CodeIssue> suggestions;
    private double score;
    private String analysisTime;
    
    public CodeAnalysisResult() {
        this.errors = new ArrayList<>();
        this.suggestions = new ArrayList<>();
        this.score = 0.0;
    }
    
    public CodeAnalysisResult(List<CodeIssue> errors, List<CodeIssue> suggestions, double score) {
        this.errors = errors != null ? errors : new ArrayList<>();
        this.suggestions = suggestions != null ? suggestions : new ArrayList<>();
        this.score = score;
    }
    
    // Getters and Setters
    public List<CodeIssue> getErrors() {
        return errors;
    }
    
    public void setErrors(List<CodeIssue> errors) {
        this.errors = errors;
    }
    
    public List<CodeIssue> getSuggestions() {
        return suggestions;
    }
    
    public void setSuggestions(List<CodeIssue> suggestions) {
        this.suggestions = suggestions;
    }
    
    public double getScore() {
        return score;
    }
    
    public void setScore(double score) {
        this.score = score;
    }
    
    public String getAnalysisTime() {
        return analysisTime;
    }
    
    public void setAnalysisTime(String analysisTime) {
        this.analysisTime = analysisTime;
    }
    
    public boolean hasIssues() {
        return !errors.isEmpty() || !suggestions.isEmpty();
    }
    
    public int getTotalIssueCount() {
        return errors.size() + suggestions.size();
    }
}
</file>

<file path="src/main/java/com/reviewer/codereviewer/client/dto/CodeIssue.java">
package com.reviewer.codereviewer.client.dto;

import java.util.List;
import java.util.ArrayList;

/**
 * Data Transfer Object for code issues from the backend API
 */
public class CodeIssue {
    
    public enum Type {
        ERROR, WARNING, SUGGESTION, INFO
    }
    
    private String message;
    private int line;
    private int column;
    private Type type;
    private String severity;
    private List<QuickFix> quickFixes;
    
    public CodeIssue() {
        this.quickFixes = new ArrayList<>();
    }
    
    public CodeIssue(String message, int line, int column, Type type) {
        this.message = message;
        this.line = line;
        this.column = column;
        this.type = type;
        this.quickFixes = new ArrayList<>();
    }
    
    public CodeIssue(String message, int line, Type type) {
        this(message, line, 0, type);
    }
    
    // Getters and Setters
    public String getMessage() {
        return message;
    }
    
    public void setMessage(String message) {
        this.message = message;
    }
    
    public int getLine() {
        return line;
    }
    
    public void setLine(int line) {
        this.line = line;
    }
    
    public int getColumn() {
        return column;
    }
    
    public void setColumn(int column) {
        this.column = column;
    }
    
    public Type getType() {
        return type;
    }
    
    public void setType(Type type) {
        this.type = type;
    }
    
    public String getSeverity() {
        return severity;
    }
    
    public void setSeverity(String severity) {
        this.severity = severity;
    }
    
    public List<QuickFix> getQuickFixes() {
        return quickFixes;
    }
    
    public void setQuickFixes(List<QuickFix> quickFixes) {
        this.quickFixes = quickFixes != null ? quickFixes : new ArrayList<>();
    }
    
    public void addQuickFix(QuickFix quickFix) {
        if (quickFix != null) {
            this.quickFixes.add(quickFix);
        }
    }
    
    public boolean hasQuickFixes() {
        return !quickFixes.isEmpty();
    }
    
    @Override
    public String toString() {
        return String.format("%s at line %d: %s", type, line, message);
    }
}
</file>

<file path="src/main/java/com/reviewer/codereviewer/client/dto/QuickFix.java">
package com.reviewer.codereviewer.client.dto;

/**
 * Data Transfer Object for quick fixes from the backend API
 */
public class QuickFix {
    private String description;
    private String action;
    private String replacement;
    private int startLine;
    private int endLine;
    
    public QuickFix() {
    }
    
    public QuickFix(String description, String action) {
        this.description = description;
        this.action = action;
    }
    
    public QuickFix(String description, String action, String replacement, int startLine, int endLine) {
        this.description = description;
        this.action = action;
        this.replacement = replacement;
        this.startLine = startLine;
        this.endLine = endLine;
    }
    
    // Getters and Setters
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public String getAction() {
        return action;
    }
    
    public void setAction(String action) {
        this.action = action;
    }
    
    public String getReplacement() {
        return replacement;
    }
    
    public void setReplacement(String replacement) {
        this.replacement = replacement;
    }
    
    public int getStartLine() {
        return startLine;
    }
    
    public void setStartLine(int startLine) {
        this.startLine = startLine;
    }
    
    public int getEndLine() {
        return endLine;
    }
    
    public void setEndLine(int endLine) {
        this.endLine = endLine;
    }
    
    @Override
    public String toString() {
        return description != null ? description : action;
    }
}
</file>

<file path="src/main/java/com/reviewer/codereviewer/client/ApiClientService.java">
package com.reviewer.codereviewer.client;

import com.reviewer.codereviewer.client.dto.CodeAnalysisResult;
import com.reviewer.codereviewer.client.dto.CodeIssue;
import com.reviewer.codereviewer.client.dto.QuickFix;

import java.io.*;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.List;
import java.util.ArrayList;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.JsonNode;

/**
 * API Client Service for communicating with the CodeReviewer backend server.
 * This service handles all HTTP communication and serialization/deserialization.
 */
public class ApiClientService {
    private static final Logger logger = Logger.getLogger(ApiClientService.class.getName());
    
    private final HttpClient httpClient;
    private final ObjectMapper objectMapper;
    private final String serverBaseUrl;
    
    // Default configuration
    private static final String DEFAULT_SERVER_URL = "http://localhost:8080";
    private static final Duration REQUEST_TIMEOUT = Duration.ofSeconds(30);
    private static final Duration STREAMING_TIMEOUT = Duration.ofMinutes(2);
    
    public ApiClientService() {
        this(DEFAULT_SERVER_URL);
    }
    
    public ApiClientService(String serverBaseUrl) {
        this.serverBaseUrl = serverBaseUrl.endsWith("/") ? 
            serverBaseUrl.substring(0, serverBaseUrl.length() - 1) : serverBaseUrl;
        
        this.httpClient = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(10))
            .build();
            
        this.objectMapper = new ObjectMapper();
        
        logger.info("ApiClientService initialized with server URL: " + this.serverBaseUrl);
    }
    
    /**
     * Analyzes the provided code by sending it to the backend server.
     * 
     * @param code The source code to analyze
     * @return CompletableFuture containing the analysis result
     */
    public CompletableFuture<CodeAnalysisResult> analyzeCode(String code) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                logger.info("Sending code analysis request to server");
                
                // Create request body
                String requestBody = objectMapper.writeValueAsString(new CodeAnalysisRequest(code));
                
                // Build HTTP request
                HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(serverBaseUrl + "/api/analyze"))
                    .timeout(REQUEST_TIMEOUT)
                    .header("Content-Type", "application/json")
                    .POST(HttpRequest.BodyPublishers.ofString(requestBody))
                    .build();
                
                // Send request and handle response
                HttpResponse<String> response = httpClient.send(request, 
                    HttpResponse.BodyHandlers.ofString());
                
                if (response.statusCode() == 200) {
                    logger.info("Analysis request successful");
                    return parseAnalysisResult(response.body());
                } else {
                    logger.warning("Analysis request failed with status: " + response.statusCode());
                    throw new RuntimeException("Server error: " + response.statusCode() + " - " + response.body());
                }
                
            } catch (Exception e) {
                logger.log(Level.SEVERE, "Error during code analysis", e);
                throw new RuntimeException("Failed to analyze code: " + e.getMessage(), e);
            }
        });
    }
    
    /**
     * Gets AI suggestions for the provided code with streaming response.
     * 
     * @param code The source code to get suggestions for
     * @param question The specific question or request about the code
     * @param chunkConsumer Consumer that receives chunks of the streaming response
     * @return CompletableFuture that completes when streaming is done
     */
    public CompletableFuture<Void> getCodeSuggestionStreaming(String code, String question, Consumer<String> chunkConsumer) {
        return CompletableFuture.runAsync(() -> {
            try {
                logger.info("Sending AI suggestion request to server");
                
                // Create request body
                AISuggestionRequest requestObj = new AISuggestionRequest(code, question);
                String requestBody = objectMapper.writeValueAsString(requestObj);
                
                // Build HTTP request
                HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(serverBaseUrl + "/api/ai/suggest"))
                    .timeout(STREAMING_TIMEOUT)
                    .header("Content-Type", "application/json")
                    .header("Accept", "text/plain")
                    .POST(HttpRequest.BodyPublishers.ofString(requestBody))
                    .build();
                
                // Send request and handle streaming response
                HttpResponse<InputStream> response = httpClient.send(request, 
                    HttpResponse.BodyHandlers.ofInputStream());
                
                if (response.statusCode() == 200) {
                    logger.info("AI suggestion request successful, processing stream");
                    
                    try (BufferedReader reader = new BufferedReader(
                            new InputStreamReader(response.body()))) {
                        
                        String line;
                        while ((line = reader.readLine()) != null) {
                            chunkConsumer.accept(line + "\n");
                        }
                    }
                } else {
                    logger.warning("AI suggestion request failed with status: " + response.statusCode());
                    throw new RuntimeException("Server error: " + response.statusCode());
                }
                
            } catch (Exception e) {
                logger.log(Level.SEVERE, "Error during AI suggestion request", e);
                throw new RuntimeException("Failed to get AI suggestions: " + e.getMessage(), e);
            }
        });
    }
    
    /**
     * Simple AI suggestion method that returns the complete response.
     * 
     * @param code The source code to get suggestions for
     * @param question The specific question or request about the code
     * @return CompletableFuture containing the complete AI response
     */
    public CompletableFuture<String> getCodeSuggestion(String code, String question) {
        CompletableFuture<String> future = new CompletableFuture<>();
        StringBuilder responseBuilder = new StringBuilder();
        
        getCodeSuggestionStreaming(code, question, chunk -> {
            responseBuilder.append(chunk);
        }).whenComplete((v, ex) -> {
            if (ex != null) {
                future.completeExceptionally(ex);
            } else {
                future.complete(responseBuilder.toString());
            }
        });
        
        return future;
    }
    
    /**
     * Checks if the server is available and responding.
     * 
     * @return CompletableFuture containing true if server is healthy, false otherwise
     */
    public CompletableFuture<Boolean> checkServerHealth() {
        return CompletableFuture.supplyAsync(() -> {
            try {
                HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(serverBaseUrl + "/api/health"))
                    .timeout(Duration.ofSeconds(5))
                    .GET()
                    .build();
                
                HttpResponse<String> response = httpClient.send(request, 
                    HttpResponse.BodyHandlers.ofString());
                
                return response.statusCode() == 200;
            } catch (Exception e) {
                logger.log(Level.WARNING, "Server health check failed", e);
                return false;
            }
        });
    }
    
    /**
     * Parses the JSON response from the analysis endpoint into a CodeAnalysisResult object.
     */
    private CodeAnalysisResult parseAnalysisResult(String jsonResponse) throws Exception {
        JsonNode rootNode = objectMapper.readTree(jsonResponse);
        
        CodeAnalysisResult result = new CodeAnalysisResult();
        
        // Parse errors
        if (rootNode.has("errors")) {
            List<CodeIssue> errors = new ArrayList<>();
            for (JsonNode errorNode : rootNode.get("errors")) {
                errors.add(parseCodeIssue(errorNode));
            }
            result.setErrors(errors);
        }
        
        // Parse suggestions
        if (rootNode.has("suggestions")) {
            List<CodeIssue> suggestions = new ArrayList<>();
            for (JsonNode suggestionNode : rootNode.get("suggestions")) {
                suggestions.add(parseCodeIssue(suggestionNode));
            }
            result.setSuggestions(suggestions);
        }
        
        // Parse score
        if (rootNode.has("score")) {
            result.setScore(rootNode.get("score").asDouble());
        }
        
        // Parse analysis time
        if (rootNode.has("analysisTime")) {
            result.setAnalysisTime(rootNode.get("analysisTime").asText());
        }
        
        return result;
    }
    
    /**
     * Parses a JSON node into a CodeIssue object.
     */
    private CodeIssue parseCodeIssue(JsonNode issueNode) {
        CodeIssue issue = new CodeIssue();
        
        if (issueNode.has("message")) {
            issue.setMessage(issueNode.get("message").asText());
        }
        
        if (issueNode.has("line")) {
            issue.setLine(issueNode.get("line").asInt());
        }
        
        if (issueNode.has("column")) {
            issue.setColumn(issueNode.get("column").asInt());
        }
        
        if (issueNode.has("type")) {
            String typeStr = issueNode.get("type").asText().toUpperCase();
            try {
                issue.setType(CodeIssue.Type.valueOf(typeStr));
            } catch (IllegalArgumentException e) {
                issue.setType(CodeIssue.Type.INFO);
            }
        }
        
        if (issueNode.has("severity")) {
            issue.setSeverity(issueNode.get("severity").asText());
        }
        
        // Parse quick fixes if present
        if (issueNode.has("quickFixes")) {
            List<QuickFix> quickFixes = new ArrayList<>();
            for (JsonNode fixNode : issueNode.get("quickFixes")) {
                QuickFix quickFix = new QuickFix();
                if (fixNode.has("description")) {
                    quickFix.setDescription(fixNode.get("description").asText());
                }
                if (fixNode.has("action")) {
                    quickFix.setAction(fixNode.get("action").asText());
                }
                if (fixNode.has("replacement")) {
                    quickFix.setReplacement(fixNode.get("replacement").asText());
                }
                if (fixNode.has("startLine")) {
                    quickFix.setStartLine(fixNode.get("startLine").asInt());
                }
                if (fixNode.has("endLine")) {
                    quickFix.setEndLine(fixNode.get("endLine").asInt());
                }
                quickFixes.add(quickFix);
            }
            issue.setQuickFixes(quickFixes);
        }
        
        return issue;
    }
    
    // Inner classes for request DTOs
    private static class CodeAnalysisRequest {
        public final String code;
        
        public CodeAnalysisRequest(String code) {
            this.code = code;
        }
    }
    
    private static class AISuggestionRequest {
        public final String code;
        public final String question;
        
        public AISuggestionRequest(String code, String question) {
            this.code = code;
            this.question = question;
        }
    }
}
</file>

<file path="src/main/java/com/reviewer/codereviewer/controller/MainController.java">
package com.reviewer.codereviewer.controller;

import com.reviewer.codereviewer.client.ApiClientService;
import com.reviewer.codereviewer.client.dto.CodeAnalysisResult;
import com.reviewer.codereviewer.ui.MainView;
import com.reviewer.codereviewer.ui.ModernMainView;
import javafx.application.Platform;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.util.concurrent.CompletableFuture;
import java.util.logging.Level;
import java.util.logging.Logger;

public class MainController {
    private static final Logger logger = Logger.getLogger(MainController.class.getName());
    
    private MainView mainView;
    private ModernMainView modernView;
    private final ApiClientService apiClientService;
    
    /**
     * Constructor with default API client
     */
    public MainController() {
        this.apiClientService = new ApiClientService();
    }
    
    /**
     * Constructor with custom API client (useful for testing)
     */
    public MainController(ApiClientService apiClientService) {
        this.apiClientService = apiClientService;
    }
    
    /**
     * Set the modern view for callbacks
     * @param modernView the modern view instance
     */
    public void setModernView(ModernMainView modernView) {
        this.modernView = modernView;
    }
    
    private CodeAnalysisResult lastResult;
    private String currentFileName = "";

    public void start(Stage primaryStage) {
        mainView = new MainView(this);
        mainView.start(primaryStage);
        
        // Check server health on startup
        checkServerConnection();
    }
    
    /**
     * Check if the backend server is available
     */
    private void checkServerConnection() {
        apiClientService.checkServerHealth().whenComplete((isHealthy, ex) -> {
            Platform.runLater(() -> {
                if (!isHealthy || ex != null) {
                    String errorMsg = "⚠️ Cannot connect to backend server. Please ensure the server is running on http://localhost:8080";
                    if (modernView != null) {
                        modernView.displayError(errorMsg);
                    } else if (mainView != null) {
                        mainView.displayError(errorMsg);
                    }
                    logger.warning("Backend server is not available");
                } else {
                    logger.info("Successfully connected to backend server");
                }
            });
        });
    }

    /**
     * Analyzes the provided code using the backend API and updates the UI with results.
     * @param code The source code to analyze
     */
    public void analyzeCode(String code) {
        if (code == null || code.trim().isEmpty()) {
            if (modernView != null) {
                modernView.displayError("No code to analyze");
            } else if (mainView != null) {
                mainView.displayError("No code to analyze");
            }
            return;
        }
        
        // Show loading state
        Platform.runLater(() -> {
            if (modernView != null) {
                modernView.displayError("Analyzing code...");
            } else if (mainView != null) {
                mainView.displayError("Analyzing code...");
            }
        });
        
        // Use the API client to analyze code
        apiClientService.analyzeCode(code).whenComplete((result, ex) -> {
            Platform.runLater(() -> {
                if (ex != null) {
                    String errorMsg = "Analysis failed: " + ex.getMessage();
                    if (modernView != null) {
                        modernView.displayError(errorMsg);
                    } else if (mainView != null) {
                        mainView.displayError(errorMsg);
                    }
                    logger.log(Level.SEVERE, "Code analysis failed", ex);
                } else {
                    // Store the result for later use
                    lastResult = result;
                    
                    if (modernView != null) {
                        modernView.displayAnalysisResult(result);
                    } else if (mainView != null) {
                        mainView.displayAnalysisResult(result);
                    }
                    
                    // Store analysis record for trend tracking
                    if (!currentFileName.isEmpty()) {
                        storeAnalysisRecord(result);
                    }
                }
            });
        });
    }

    public void onOpenFile(Stage primaryStage) {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Open Java File");
        fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter("Java Files", "*.java"));
        File file = fileChooser.showOpenDialog(primaryStage);
        if (file != null) {
            try {
                String content = Files.readString(file.toPath());
                currentFileName = file.getName();
                mainView.displayCode(content);
                analyzeCode(content);
            } catch (Exception ex) {
                mainView.displayError("Failed to load file: " + ex.getMessage());
            }
        }
    }

    public void analyzeAndDisplay(String code) {
        // This method now delegates to the main analyzeCode method
        // which uses the API client
        analyzeCode(code);
    }
    
    private void storeAnalysisRecord(CodeAnalysisResult result) {
        try {
            // Create a simple analysis record for tracking
            String record = String.format(
                "{\"timestamp\":\"%s\", \"fileName\":\"%s\", \"totalIssues\":%d, \"errors\":%d, \"suggestions\":%d}",
                java.time.Instant.now().toString(),
                currentFileName,
                result.getTotalIssueCount(),
                result.getErrors().size(),
                result.getSuggestions().size()
            );
            
            // Append to analysis history file
            String homeDir = System.getProperty("user.home");
            String historyFile = homeDir + "/analysis_history.json";
            
            try (FileWriter writer = new FileWriter(historyFile, true)) {
                writer.write(record + "\n");
            }
        } catch (IOException e) {
            // Silently fail - trend tracking is not critical
            System.err.println("Failed to store analysis record: " + e.getMessage());
        }
    }
    
    /**
     * Handle the Ask AI button click (this method is no longer directly used - see onAskAiWithQuestion)
     * @deprecated Use onAskAiWithQuestion instead
     */
    @Deprecated
    public void onAskAi() {
        // Default question if none provided
        onAskAiWithQuestion(mainView.getCurrentCode(), "Please review this code and suggest improvements.");
    }
    
    /**
     * Handle AI request with a specific question using the backend API
     * @param code The code to analyze
     * @param question The user's question about the code
     */
    public void onAskAiWithQuestion(String code, String question) {
        if (code == null || code.trim().isEmpty()) {
            mainView.displayError("No code to analyze");
            return;
        }
        
        mainView.showAiLoading();
        mainView.clearAiSuggestion();
        
        logger.info("Starting AI request with question: \"" + question + "\"");
        
        // Show some immediate feedback
        Platform.runLater(() -> mainView.appendAiSuggestion("Processing your question: \"" + question + "\"\n\n"));
        
        logger.info("Using AI service from backend server");
        
        // Use the API client for AI suggestions with streaming
        CompletableFuture<Void> future = apiClientService.getCodeSuggestionStreaming(
                code, 
                question,
                // This consumer will be called for each chunk of the response
                chunk -> Platform.runLater(() -> mainView.appendAiSuggestion(chunk))
        );
        
        // Handle completion
        future.exceptionally(ex -> {
            Platform.runLater(() -> {
                logger.log(Level.SEVERE, "AI suggestion error", ex);
                mainView.appendAiSuggestion("\n\nError getting AI suggestion: " + ex.getMessage());
                mainView.appendAiSuggestion("\n\nTroubleshooting steps:\n" +
                        "1. Check that the backend server is running\n" +
                        "2. Verify your AI service configuration\n" +
                        "3. Check your internet connection\n" +
                        "4. Try with a simpler question");
                mainView.hideAiLoading();
            });
            return null;
        }).thenRun(() -> Platform.runLater(() -> {
            mainView.hideAiLoading();
        }));
    }

    public CodeAnalysisResult getLastResult() {
        return lastResult;
    }
}
</file>

<file path="src/main/java/com/reviewer/codereviewer/ui/MainView.java">
package com.reviewer.codereviewer.ui;

import com.reviewer.codereviewer.controller.MainController;
import com.reviewer.codereviewer.client.dto.CodeAnalysisResult;
import com.reviewer.codereviewer.client.dto.CodeIssue;
import com.reviewer.codereviewer.client.dto.QuickFix;
import javafx.animation.FadeTransition;
import javafx.application.Platform;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;
import javafx.scene.control.SplitPane;
import org.fxmisc.richtext.CodeArea;
import org.fxmisc.richtext.LineNumberFactory;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.scene.input.MouseEvent;
import javafx.stage.FileChooser;
import javafx.geometry.Pos;
import org.kordamp.ikonli.javafx.FontIcon;
import org.kordamp.ikonli.fontawesome5.FontAwesomeSolid;
import java.io.FileWriter;
import java.io.IOException;
import java.io.File;
import java.util.logging.Level;
import java.util.logging.Logger;

import javafx.scene.control.Tooltip;
import javafx.util.Duration;
import java.util.HashMap;
import java.util.Map;
import javafx.scene.layout.StackPane;
import javafx.geometry.Insets;
import javafx.scene.text.Text;
import javafx.scene.shape.Rectangle;
import java.util.concurrent.CompletableFuture;

public class MainView {
    private final MainController controller;
    private final Logger logger = Logger.getLogger(MainView.class.getName());
    private CodeArea codeArea;
    private TableView<CodeIssue> errorTableView;
    private TableView<CodeIssue> suggestionTableView;
    private ObservableList<CodeIssue> errors;
    private ObservableList<CodeIssue> suggestions;
    private FilteredList<CodeIssue> filteredErrors;
    private FilteredList<CodeIssue> filteredSuggestions;
    private Stage primaryStage;
    private Label detailsHeader;
    private TextArea detailsArea;
    private Map<Integer, String> errorTooltips = new HashMap<>();
    private VBox heatmapPane;
    
    // Search and filter components
    private TextField searchField;
    private ToggleButton criticalToggle;
    private ToggleButton warningToggle;
    private ToggleButton infoToggle;
    
    // Status bar
    private Label statusBar;
    
    // AI review components
    private TextArea aiSuggestionArea;
    private SplitPane codeSplitPane;
    private ProgressIndicator aiProgressIndicator;

    public MainView(MainController controller) {
        this.controller = controller;
    }

    public void start(Stage primaryStage) {
        this.primaryStage = primaryStage;
        primaryStage.setTitle("Java Code Reviewer");
        
        // Set minimum window size for usability
        primaryStage.setMinWidth(800);
        primaryStage.setMinHeight(600);

        BorderPane root = new BorderPane();
        root.setPrefSize(1400, 900);
        
        codeArea = new CodeArea();
        codeArea.setEditable(false);
        codeArea.setWrapText(false);
        // Do not set paragraph graphic factory here; set it only when code is loaded
        codeArea.getStyleClass().add("code-area");

        // Create heatmap pane with better sizing
        heatmapPane = new VBox();
        heatmapPane.setPrefWidth(25);
        heatmapPane.setMinWidth(25);
        heatmapPane.setMaxWidth(25);
        heatmapPane.getStyleClass().add("heatmap-pane");
        
        // Set proper growth behavior for code area
        codeArea.setMinWidth(400);
        codeArea.setPrefWidth(3000);
        HBox.setHgrow(codeArea, javafx.scene.layout.Priority.ALWAYS);
        
        // Create HBox to hold code area and heatmap with proper spacing
        HBox codeAndHeatmap = new HBox();
        codeAndHeatmap.getChildren().addAll(codeArea, heatmapPane);
        codeAndHeatmap.setSpacing(5);
        codeAndHeatmap.getStyleClass().add("code-heatmap-container");
        HBox.setHgrow(codeAndHeatmap, javafx.scene.layout.Priority.ALWAYS);
        
        // Initialize AI suggestion area
        aiSuggestionArea = new TextArea();
        aiSuggestionArea.setEditable(false);
        aiSuggestionArea.setWrapText(true);
        aiSuggestionArea.setPrefRowCount(10);
        aiSuggestionArea.setVisible(false);
        aiSuggestionArea.getStyleClass().add("ai-suggestion-area");
        
        // Progress indicator for AI review
        aiProgressIndicator = new ProgressIndicator();
        aiProgressIndicator.setMaxSize(20, 20);
        aiProgressIndicator.setVisible(false);

        // Create button for AI review
        Button reviewButton = new Button("🤖 AI Code Review");
        reviewButton.getStyleClass().add("ai-button");
        reviewButton.setOnAction(e -> requestAiReview());
        
        HBox aiButtonBox = new HBox(5, reviewButton, aiProgressIndicator);
        aiButtonBox.setAlignment(javafx.geometry.Pos.CENTER_RIGHT);
        aiButtonBox.setPadding(new Insets(5));
        
        // Create vertical split for code and AI area with proper resize behavior
        codeSplitPane = new SplitPane();
        codeSplitPane.setOrientation(javafx.geometry.Orientation.VERTICAL);
        VBox.setVgrow(codeSplitPane, javafx.scene.layout.Priority.ALWAYS);
        
        // Add a VBox to properly manage the code area and AI suggestion area
        VBox codeContainer = new VBox();
        codeContainer.getChildren().addAll(aiButtonBox, codeAndHeatmap);
        VBox.setVgrow(codeAndHeatmap, javafx.scene.layout.Priority.ALWAYS);
        
        // Setup AI suggestion area with proper resize behavior
        VBox aiContainer = new VBox();
        aiContainer.getChildren().add(aiSuggestionArea);
        VBox.setVgrow(aiSuggestionArea, javafx.scene.layout.Priority.ALWAYS);
        
        codeSplitPane.getItems().addAll(codeContainer, aiContainer);
        codeSplitPane.setDividerPositions(0.7);
        codeSplitPane.getStyleClass().add("code-split-pane");

        // Initialize collections and filtered lists
        errors = FXCollections.observableArrayList();
        suggestions = FXCollections.observableArrayList();
        filteredErrors = new FilteredList<>(errors, p -> true);
        filteredSuggestions = new FilteredList<>(suggestions, p -> true);
        
        // Create and configure error TableView
        errorTableView = new TableView<>(filteredErrors);
        TableColumn<CodeIssue, Integer> errorLineCol = new TableColumn<>("Line");
        TableColumn<CodeIssue, String> errorSeverityCol = new TableColumn<>("Severity");
        TableColumn<CodeIssue, String> errorMessageCol = new TableColumn<>("Message");
        
        errorLineCol.setCellValueFactory(new PropertyValueFactory<>("lineNumber"));
        errorSeverityCol.setCellValueFactory(new PropertyValueFactory<>("severity"));
        errorMessageCol.setCellValueFactory(new PropertyValueFactory<>("message"));
        
        errorTableView.getColumns().add(errorLineCol);
        errorTableView.getColumns().add(errorSeverityCol);
        errorTableView.getColumns().add(errorMessageCol);
        errorTableView.setPrefHeight(200);
        errorTableView.setMinHeight(150);
        errorTableView.getStyleClass().add("table-view");
        
        // Create and configure suggestion TableView
        suggestionTableView = new TableView<>(filteredSuggestions);
        TableColumn<CodeIssue, Integer> suggLineCol = new TableColumn<>("Line");
        TableColumn<CodeIssue, String> suggMessageCol = new TableColumn<>("Message");
        
        suggLineCol.setCellValueFactory(new PropertyValueFactory<>("lineNumber"));
        suggMessageCol.setCellValueFactory(new PropertyValueFactory<>("message"));
        
        suggestionTableView.getColumns().add(suggLineCol);
        suggestionTableView.getColumns().add(suggMessageCol);
        suggestionTableView.setPrefHeight(250);
        suggestionTableView.setMinHeight(200);
        suggestionTableView.getStyleClass().add("table-view");
        
        // Add selection listeners
        errorTableView.setOnMouseClicked(this::onIssueClicked);
        suggestionTableView.setOnMouseClicked(this::onIssueClicked);
        
        // Create filter controls
        searchField = new TextField();
        searchField.setPromptText("Search issues...");
        searchField.getStyleClass().add("search-field");
        
        criticalToggle = new ToggleButton("Critical");
        warningToggle = new ToggleButton("Warning");
        infoToggle = new ToggleButton("Info");
        
        HBox filterBox = new HBox(8);
        filterBox.getChildren().addAll(
            searchField,
            new Separator(javafx.geometry.Orientation.VERTICAL),
            criticalToggle, warningToggle, infoToggle
        );
        filterBox.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        filterBox.getStyleClass().add("filter-box");
        
        // Setup filter listeners
        setupFilterListeners();

        // Enhanced headers with icons
        Label errorHeader = new Label("🚨 Critical Issues");
        errorHeader.getStyleClass().add("section-header");
        errorHeader.getStyleClass().add("error-header");
        
        Label suggestionHeader = new Label("💡 Suggestions");
        suggestionHeader.getStyleClass().add("section-header");
        suggestionHeader.getStyleClass().add("suggestion-header");

        detailsHeader = new Label("📋 Issue Details");
        detailsHeader.getStyleClass().add("section-header");
        detailsHeader.getStyleClass().add("details-header");
        
        detailsArea = new TextArea();
        detailsArea.setEditable(false);
        detailsArea.setWrapText(true);
        detailsArea.setPrefRowCount(8);
        detailsArea.setMinHeight(120);
        detailsArea.getStyleClass().add("details-area");

        // Improved right pane layout with better spacing
        VBox rightPane = new VBox();
        rightPane.setSpacing(15);
        rightPane.setPadding(new Insets(15));
        rightPane.getChildren().addAll(
            errorHeader, filterBox, errorTableView, 
            suggestionHeader, suggestionTableView, 
            detailsHeader, detailsArea
        );
        rightPane.getStyleClass().add("right-pane");
        rightPane.setMaxWidth(400);
        rightPane.setPrefWidth(350);
        rightPane.setMinWidth(300);

        // Main split pane with better proportions
        SplitPane mainSplitPane = new SplitPane();
        mainSplitPane.getItems().addAll(codeSplitPane, rightPane);
        mainSplitPane.setDividerPositions(0.7);
        mainSplitPane.getStyleClass().add("main-split-pane");
        
        // Set proper growth behavior for the code area side of the split pane
        codeSplitPane.setMinWidth(500);
        codeSplitPane.setPrefWidth(1000);
        SplitPane.setResizableWithParent(codeSplitPane, true);
        SplitPane.setResizableWithParent(rightPane, false);

        MenuBar menuBar = new MenuBar();
        Menu fileMenu = new Menu("File");
        // Create menu items with icons
        MenuItem openItem = new MenuItem("Open Java File...");
        FontIcon openIcon = new FontIcon(FontAwesomeSolid.FOLDER_OPEN);
        openIcon.setIconSize(16);
        openItem.setGraphic(openIcon);
        openItem.setAccelerator(new KeyCodeCombination(KeyCode.O, KeyCombination.SHORTCUT_DOWN));
        openItem.setOnAction(e -> controller.onOpenFile(primaryStage));
        
        MenuItem exportItem = new MenuItem("Export Analysis as Markdown");
        FontIcon exportIcon = new FontIcon(FontAwesomeSolid.DOWNLOAD);
        exportIcon.setIconSize(16);
        exportItem.setGraphic(exportIcon);
        exportItem.setAccelerator(new KeyCodeCombination(KeyCode.E, KeyCombination.SHORTCUT_DOWN));
        exportItem.setOnAction(e -> exportAnalysisAsMarkdown());
        fileMenu.getItems().addAll(openItem, exportItem);
        
        // Create AI menu
        Menu aiMenu = new Menu("AI");
        MenuItem toggleAiItem = new MenuItem("Toggle AI Suggestion Panel");
        FontIcon aiIcon = new FontIcon(FontAwesomeSolid.ROBOT);
        aiIcon.setIconSize(16);
        toggleAiItem.setGraphic(aiIcon);
        toggleAiItem.setOnAction(e -> toggleAiSuggestionPanel());
        aiMenu.getItems().add(toggleAiItem);
        
        // Create Edit menu for undo/redo
        Menu editMenu = new Menu("Edit");
        MenuItem undoItem = new MenuItem("Undo");
        undoItem.setAccelerator(new KeyCodeCombination(KeyCode.Z, KeyCombination.SHORTCUT_DOWN));
        undoItem.setOnAction(e -> {
            statusBar.setText("Undo/Redo functionality has been moved to the backend server");
        });
        FontIcon undoIcon = new FontIcon(FontAwesomeSolid.UNDO);
        undoIcon.setIconSize(16);
        undoItem.setGraphic(undoIcon);
        
        MenuItem redoItem = new MenuItem("Redo");
        redoItem.setAccelerator(new KeyCodeCombination(KeyCode.Z, KeyCombination.SHORTCUT_DOWN, KeyCombination.SHIFT_DOWN));
        redoItem.setOnAction(e -> {
            statusBar.setText("Undo/Redo functionality has been moved to the backend server");
        });
        FontIcon redoIcon = new FontIcon(FontAwesomeSolid.REDO);
        redoIcon.setIconSize(16);
        redoItem.setGraphic(redoIcon);
        
        editMenu.getItems().addAll(undoItem, redoItem);
        
        menuBar.getMenus().addAll(fileMenu, editMenu, aiMenu);
        menuBar.getStyleClass().add("menu-bar");

        // Add the AI button to the code area header
        HBox codeHeader = new HBox();
        codeHeader.setAlignment(javafx.geometry.Pos.CENTER_RIGHT);
        codeHeader.getChildren().add(aiButtonBox);
        codeHeader.setPadding(new Insets(5, 10, 5, 10));
        codeHeader.setSpacing(10);
        
        VBox codeContainerWithHeader = new VBox(codeHeader, mainSplitPane);
        VBox.setVgrow(mainSplitPane, javafx.scene.layout.Priority.ALWAYS);
        
        // Create and setup status bar
        statusBar = new Label("Ready");
        statusBar.getStyleClass().add("status-bar");
        
        root.setTop(menuBar);
        root.setCenter(codeContainerWithHeader);
        root.setBottom(statusBar);

        Scene scene = new Scene(root);
        scene.getStylesheets().add(getClass().getResource("/app-theme.css").toExternalForm());
        scene.getStylesheets().add(getClass().getResource("/ai-style.css").toExternalForm());

        // Add keyboard shortcuts for undo/redo
        scene.getAccelerators().put(
            new KeyCodeCombination(KeyCode.Z, KeyCombination.SHORTCUT_DOWN),
            () -> statusBar.setText("Undo/Redo functionality has been moved to the backend server")
        );
        
        scene.getAccelerators().put(
            new KeyCodeCombination(KeyCode.Z, KeyCombination.SHORTCUT_DOWN, KeyCombination.SHIFT_DOWN),
            () -> statusBar.setText("Undo/Redo functionality has been moved to the backend server")
        );
        
        primaryStage.setScene(scene);
        primaryStage.setMinWidth(1200);
        primaryStage.setMinHeight(800);
        primaryStage.show();
    }

    public void displayCode(String code) {
        codeArea.replaceText(code);
        codeArea.setParagraphGraphicFactory(LineNumberFactory.get(codeArea));
        clearAllLineHighlights();
        onCodeLoaded();
    }

    public void displayError(String message) {
        errors.clear();
        suggestions.clear();
    }

    public void clearCodeArea() {
        codeArea.clear();
        codeArea.setParagraphGraphicFactory(null);
    }

    public void displayAnalysisResult(CodeAnalysisResult result) {
        errors.setAll(result.getErrors()); // Show errors in the list
        suggestions.setAll(result.getSuggestions());
        clearAllLineHighlights();
        errorTooltips.clear();
        for (CodeIssue issue : result.getErrors()) {
            String styleClass = getHighlightClass(issue);
            highlightLine(issue.getLine(), styleClass);
            errorTooltips.put(issue.getLine(), issue.getMessage());
        }
        // Set paragraph graphic factory for tooltips
        codeArea.setParagraphGraphicFactory(line -> {
            int lineNum = line + 1;
            Text lineNo = new Text(String.valueOf(lineNum));
            StackPane graphic = new StackPane(lineNo);
            graphic.getStyleClass().add("lineno-graphic");
            if (errorTooltips.containsKey(lineNum)) {
                Tooltip tooltip = new Tooltip(errorTooltips.get(lineNum));
                tooltip.setShowDelay(Duration.millis(100));
                Tooltip.install(graphic, tooltip);
                // Add severity class for color
                String severityClass = "";
                String msg = errorTooltips.get(lineNum).toLowerCase();
                if (msg.contains("critical")) severityClass = "critical-error-highlight";
                else if (msg.contains("warning")) severityClass = "warning-highlight";
                else if (msg.contains("info")) severityClass = "info-highlight";
                if (!severityClass.isEmpty()) graphic.getStyleClass().add(severityClass);
            }
            return graphic;
        });
        for (CodeIssue issue : suggestions) {
            if (issue.getType() == CodeIssue.Type.SUGGESTION) {
                highlightLine(issue.getLine(), "suggestion-highlight");
            }
        }
        
        // Render heatmap
        renderHeatmap(result);
    }

    private String getHighlightClass(CodeIssue issue) {
        if ("critical".equalsIgnoreCase(issue.getSeverity())) {
            return "critical-error-highlight";
        } else if ("warning".equalsIgnoreCase(issue.getSeverity())) {
            return "warning-highlight";
        } else if ("info".equalsIgnoreCase(issue.getSeverity())) {
            return "info-highlight";
        } else {
            return "long-method-highlight";
        }
    }



    private void setupFilterListeners() {
        // Setup search field listener
        searchField.textProperty().addListener((obs, oldVal, newVal) -> {
            String searchText = newVal.toLowerCase();
            filteredErrors.setPredicate(issue -> 
                issue.getMessage().toLowerCase().contains(searchText) &&
                matchesSeverityFilter(issue)
            );
            filteredSuggestions.setPredicate(issue ->
                issue.getMessage().toLowerCase().contains(searchText)
            );
        });

        // Setup severity toggle listeners
        ToggleButton[] toggles = {criticalToggle, warningToggle, infoToggle};
        for (ToggleButton toggle : toggles) {
            toggle.setSelected(true);
            toggle.selectedProperty().addListener((obs, oldVal, newVal) -> {
                filteredErrors.setPredicate(issue ->
                    issue.getMessage().toLowerCase().contains(searchField.getText().toLowerCase()) &&
                    matchesSeverityFilter(issue)
                );
            });
        }
    }

    private boolean matchesSeverityFilter(CodeIssue issue) {
        String severity = issue.getSeverity().toLowerCase();
        return (severity.equals("critical") && criticalToggle.isSelected()) ||
               (severity.equals("warning") && warningToggle.isSelected()) ||
               (severity.equals("info") && infoToggle.isSelected());
    }

    private void onIssueClicked(MouseEvent event) {
        Object source = event.getSource();
        if (!(source instanceof TableView<?>)) {
            return;
        }
        @SuppressWarnings("unchecked")
        TableView<CodeIssue> tableView = (TableView<CodeIssue>) source;
        CodeIssue selected = tableView.getSelectionModel().getSelectedItem();
        if (selected != null && selected.getLine() > 0) {
            // Clear any previous selected highlights first
            clearAllLineHighlights();
            // Re-apply all issue highlights
            for (CodeIssue issue : errors) {
                String styleClass = getHighlightClass(issue);
                highlightLine(issue.getLine(), styleClass);
            }
            for (CodeIssue issue : suggestions) {
                if (issue.getType() == CodeIssue.Type.SUGGESTION) {
                    highlightLine(issue.getLine(), "suggestion-highlight");
                }
            }
            // Now highlight the selected line
            highlightLine(selected.getLine(), "selected-issue-highlight");
            showIssueDetails(selected);
            
            // Scroll to the selected line and center it in the viewport
            Platform.runLater(() -> {
                codeArea.showParagraphAtCenter(selected.getLine() - 1);
                // Also request focus on the code area for better UX
                codeArea.requestFocus();
            });
        }
    }

    private void showIssueDetails(CodeIssue issue) {
        // Create a VBox to hold both the details and quick fix buttons
        VBox detailsContainer = new VBox(10); // 10px spacing
        
        // Add the text details
        StringBuilder sb = new StringBuilder();
        sb.append("Line: ").append(issue.getLine()).append("\n");
        sb.append("Type: ").append(issue.getType()).append("\n");
        sb.append("Severity: ").append(issue.getSeverity()).append("\n");
        sb.append("Message: ").append(issue.getMessage()).append("\n");
        
        TextArea textDetails = new TextArea(sb.toString());
        textDetails.setEditable(false);
        textDetails.setWrapText(true);
        textDetails.setPrefRowCount(4);
        
        detailsContainer.getChildren().add(textDetails);
        
        // If there are quick fixes available, add buttons for them
        if (issue.hasQuickFixes()) {
            HBox quickFixButtons = new HBox(5); // 5px spacing
            quickFixButtons.setAlignment(Pos.CENTER_LEFT);
            
            for (QuickFix fix : issue.getQuickFixes()) {
                Button fixButton = new Button(fix.getDescription());
                fixButton.getStyleClass().add("quick-fix-button");
                
                // Add tooltip with detailed description
                Tooltip tooltip = new Tooltip(fix.getDescription());
                tooltip.setShowDelay(Duration.millis(200));
                fixButton.setTooltip(tooltip);
                
                // Add click handler
                fixButton.setOnAction(e -> applyQuickFix(issue, fix));
                
                quickFixButtons.getChildren().add(fixButton);
            }
            
            detailsContainer.getChildren().add(quickFixButtons);
        }
        
        detailsArea.setText(sb.toString());
    }

    private void highlightLine(int lineNumber, String styleClass) {
        if (lineNumber < 1) return;
        int start = codeArea.position(lineNumber - 1, 0).toOffset();
        int end = codeArea.position(lineNumber - 1, codeArea.getParagraph(lineNumber - 1).length()).toOffset();
        codeArea.setStyleClass(start, end, styleClass);
    }

    private void clearAllLineHighlights() {
        codeArea.setStyleSpans(0, codeArea.getStyleSpans(0, codeArea.getLength()));
    }
    
    private void renderHeatmap(CodeAnalysisResult result) {
        // Clear existing heatmap
        heatmapPane.getChildren().clear();
        
        // Get total number of lines
        int totalLines = codeArea.getParagraphs().size();
        
        // Create a map to track issue density per line
        Map<Integer, String> lineSeverity = new HashMap<>();
        
        // Process all issues and determine severity for each line
        for (CodeIssue issue : result.getErrors()) {
            int lineNum = issue.getLine();
            String currentSeverity = lineSeverity.get(lineNum);
            String issueSeverity = issue.getSeverity();
            
            // Prioritize severity: critical > warning > info
            if (currentSeverity == null || 
                (issueSeverity.equalsIgnoreCase("critical") && !currentSeverity.equalsIgnoreCase("critical")) ||
                (issueSeverity.equalsIgnoreCase("warning") && currentSeverity.equalsIgnoreCase("info"))) {
                lineSeverity.put(lineNum, issueSeverity);
            }
        }
        
        // Create rectangles for each line
        for (int lineNumber = 1; lineNumber <= totalLines; lineNumber++) {
            Rectangle rect = new Rectangle();
            rect.setHeight(3);
            rect.setWidth(25); // Match the heatmap pane width
            
            // Set color based on severity
            String severity = lineSeverity.get(lineNumber);
            if (severity != null) {
                if (severity.equalsIgnoreCase("critical")) {
                    rect.setFill(javafx.scene.paint.Color.web("#dc2626"));
                } else if (severity.equalsIgnoreCase("warning")) {
                    rect.setFill(javafx.scene.paint.Color.web("#fbbf24"));
                } else {
                    rect.setFill(javafx.scene.paint.Color.web("#60a5fa"));
                }
            } else {
                rect.setFill(javafx.scene.paint.Color.web("#34d399"));
            }
            
            // Add click handler to scroll to line
            final int lineNum = lineNumber;
            rect.setOnMouseClicked(e -> codeArea.showParagraphAtTop(lineNum - 1));
            
            heatmapPane.getChildren().add(rect);
        }
    }

    private void exportAnalysisAsMarkdown() {
        if (errors.isEmpty() && suggestions.isEmpty()) {
            statusBar.setText("No analysis to export");
            return;
        }
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Save Analysis Report");
        fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter("Markdown Files", "*.md"));
        File file = fileChooser.showSaveDialog(primaryStage);
        if (file != null) {
            try (FileWriter writer = new FileWriter(file)) {
                writer.write("# Code Analysis Report\n\n");
                writer.write("## Errors\n");
                for (CodeIssue issue : errors) {
                    writer.write("- Line " + issue.getLine() + " [" + issue.getSeverity() + "]: " + issue.getMessage() + "\n");
                }
                writer.write("\n## Suggestions\n");
                for (CodeIssue issue : suggestions) {
                    writer.write("- Line " + issue.getLine() + ": " + issue.getMessage() + "\n");
                }
                statusBar.setText("Analysis exported to " + file.getName());
            } catch (IOException ex) {
                statusBar.setText("Failed to export: " + ex.getMessage());
            }
        }
    }

    public String getCurrentCode() {
        return codeArea.getText();
    }
    
    public void replaceCodeText(String newCode) {
        codeArea.replaceText(newCode);
    }
    
    /**
     * Toggle visibility of the AI suggestion panel
     */
    public void toggleAiSuggestionPanel() {
        boolean isVisible = aiSuggestionArea.isVisible();
        
        FadeTransition fade = new FadeTransition(Duration.millis(300), aiSuggestionArea);
        fade.setFromValue(isVisible ? 1.0 : 0.0);
        fade.setToValue(isVisible ? 0.0 : 1.0);
        
        if (isVisible) {
            fade.setOnFinished(e -> {
                aiSuggestionArea.setVisible(false);
                codeSplitPane.setDividerPositions(1.0);
            });
        } else {
            aiSuggestionArea.setVisible(true);
            aiSuggestionArea.setOpacity(0);
            codeSplitPane.setDividerPositions(0.7);
            if (aiSuggestionArea.getText().isEmpty()) {
                aiSuggestionArea.setText("Ask AI for suggestions about your code by clicking the 'Ask AI' button.");
            }
        }
        
        fade.play();
        
        // Update status bar
        statusBar.setText(isVisible ? "AI suggestion panel hidden" : "AI suggestion panel shown");
    }
    
    /**
     * Show loading indicator while waiting for AI response
     */
    public void showAiLoading() {
        aiProgressIndicator.setVisible(true);
    }
    
    /**
     * Hide loading indicator
     */
    public void hideAiLoading() {
        aiProgressIndicator.setVisible(false);
    }
    
    /**
     * Show AI suggestion in the panel and ensure it's visible
     */
    public void showAiSuggestion(String suggestion) {
        aiSuggestionArea.setText(suggestion);
        if (!aiSuggestionArea.isVisible()) {
            aiSuggestionArea.setVisible(true);
            codeSplitPane.setDividerPositions(0.7);
        }
    }
    
    /**
     * Append to the AI suggestion text (for streaming responses)
     */
    public void appendAiSuggestion(String text) {
        aiSuggestionArea.appendText(text);
        if (!aiSuggestionArea.isVisible()) {
            aiSuggestionArea.setVisible(true);
            codeSplitPane.setDividerPositions(0.7);
        }
    }
    
    /**
     * Clear the AI suggestion panel
     */
    public void clearAiSuggestion() {
        aiSuggestionArea.clear();
    }
    
    /**
     * Applies a quick fix to the code and updates the UI.
     * @param issue The issue to fix
     * @param fix The quick fix to apply
     */
    private void applyQuickFix(CodeIssue issue, QuickFix fix) {
        statusBar.setText("Quick fix functionality has been moved to the backend server");
        
        // In a real implementation, this would send a request to the backend
        // to apply the quick fix and then update the UI with the result
        
        logger.info("Quick fix requested: " + fix.getDescription() + " for issue: " + issue.getMessage());
    }
    
    /**
     * Update the UI when code is loaded
     */
    public void onCodeLoaded() {
        aiSuggestionArea.setVisible(true);
    }
    
    /**
     * Request a full AI review of the code
     */
    private void requestAiReview() {
        String code = getCurrentCode();
        if (code == null || code.trim().isEmpty()) {
            displayError("No code to analyze");
            return;
        }
        
        showAiLoading();
        clearAiSuggestion();
        
        // Show AI suggestion area with initial message
        aiSuggestionArea.setVisible(true);
        codeSplitPane.setDividerPositions(0.7);
        appendAiSuggestion("Initializing AI code review...\n\n");
        
        // Use the controller's method which now talks to the backend
        String reviewPrompt = "Please provide a comprehensive code review focusing on:\n" +
                             "1. Code quality issues\n" +
                             "2. Performance optimizations\n" +
                             "3. Security concerns\n" +
                             "4. Best practices recommendations\n\n" +
                             "FORMAT: Provide a structured review with specific line numbers where applicable. Start with a brief summary.";
        
        // Use the controller's AI method which now uses the API client
        controller.onAskAiWithQuestion(code, reviewPrompt);
    }
}
</file>

<file path="src/main/java/com/reviewer/codereviewer/ui/ModernMainView.java">
package com.reviewer.codereviewer.ui;

import com.reviewer.codereviewer.controller.MainController;
import com.reviewer.codereviewer.client.dto.CodeAnalysisResult;
import com.reviewer.codereviewer.client.dto.CodeIssue;
import com.reviewer.codereviewer.client.dto.QuickFix;
import javafx.application.Platform;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.scene.layout.*;
import org.fxmisc.richtext.CodeArea;
import org.fxmisc.richtext.LineNumberFactory;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.scene.input.MouseEvent;
import javafx.stage.FileChooser;
import javafx.geometry.Pos;
import javafx.geometry.Insets;
import javafx.scene.shape.Rectangle;
import javafx.scene.paint.Color;
import java.io.FileWriter;
import java.io.IOException;
import java.io.File;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Modern, professional UI for Code Reviewer with improved information hierarchy
 * and clean visual design following modern UI/UX principles.
 */
public class ModernMainView {
    private static final Logger logger = Logger.getLogger(ModernMainView.class.getName());
    
    private final MainController controller;
    
        // UI Components
    private CodeArea codeArea;
    private TabPane analysisTabPane;
    private TableView<CodeIssue> allIssuesTable;
    private TableView<CodeIssue> criticalIssuesTable;
    private TableView<CodeIssue> warningsTable;
    private TableView<CodeIssue> suggestionsTable;
    private Label statusLabel;
    private ProgressBar analysisProgressBar;
    private Button analyzeButton;
    private Button aiReviewButton;
    private VBox issueDetailsPane;
    private ScrollPane detailsScrollPane;
    private Label filePathLabel;
    private VBox heatmapPane;
    private TextField searchField;
    private ProgressIndicator aiProgressIndicator;
    private TextArea aiSuggestionArea;
    private SplitPane mainSplit;
    private SplitPane outerSplit;
    private BorderPane content;
    
    // Data and State
    private ObservableList<CodeIssue> allIssues = FXCollections.observableArrayList();
    private ObservableList<CodeIssue> criticalIssues = FXCollections.observableArrayList();
    private ObservableList<CodeIssue> warnings = FXCollections.observableArrayList();
    private ObservableList<CodeIssue> suggestions = FXCollections.observableArrayList();
    private FilteredList<CodeIssue> filteredIssues;
    private File currentFile;
    private Map<Integer, Rectangle> heatmapRectangles = new HashMap<>();
    public ModernMainView(MainController controller) {
        this.controller = controller;
        this.filteredIssues = new FilteredList<>(allIssues);
        setupKeyboardShortcuts();
    }
    
    public Scene createScene() {
        BorderPane root = createMainLayout();
        Scene scene = new Scene(root, 1400, 900);
        
        // Apply modern theme
        scene.getStylesheets().clear();
        scene.getStylesheets().add(getClass().getResource("/modern-theme.css").toExternalForm());
        
        return scene;
    }
    
    private BorderPane createMainLayout() {
        BorderPane root = new BorderPane();
        root.getStyleClass().add("main-container");
        
        // Create header with file info and controls
        VBox header = createHeader();
        root.setTop(header);
        
        // Create main content area with improved layout
        BorderPane content = createContentArea();
        root.setCenter(content);
        
        // Create status bar
        HBox statusBar = createStatusBar();
        root.setBottom(statusBar);
        
        return root;
    }
    
    private VBox createHeader() {
        VBox header = new VBox();
        header.getStyleClass().add("header-bar");
        
        // Create menu bar
        MenuBar menuBar = createMenuBar();
        
        // Create toolbar with file operations and analysis controls
        HBox toolbar = createToolbar();
        
        header.getChildren().addAll(menuBar, toolbar);
        return header;
    }
    
    private MenuBar createMenuBar() {
        MenuBar menuBar = new MenuBar();
        
        // File Menu
        Menu fileMenu = new Menu("File");
        MenuItem openItem = new MenuItem("Open File...");
        openItem.setAccelerator(new KeyCodeCombination(KeyCode.O, KeyCombination.CONTROL_DOWN));
        openItem.setOnAction(e -> openFile());
        
        MenuItem saveItem = new MenuItem("Save");
        saveItem.setAccelerator(new KeyCodeCombination(KeyCode.S, KeyCombination.CONTROL_DOWN));
        saveItem.setOnAction(e -> saveFile());
        
        MenuItem exitItem = new MenuItem("Exit");
        exitItem.setOnAction(e -> Platform.exit());
        
        fileMenu.getItems().addAll(openItem, saveItem, new SeparatorMenuItem(), exitItem);
        
        // Analysis Menu
        Menu analysisMenu = new Menu("Analysis");
        MenuItem analyzeItem = new MenuItem("Analyze Code");
        analyzeItem.setAccelerator(new KeyCodeCombination(KeyCode.F5));
        analyzeItem.setOnAction(e -> analyzeCode());
        
        MenuItem aiReviewItem = new MenuItem("AI Code Review");
        aiReviewItem.setAccelerator(new KeyCodeCombination(KeyCode.F6));
        aiReviewItem.setOnAction(e -> requestAiReview());
        
        analysisMenu.getItems().addAll(analyzeItem, aiReviewItem);
        
        // View Menu
        Menu viewMenu = new Menu("View");
        CheckMenuItem showHeatmapItem = new CheckMenuItem("Show Heatmap");
        showHeatmapItem.setSelected(true);
        showHeatmapItem.setOnAction(e -> toggleHeatmap(showHeatmapItem.isSelected()));
        
        viewMenu.getItems().add(showHeatmapItem);
        
        menuBar.getMenus().addAll(fileMenu, analysisMenu, viewMenu);
        return menuBar;
    }
    
    private HBox createToolbar() {
        HBox toolbar = new HBox(16);
        toolbar.getStyleClass().add("toolbar");
        toolbar.setAlignment(Pos.CENTER_LEFT);
        
        // File path display
        filePathLabel = new Label("No file selected");
        filePathLabel.getStyleClass().add("file-path-label");
        
        // Spacer
        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        
        // Analysis controls
        analyzeButton = new Button("📊 Analyze Code");
        analyzeButton.getStyleClass().addAll("button", "primary-button");
        analyzeButton.setOnAction(e -> analyzeCode());
        
        aiReviewButton = new Button("🤖 AI Review");
        aiReviewButton.getStyleClass().addAll("button", "ai-button");
        aiReviewButton.setOnAction(e -> requestAiReview());
        
        // Progress indicator
        analysisProgressBar = new ProgressBar();
        analysisProgressBar.setVisible(false);
        analysisProgressBar.setPrefWidth(200);
        
        toolbar.getChildren().addAll(
            filePathLabel, spacer, 
            analyzeButton, aiReviewButton, analysisProgressBar
        );
        
        return toolbar;
    }
    
    private BorderPane createContentArea() {
        content = new BorderPane();
        content.getStyleClass().add("content-area");
        
        // Left: Code editor with heatmap
        VBox codeSection = createCodeSection();
        
        // Center: Analysis results
        VBox analysisSection = createAnalysisSection();
        
        // Split pane for resizable layout (initially just code and analysis)
        mainSplit = new SplitPane();
        mainSplit.getItems().addAll(codeSection, analysisSection);
        mainSplit.setDividerPositions(0.65);
        
        // Initially show only the main split without details panel
        content.setCenter(mainSplit);
        return content;
    }
    
    private VBox createCodeSection() {
        VBox codeSection = new VBox(12);
        codeSection.getStyleClass().add("card");
        
        // Code editor header
        HBox codeHeader = new HBox(12);
        codeHeader.setAlignment(Pos.CENTER_LEFT);
        
        Label codeTitle = new Label("📝 Code Editor");
        codeTitle.getStyleClass().addAll("card-header", "section-header");
        
        // Search in code
        TextField codeSearchField = new TextField();
        codeSearchField.setPromptText("Search in code...");
        codeSearchField.getStyleClass().add("search-field");
        codeSearchField.setPrefWidth(200);
        
        Region codeSpacerJavaFX = new Region();
        HBox.setHgrow(codeSpacerJavaFX, Priority.ALWAYS);
        
        codeHeader.getChildren().addAll(codeTitle, codeSpacerJavaFX, codeSearchField);
        
        // Code area with heatmap
        HBox codeContainer = createCodeAreaWithHeatmap();
        VBox.setVgrow(codeContainer, Priority.ALWAYS);
        
        codeSection.getChildren().addAll(codeHeader, codeContainer);
        return codeSection;
    }
    
    private HBox createCodeAreaWithHeatmap() {
        HBox container = new HBox(0);
        
        // Initialize code area
        codeArea = new CodeArea();
        codeArea.setParagraphGraphicFactory(LineNumberFactory.get(codeArea));
        codeArea.getStyleClass().add("code-area");
        codeArea.setWrapText(false);
        
        // Enable syntax highlighting (basic)
        codeArea.textProperty().addListener((obs, oldText, newText) -> {
            // Basic Java syntax highlighting could be added here
        });
        
        // Heatmap panel
        heatmapPane = new VBox();
        heatmapPane.getStyleClass().add("heatmap-pane");
        heatmapPane.setPrefWidth(20);
        heatmapPane.setMinWidth(20);
        heatmapPane.setMaxWidth(20);
        
        // Set growth priorities
        HBox.setHgrow(codeArea, Priority.ALWAYS);
        
        container.getChildren().addAll(codeArea, heatmapPane);
        return container;
    }
    
    private VBox createAnalysisSection() {
        VBox analysisSection = new VBox(16);
        analysisSection.getStyleClass().add("card");
        analysisSection.setPrefWidth(450);
        analysisSection.setMinWidth(400);
        
        // Analysis header with search
        HBox analysisHeader = createAnalysisHeader();
        
        // Tab pane for different issue types
        analysisTabPane = createAnalysisTabPane();
        VBox.setVgrow(analysisTabPane, Priority.ALWAYS);
        
        analysisSection.getChildren().addAll(analysisHeader, analysisTabPane);
        return analysisSection;
    }
    
    private HBox createAnalysisHeader() {
        HBox header = new HBox(12);
        header.setAlignment(Pos.CENTER_LEFT);
        
        Label title = new Label("🔍 Analysis Results");
        title.getStyleClass().addAll("card-header", "section-header");
        
        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        
        // Global search for issues
        searchField = new TextField();
        searchField.setPromptText("Search issues...");
        searchField.getStyleClass().add("search-field");
        searchField.setPrefWidth(180);
        
        // Setup search functionality
        searchField.textProperty().addListener((obs, oldVal, newVal) -> {
            updateIssueFilter();
        });
        
        header.getChildren().addAll(title, spacer, searchField);
        return header;
    }
    
    private TabPane createAnalysisTabPane() {
        TabPane tabPane = new TabPane();
        tabPane.setTabClosingPolicy(TabPane.TabClosingPolicy.UNAVAILABLE);
        
        // Critical Issues Tab
        Tab criticalTab = new Tab();
        criticalTab.setText("🚨 Critical");
        criticalTab.setContent(createIssueTable(criticalIssuesTable = new TableView<>(), "critical"));
        
        // Warnings Tab
        Tab warningsTab = new Tab();
        warningsTab.setText("⚠️ Warnings");
        warningsTab.setContent(createIssueTable(warningsTable = new TableView<>(), "warning"));
        
        // Suggestions Tab
        Tab suggestionsTab = new Tab();
        suggestionsTab.setText("💡 Suggestions");
        suggestionsTab.setContent(createIssueTable(suggestionsTable = new TableView<>(), "suggestion"));
        
        // AI Review Tab
        Tab aiTab = new Tab();
        aiTab.setText("🤖 AI Review");
        aiTab.setContent(createAiReviewSection());
        
        tabPane.getTabs().addAll(criticalTab, warningsTab, suggestionsTab, aiTab);
        return tabPane;
    }
    
    private ScrollPane createIssueTable(TableView<CodeIssue> table, String type) {
        // Configure table
        table.getStyleClass().add("table-view");
        
        // Line column
        TableColumn<CodeIssue, Integer> lineCol = new TableColumn<>("Line");
        lineCol.setCellValueFactory(new PropertyValueFactory<>("lineNumber"));
        lineCol.setPrefWidth(50);
        lineCol.setMaxWidth(50);
        
        // Severity column with custom cell factory
        TableColumn<CodeIssue, String> severityCol = new TableColumn<>("Severity");
        severityCol.setCellValueFactory(new PropertyValueFactory<>("severity"));
        severityCol.setPrefWidth(80);
        severityCol.setCellFactory(column -> new TableCell<CodeIssue, String>() {
            @Override
            protected void updateItem(String severity, boolean empty) {
                super.updateItem(severity, empty);
                if (empty || severity == null) {
                    setText(null);
                    setGraphic(null);
                } else {
                    Label severityLabel = new Label(severity.toUpperCase());
                    severityLabel.getStyleClass().add("severity-" + severity.toLowerCase());
                    setGraphic(severityLabel);
                    setText(null);
                }
            }
        });
        
        // Message column
        TableColumn<CodeIssue, String> messageCol = new TableColumn<>("Description");
        messageCol.setCellValueFactory(new PropertyValueFactory<>("message"));
        messageCol.setPrefWidth(280);
        messageCol.setCellFactory(column -> new TableCell<CodeIssue, String>() {
            @Override
            protected void updateItem(String message, boolean empty) {
                super.updateItem(message, empty);
                if (empty || message == null) {
                    setText(null);
                } else {
                    setText(message);
                    setWrapText(true);
                }
            }
        });
        
        table.getColumns().addAll(lineCol, severityCol, messageCol);
        
        // Handle row selection
        table.setOnMouseClicked(this::onIssueClicked);
        
        // Set data based on type
        switch (type) {
            case "critical":
                table.setItems(criticalIssues);
                break;
            case "warning":
                table.setItems(warnings);
                break;
            case "suggestion":
                table.setItems(suggestions);
                break;
        }
        
        ScrollPane scrollPane = new ScrollPane(table);
        scrollPane.setFitToWidth(true);
        scrollPane.setFitToHeight(true);
        return scrollPane;
    }
    
    private VBox createAiReviewSection() {
        VBox aiSection = new VBox(12);
        aiSection.setPadding(new Insets(16));
        
        // AI progress and controls
        HBox aiControls = new HBox(12);
        aiControls.setAlignment(Pos.CENTER_LEFT);
        
        Button generateReviewBtn = new Button("Generate AI Review");
        generateReviewBtn.getStyleClass().addAll("button", "ai-button");
        generateReviewBtn.setOnAction(e -> requestAiReview());
        
        aiProgressIndicator = new ProgressIndicator();
        aiProgressIndicator.setMaxSize(20, 20);
        aiProgressIndicator.setVisible(false);
        
        Label aiStatus = new Label("Ready for AI review");
        aiStatus.getStyleClass().add("ai-status-label");
        
        aiControls.getChildren().addAll(generateReviewBtn, aiProgressIndicator, aiStatus);
        
        // AI suggestion area
        aiSuggestionArea = new TextArea();
        aiSuggestionArea.setPromptText("AI suggestions will appear here...");
        aiSuggestionArea.setEditable(false);
        aiSuggestionArea.setWrapText(true);
        aiSuggestionArea.getStyleClass().add("ai-suggestion-area");
        VBox.setVgrow(aiSuggestionArea, Priority.ALWAYS);
        
        aiSection.getChildren().addAll(aiControls, aiSuggestionArea);
        return aiSection;
    }
    
    private VBox createIssueDetailsPanel() {
        issueDetailsPane = new VBox(12);
        issueDetailsPane.getStyleClass().add("issue-details-panel");
        issueDetailsPane.setPadding(new Insets(16));
        issueDetailsPane.setVisible(false); // Hidden by default
        
        Label detailsTitle = new Label("� Issue Details");
        detailsTitle.getStyleClass().addAll("section-header", "details-header");
        
        // Create expandable details content
        VBox detailsContent = new VBox(8);
        detailsContent.getStyleClass().add("details-content");
        
        // Wrap in scroll pane for large content
        detailsScrollPane = new ScrollPane(detailsContent);
        detailsScrollPane.setFitToWidth(true);
        detailsScrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        detailsScrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
        detailsScrollPane.getStyleClass().add("details-scroll");
        VBox.setVgrow(detailsScrollPane, Priority.ALWAYS);
        
        // Close button
        Button closeButton = new Button("✕");
        closeButton.getStyleClass().addAll("button", "close-button");
        closeButton.setOnAction(e -> hideIssueDetails());
        
        HBox titleBar = new HBox(8);
        titleBar.setAlignment(Pos.CENTER_LEFT);
        HBox spacer = new HBox();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        titleBar.getChildren().addAll(detailsTitle, spacer, closeButton);
        
        issueDetailsPane.getChildren().addAll(titleBar, detailsScrollPane);
        return issueDetailsPane;
    }
    
    private void showIssueDetails(CodeIssue issue) {
        if (issue == null) return;
        
        // Create the details panel if it doesn't exist
        if (issueDetailsPane == null) {
            createIssueDetailsPanel();
        }
        
        // Create detailed content for the selected issue
        VBox content = new VBox(12);
        content.getStyleClass().add("issue-details-content");
        
        // Issue header
        VBox header = new VBox(4);
        Label issueTitle = new Label("📌 " + issue.getType().toString() + " Issue");
        issueTitle.getStyleClass().add("issue-detail-title");
        
        Label issueSeverity = new Label("Severity: " + (issue.getSeverity() != null ? issue.getSeverity() : "Unknown"));
        issueSeverity.getStyleClass().add("issue-severity");
        
        Label issueLine = new Label("Line: " + issue.getLine());
        issueLine.getStyleClass().add("issue-line");
        
        header.getChildren().addAll(issueTitle, issueSeverity, issueLine);
        
        // Issue description
        Label descTitle = new Label("Description:");
        descTitle.getStyleClass().add("detail-section-title");
        
        TextArea descArea = new TextArea(issue.getMessage());
        descArea.setEditable(false);
        descArea.setWrapText(true);
        descArea.setPrefRowCount(3);
        descArea.getStyleClass().add("issue-description");
        
        // Quick fixes section
        VBox fixesSection = new VBox(8);
        Label fixesTitle = new Label("Suggested Fixes:");
        fixesTitle.getStyleClass().add("detail-section-title");
        
        if (issue.hasQuickFixes()) {
            for (QuickFix fix : issue.getQuickFixes()) {
                Label fixLabel = new Label("• " + fix.getDescription());
                fixLabel.getStyleClass().add("quick-fix-item");
                fixLabel.setWrapText(true);
                fixesSection.getChildren().add(fixLabel);
            }
        } else {
            Label noFixes = new Label("No quick fixes available");
            noFixes.getStyleClass().add("no-fixes-label");
            fixesSection.getChildren().add(noFixes);
        }
        
        // Note: Code context has been moved to backend processing
        
        content.getChildren().addAll(header, new VBox(4, descTitle, descArea), fixesSection);
        
        // Update the details scroll pane content
        detailsScrollPane.setContent(content);
        
        // Show the details panel by creating/updating the outer split pane
        if (outerSplit == null) {
            outerSplit = new SplitPane();
            outerSplit.getItems().addAll(mainSplit, issueDetailsPane);
            outerSplit.setDividerPositions(0.75);
            this.content.setCenter(outerSplit);
        } else {
            // If outer split already exists, just make sure details panel is visible
            if (!outerSplit.getItems().contains(issueDetailsPane)) {
                outerSplit.getItems().add(issueDetailsPane);
                outerSplit.setDividerPositions(0.75);
            }
        }
        
        // Navigate to line in code editor
        Platform.runLater(() -> {
            codeArea.moveTo(issue.getLine() - 1, 0);
            codeArea.selectLine();
            codeArea.requestFocus();
        });
    }
    
    private void hideIssueDetails() {
        // Remove the details panel from the split pane and restore main split only
        if (outerSplit != null && outerSplit.getItems().contains(issueDetailsPane)) {
            outerSplit.getItems().remove(issueDetailsPane);
            if (outerSplit.getItems().size() == 1) {
                // If only main split left, replace outer split with main split
                content.setCenter(mainSplit);
                outerSplit = null;
            }
        }
    }
    
    /**
     * Apply syntax highlighting to code issues based on their severity
     * @param result The analysis result containing issues to highlight
     */
    private void applyIssueHighlighting(CodeAnalysisResult result) {
        Platform.runLater(() -> {
            // Clear existing highlights
            codeArea.clearStyle(0, codeArea.getLength());
            
            // Apply base syntax highlighting first
            applySyntaxHighlighting();
            
            // Apply issue-based highlighting
            for (CodeIssue issue : result.getErrors()) {
                highlightIssueLine(issue);
            }
            for (CodeIssue issue : result.getSuggestions()) {
                highlightIssueLine(issue);
            }
        });
    }
    
    /**
     * Highlight a specific line based on issue severity
     * @param issue The issue to highlight
     */
    private void highlightIssueLine(CodeIssue issue) {
        try {
            int lineNumber = issue.getLine() - 1; // Convert to 0-based index
            if (lineNumber >= 0 && lineNumber < codeArea.getParagraphs().size()) {
                int startPos = codeArea.getAbsolutePosition(lineNumber, 0);
                int endPos = codeArea.getAbsolutePosition(lineNumber, codeArea.getParagraph(lineNumber).length());
                
                String severity = issue.getSeverity();
                String styleClass = getHighlightStyleClass(severity);
                
                // Apply the highlight style to the entire line
                codeArea.setStyleClass(startPos, endPos, styleClass);
            }
        } catch (Exception e) {
            logger.warning("Failed to highlight line " + issue.getLine() + ": " + e.getMessage());
        }
    }
    
    /**
     * Get CSS style class based on issue severity
     * @param severity The severity level
     * @return CSS style class name
     */
    private String getHighlightStyleClass(String severity) {
        if (severity == null) return "issue-info";
        
        switch (severity.toLowerCase()) {
            case "critical":
                return "issue-critical";
            case "warning":
                return "issue-warning";
            case "info":
                return "issue-info";
            default:
                return "issue-info";
        }
    }
    
    /**
     * Apply basic Java syntax highlighting
     */
    private void applySyntaxHighlighting() {
        // This is a basic implementation - could be enhanced with more sophisticated parsing
        String text = codeArea.getText();
        
        // Keywords
        highlightPattern(text, "\\b(public|private|protected|static|final|class|interface|extends|implements|import|package|return|if|else|for|while|try|catch|finally|throw|throws)\\b", "keyword");
        
        // String literals
        highlightPattern(text, "\"[^\"]*\"", "string");
        
        // Comments
        highlightPattern(text, "//.*$", "comment");
        highlightPattern(text, "/\\*[\\s\\S]*?\\*/", "comment");
        
        // Numbers
        highlightPattern(text, "\\b\\d+(\\.\\d+)?\\b", "number");
    }
    
    /**
     * Highlight text matching a regex pattern
     * @param text The full text to search
     * @param pattern The regex pattern to match
     * @param styleClass The CSS style class to apply
     */
    private void highlightPattern(String text, String pattern, String styleClass) {
        try {
            java.util.regex.Pattern regex = java.util.regex.Pattern.compile(pattern, java.util.regex.Pattern.MULTILINE);
            java.util.regex.Matcher matcher = regex.matcher(text);
            
            while (matcher.find()) {
                int start = matcher.start();
                int end = matcher.end();
                codeArea.setStyleClass(start, end, styleClass);
            }
        } catch (Exception e) {
            logger.warning("Failed to apply pattern highlighting: " + e.getMessage());
        }
    }
    
    private HBox createStatusBar() {
        HBox statusBar = new HBox(16);
        statusBar.getStyleClass().add("status-bar");
        statusBar.setPadding(new Insets(8, 16, 8, 16));
        statusBar.setAlignment(Pos.CENTER_LEFT);
        
        statusLabel = new Label("Ready");
        statusLabel.getStyleClass().add("status-label");
        
        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        
        Label issueCountLabel = new Label("Issues: 0");
        issueCountLabel.getStyleClass().add("issue-count-label");
        
        statusBar.getChildren().addAll(statusLabel, spacer, issueCountLabel);
        return statusBar;
    }
    
    // Event Handlers
    private void openFile() {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Open Java File");
        fileChooser.getExtensionFilters().add(
            new FileChooser.ExtensionFilter("Java Files", "*.java")
        );
        
        File file = fileChooser.showOpenDialog(null);
        if (file != null) {
            loadFile(file);
        }
    }
    
    private void loadFile(File file) {
        try {
            this.currentFile = file;
            filePathLabel.setText(file.getName());
            statusLabel.setText("Loading file...");
            
            // Load file content in background
            CompletableFuture.supplyAsync(() -> {
                try {
                    return java.nio.file.Files.readString(file.toPath());
                } catch (IOException e) {
                    logger.log(Level.SEVERE, "Error loading file", e);
                    return null;
                }
            }).thenAcceptAsync(content -> {
                if (content != null) {
                    codeArea.replaceText(content);
                    statusLabel.setText("File loaded: " + file.getName());
                    analyzeCode(); // Auto-analyze on file load
                } else {
                    statusLabel.setText("Error loading file");
                }
            }, Platform::runLater);
            
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error loading file", e);
            statusLabel.setText("Error: " + e.getMessage());
        }
    }
    
    private void saveFile() {
        if (currentFile != null) {
            try (FileWriter writer = new FileWriter(currentFile)) {
                writer.write(codeArea.getText());
                statusLabel.setText("File saved: " + currentFile.getName());
            } catch (IOException e) {
                logger.log(Level.SEVERE, "Error saving file", e);
                statusLabel.setText("Error saving file");
            }
        }
    }
    
    private void analyzeCode() {
        if (codeArea.getText().trim().isEmpty()) {
            statusLabel.setText("No code to analyze");
            return;
        }
        
        analysisProgressBar.setVisible(true);
        statusLabel.setText("Analyzing code...");
        
        CompletableFuture.runAsync(() -> {
            controller.analyzeCode(codeArea.getText());
        }).thenRunAsync(() -> {
            // Analysis complete - controller should update the view
            analysisProgressBar.setVisible(false);
            statusLabel.setText("Analysis complete");
        }, Platform::runLater).exceptionally(throwable -> {
            analysisProgressBar.setVisible(false);
            statusLabel.setText("Analysis failed: " + throwable.getMessage());
            logger.log(Level.SEVERE, "Analysis error", throwable);
            return null;
        });
    }
    
    private void requestAiReview() {
        if (codeArea.getText().trim().isEmpty()) {
            statusLabel.setText("No code for AI review");
            return;
        }
        
        // Switch to AI tab
        analysisTabPane.getSelectionModel().select(3);
        
        aiProgressIndicator.setVisible(true);
        statusLabel.setText("Requesting AI review...");
        
        // Use the controller's method which now uses the API client
        String reviewPrompt = "Please provide a comprehensive code review";
        controller.onAskAiWithQuestion(codeArea.getText(), reviewPrompt);
        
        // Note: The response will be displayed in the main UI since the controller
        // now handles AI requests through the backend API
        aiProgressIndicator.setVisible(false);
        statusLabel.setText("AI review request sent - check main AI panel for response");
    }
    
    private void updateAnalysisResultsInternal(CodeAnalysisResult result) {
        if (result == null) {
            return;
        }
        
        // Clear previous results
        allIssues.clear();
        criticalIssues.clear();
        warnings.clear();
        suggestions.clear();
        
        // Categorize issues
        for (CodeIssue issue : result.getErrors()) {
            allIssues.add(issue);
            if ("critical".equalsIgnoreCase(issue.getSeverity())) {
                criticalIssues.add(issue);
            } else {
                warnings.add(issue);
            }
        }
        
        for (CodeIssue suggestion : result.getSuggestions()) {
            allIssues.add(suggestion);
            suggestions.add(suggestion);
        }
        
        // Update heatmap
        updateHeatmap();
        
        // Update tab titles with counts
        updateTabCounts();
    }
    
    private void updateTabCounts() {
        if (analysisTabPane != null) {
            analysisTabPane.getTabs().get(0).setText("🚨 Critical (" + criticalIssues.size() + ")");
            analysisTabPane.getTabs().get(1).setText("⚠️ Warnings (" + warnings.size() + ")");
            analysisTabPane.getTabs().get(2).setText("💡 Suggestions (" + suggestions.size() + ")");
        }
    }
    
    private void updateHeatmap() {
        heatmapPane.getChildren().clear();
        heatmapRectangles.clear();
        
        if (codeArea.getText().isEmpty()) {
            return;
        }
        
        String[] lines = codeArea.getText().split("\n");
        Map<Integer, Integer> issueCounts = new HashMap<>();
        
        // Count issues per line
        for (CodeIssue issue : allIssues) {
            issueCounts.merge(issue.getLine(), 1, Integer::sum);
        }
        
        // Create heatmap rectangles
        double rectHeight = Math.max(2, (double) heatmapPane.getHeight() / lines.length);
        
        for (int i = 1; i <= lines.length; i++) {
            Rectangle rect = new Rectangle(16, rectHeight);
            int issueCount = issueCounts.getOrDefault(i, 0);
            
            // Set color based on issue count
            if (issueCount == 0) {
                rect.setFill(Color.TRANSPARENT);
            } else if (issueCount == 1) {
                rect.setFill(Color.YELLOW);
            } else if (issueCount == 2) {
                rect.setFill(Color.ORANGE);
            } else {
                rect.setFill(Color.RED);
            }
            
            heatmapRectangles.put(i, rect);
            heatmapPane.getChildren().add(rect);
        }
    }
    
    private void onIssueClicked(MouseEvent event) {
        if (event.getClickCount() == 2) {
            @SuppressWarnings("unchecked")
            TableView<CodeIssue> table = (TableView<CodeIssue>) event.getSource();
            CodeIssue selectedIssue = table.getSelectionModel().getSelectedItem();
            
            if (selectedIssue != null) {
                // Show issue details in side panel
                showIssueDetails(selectedIssue);
            }
        }
    }
    
    private void updateIssueFilter() {
        String searchText = searchField.getText().toLowerCase();
        if (searchText.isEmpty()) {
            filteredIssues.setPredicate(null);
        } else {
            filteredIssues.setPredicate(issue -> 
                issue.getMessage().toLowerCase().contains(searchText) ||
                issue.getSeverity().toLowerCase().contains(searchText)
            );
        }
    }
    
    private void toggleHeatmap(boolean show) {
        heatmapPane.setVisible(show);
        heatmapPane.setManaged(show);
    }
    
    private void setupKeyboardShortcuts() {
        // Keyboard shortcuts will be set up when scene is created
    }
    
    // Public methods for MainController to call
    public void updateAnalysisResults(CodeAnalysisResult result) {
        Platform.runLater(() -> updateAnalysisResultsInternal(result));
    }
    
    public void displayError(String error) {
        Platform.runLater(() -> {
            statusLabel.setText("Error: " + error);
        });
    }
    
    public void displayMessage(String message) {
        Platform.runLater(() -> statusLabel.setText(message));
    }
    
    /**
     * Display analysis results in the modern UI
     * @param result The analysis result to display
     */
    public void displayAnalysisResult(CodeAnalysisResult result) {
        Platform.runLater(() -> {
            // Clear existing data
            allIssues.clear();
            criticalIssues.clear();
            warnings.clear();
            suggestions.clear();
            
            // Add all errors as issues
            allIssues.addAll(result.getErrors());
            
            // Categorize issues based on type or message content
            for (CodeIssue issue : result.getErrors()) {
                String message = issue.getMessage().toLowerCase();
                String severity = issue.getSeverity();
                
                if (message.contains("critical") || message.contains("security") || 
                    message.contains("vulnerability") || message.contains("sql injection") || 
                    message.contains("xss") || issue.getType() == CodeIssue.Type.ERROR) {
                    criticalIssues.add(issue);
                } else if (severity != null && severity.toLowerCase().contains("warning")) {
                    warnings.add(issue);
                } else {
                    suggestions.add(issue);
                }
            }
            
            // Add suggestions from result
            allIssues.addAll(result.getSuggestions());
            suggestions.addAll(result.getSuggestions());
            
            // Update status
            statusLabel.setText(String.format("Analysis complete: %d issues found", 
                result.getErrors().size() + result.getSuggestions().size()));
            
            // Update analysis summary
            updateAnalysisSummary(result);
            
            // Apply code highlighting for issues
            applyIssueHighlighting(result);
        });
    }
    
    /**
     * Display code in the editor
     * @param code The code to display
     */
    public void displayCode(String code) {
        Platform.runLater(() -> {
            codeArea.replaceText(code);
            // Clear any existing highlights when new code is loaded
            codeArea.clearStyle(0, codeArea.getLength());
            // Apply basic syntax highlighting
            applySyntaxHighlighting();
            statusLabel.setText("File loaded successfully");
        });
    }
    
    private void updateAnalysisSummary(CodeAnalysisResult result) {
        // Update status with summary information
        String summaryText = String.format(
            "Analysis complete: %d total issues (%d critical, %d warnings, %d suggestions)",
            result.getErrors().size() + result.getSuggestions().size(),
            criticalIssues.size(),
            warnings.size(),
            suggestions.size()
        );
        statusLabel.setText(summaryText);
    }
}
</file>

<file path="src/main/java/com/reviewer/codereviewer/MainApp.java">
package com.reviewer.codereviewer;

import com.reviewer.codereviewer.controller.MainController;
import com.reviewer.codereviewer.ui.ModernMainView;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.util.logging.Logger;

public class MainApp extends Application {
    private static final Logger logger = Logger.getLogger(MainApp.class.getName());
    
    @Override
    public void start(Stage primaryStage) {
        try {
            logger.info("Starting CodeReviewer Frontend Application");
            
            // Create main controller
            MainController controller = new MainController();
            
            // Create and configure the modern view
            ModernMainView modernView = new ModernMainView(controller);
            controller.setModernView(modernView);
            
            // Create and show the scene
            Scene scene = modernView.createScene();
            primaryStage.setTitle("CodeReviewer - Frontend Client");
            primaryStage.setScene(scene);
            primaryStage.setResizable(true);
            primaryStage.setMaximized(true);
            primaryStage.show();
            
            logger.info("Application started successfully");
            
            // Show a status message about backend connection
            modernView.displayError("Frontend application started. Connecting to backend server...");
            
        } catch (Exception e) {
            logger.severe("Application startup failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        try {
            logger.info("Launching CodeReviewer Frontend Client");
            launch(args);
        } catch (Exception e) {
            logger.severe("Application startup failed: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
}
</file>

<file path="src/main/resources/ai-style.css">
/* AI Suggestion Area Styling */
.ai-suggestion-area {
    -fx-font-size: 14px;
    -fx-background-color: linear-gradient(to bottom, #f8fafc 0%, #f1f5f9 100%);
    -fx-border-color: #6366f1;
    -fx-border-width: 2px;
    -fx-padding: 20px;
    -fx-background-radius: 12px;
    -fx-border-radius: 12px;
    -fx-text-fill: #1e293b;
    -fx-effect: dropshadow(three-pass-box, rgba(99,102,241,0.2), 16, 0.3, 0, 4);
    -fx-font-family: 'Inter', 'Segoe UI', sans-serif;
}

.ai-suggestion-area:focused {
    -fx-border-color: #4f46e5;
    -fx-effect: dropshadow(three-pass-box, rgba(79,70,229,0.3), 20, 0.4, 0, 6);
}

/* AI Button Styling */
.ai-button {
    -fx-font-size: 14px;
    -fx-background-color: linear-gradient(to right, #6366f1 0%, #4f46e5 100%);
    -fx-text-fill: white;
    -fx-padding: 10px 16px;
    -fx-background-radius: 10px;
    -fx-border-radius: 10px;
    -fx-font-weight: 600;
    -fx-cursor: hand;
    -fx-effect: dropshadow(gaussian, rgba(99,102,241,0.4), 8, 0.3, 0, 3);
    -fx-border-color: transparent;
}

.ai-button:hover {
    -fx-background-color: linear-gradient(to right, #4f46e5 0%, #4338ca 100%);
    -fx-effect: dropshadow(gaussian, rgba(79,70,229,0.5), 12, 0.4, 0, 4);
    -fx-scale-y: 1.02;
    -fx-scale-x: 1.02;
}

.ai-button:disabled {
    -fx-opacity: 0.7;
    -fx-background-color: #9ca3af;
    -fx-text-fill: #f3f4f6;
    -fx-effect: none;
}
</file>

<file path="src/main/resources/app-theme.css">
/* Modern Enhanced Theme for Code Reviewer */
.root {
    -fx-background-color: linear-gradient(to bottom, #f8fafc 0%, #e2e8f0 100%);
    -fx-font-family: 'Segoe UI', 'Roboto', 'Inter', sans-serif;
    -fx-text-fill: #1e293b;
    -fx-focus-color: transparent;
    -fx-faint-focus-color: transparent;
}

/* Enhanced Menu System */
.menu-bar {
    -fx-background-color: linear-gradient(to bottom, #ffffff 0%, #f1f5f9 100%);
    -fx-border-color: #cbd5e1;
    -fx-border-width: 0 0 1px 0;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.08), 8, 0.2, 0, 2);
    -fx-padding: 4 0;
}

.menu {
    -fx-background-color: transparent;
    -fx-text-fill: #334155;
    -fx-padding: 10 18;
    -fx-font-size: 14px;
    -fx-font-weight: 500;
}

.menu:hover, .menu:showing {
    -fx-background-color: #e0e7ff;
    -fx-text-fill: #4338ca;
    -fx-background-radius: 6px;
}

.context-menu {
    -fx-background-color: #ffffff;
    -fx-border-color: #e2e8f0;
    -fx-border-radius: 8px;
    -fx-background-radius: 8px;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.15), 12, 0.3, 0, 4);
    -fx-padding: 6px 0;
}

.menu-item {
    -fx-background-color: transparent;
    -fx-text-fill: #374151;
    -fx-padding: 10 20;
    -fx-font-size: 14px;
    -fx-background-radius: 6px;
}

.menu-item:focused, .menu-item:hover {
    -fx-background-color: #f0f9ff;
    -fx-text-fill: #0ea5e9;
    -fx-font-weight: 500;
}

/* Enhanced Code Area - Better Expansion */
.code-area {
    -fx-background-color: #ffffff;
    -fx-text-fill: #374151;
    -fx-highlight-fill: #dbeafe;
    -fx-highlight-text-fill: #1e40af;
    -fx-font-size: 14px;
    -fx-font-family: 'JetBrains Mono', 'Consolas', 'Monaco', monospace;
    -fx-border-radius: 12px;
    -fx-background-radius: 12px;
    -fx-padding: 10px;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.1), 16, 0.2, 0, 4);
    -fx-border-color: #e2e8f0;
    -fx-border-width: 1px;
    -fx-pref-width: 1000px;  /* Ensure code area expands properly */
    -fx-max-width: 5000px;   /* Allow extensive horizontal expansion */
}

.code-area:focused {
    -fx-border-color: #3b82f6;
    -fx-effect: dropshadow(three-pass-box, rgba(59,130,246,0.3), 20, 0.3, 0, 6);
}

/* Enhanced Code and Heatmap Container - Fix Expansion Issues */
.code-heatmap-container {
    -fx-background-color: transparent;
    -fx-padding: 10;
    -fx-background-radius: 12px;
    -fx-pref-width: 5000px; /* Allow the container to expand fully */
    -fx-min-width: 800px;   /* Ensure minimum reasonable width */
    -fx-hgrow: ALWAYS;      /* Horizontal growth priority */
}

/* Improved Split Panes */
.code-split-pane {
    -fx-background-color: transparent;
    -fx-padding: 0;
}

.code-split-pane .split-pane-divider {
    -fx-background-color: #cbd5e1;
    -fx-padding: 0 0 2 0;
}

.main-split-pane {
    -fx-background-color: transparent;
    -fx-padding: 0;
}

.main-split-pane .split-pane-divider {
    -fx-background-color: #e2e8f0;
    -fx-padding: 0 2 0 0;
}

/* Enhanced List Views */
.list-view {
    -fx-background-color: #ffffff;
    -fx-control-inner-background: #ffffff;
    -fx-border-radius: 10px;
    -fx-background-radius: 10px;
    -fx-padding: 8px 0;
    -fx-border-color: #e2e8f0;
    -fx-border-width: 1px;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.08), 12, 0.2, 0, 3);
}

.list-cell {
    -fx-background-color: transparent;
    -fx-text-fill: #374151;
    -fx-padding: 12px 16px;
    -fx-border-radius: 6px;
    -fx-font-size: 13px;
    -fx-background-radius: 6px;
}

.list-cell:hover {
    -fx-background-color: #f8fafc;
    -fx-text-fill: #1e40af;
}

.list-cell:selected, .list-cell:focused {
    -fx-background-color: linear-gradient(to right, #dbeafe 0%, #f0f9ff 100%);
    -fx-text-fill: #1e40af;
    -fx-font-weight: 600;
    -fx-border-color: #3b82f6;
    -fx-border-width: 0 0 0 3px;
}

/* Enhanced Section Headers */
.section-header {
    -fx-font-size: 16px;
    -fx-font-weight: 700;
    -fx-text-fill: #1e293b;
    -fx-padding: 12px 0 8px 0;
    -fx-background-color: transparent;
    -fx-border-color: #e2e8f0;
    -fx-border-width: 0 0 1px 0;
}

.error-header {
    -fx-text-fill: #dc2626;
}

.suggestion-header {
    -fx-text-fill: #059669;
}

.details-header {
    -fx-text-fill: #7c3aed;
}

/* Issue Highlighting */
.critical-error-highlight {
    -fx-background-color: #fef2f2;
    -fx-text-fill: #dc2626;
    -fx-font-weight: 600;
    -fx-border-color: #fca5a5;
    -fx-border-width: 0 0 0 3px;
}

.warning-highlight {
    -fx-background-color: #fffbeb;
    -fx-text-fill: #d97706;
    -fx-border-color: #fbbf24;
    -fx-border-width: 0 0 0 3px;
}

.info-highlight {
    -fx-background-color: #eff6ff;
    -fx-text-fill: #2563eb;
    -fx-border-color: #60a5fa;
    -fx-border-width: 0 0 0 3px;
}

.suggestion-highlight {
    -fx-background-color: #f0fdf4;
    -fx-text-fill: #059669;
    -fx-border-color: #34d399;
    -fx-border-width: 0 0 0 3px;
}

.selected-issue-highlight {
    -fx-background-color: #e0e7ff;
    -fx-text-fill: #4338ca;
    -fx-font-weight: 700;
    -fx-effect: dropshadow(gaussian, rgba(67,56,202,0.4), 8, 0.5, 0, 0);
}

/* Long method and other specific highlights */
.long-method-highlight {
    -fx-background-color: #fef3c7;
    -fx-text-fill: #d97706;
    -fx-border-color: #fbbf24;
    -fx-border-width: 0 0 0 3px;
}

.deep-nesting-highlight {
    -fx-background-color: #fee2e2;
    -fx-text-fill: #dc2626;
    -fx-border-color: #fca5a5;
    -fx-border-width: 0 0 0 3px;
}

.empty-block-highlight {
    -fx-background-color: #f3f4f6;
    -fx-text-fill: #6b7280;
    -fx-border-color: #d1d5db;
    -fx-border-width: 0 0 0 3px;
}

.unused-import-highlight {
    -fx-background-color: #f0fdf4;
    -fx-text-fill: #059669;
    -fx-border-color: #34d399;
    -fx-border-width: 0 0 0 3px;
}

/* Enhanced Details Area */
.details-area {
    -fx-background-color: #ffffff;
    -fx-text-fill: #374151;
    -fx-font-size: 13px;
    -fx-border-radius: 10px;
    -fx-background-radius: 10px;
    -fx-border-color: #e2e8f0;
    -fx-border-width: 1px;
    -fx-padding: 16px;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.08), 12, 0.2, 0, 3);
    -fx-control-inner-background: #ffffff;
}

/* AI Suggestion Area has been removed */

/* Enhanced Buttons */
.button {
    -fx-background-color: linear-gradient(to bottom, #ffffff 0%, #f8fafc 100%);
    -fx-text-fill: #374151;
    -fx-border-color: #d1d5db;
    -fx-border-width: 1px;
    -fx-border-radius: 8px;
    -fx-background-radius: 8px;
    -fx-padding: 10px 16px;
    -fx-font-size: 13px;
    -fx-font-weight: 500;
    -fx-cursor: hand;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.05), 4, 0.2, 0, 1);
}

.button:hover {
    -fx-background-color: linear-gradient(to bottom, #f9fafb 0%, #f3f4f6 100%);
    -fx-text-fill: #1f2937;
    -fx-border-color: #9ca3af;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.1), 6, 0.3, 0, 2);
}

/* AI buttons have been removed */

/* Enhanced Containers */
.right-pane {
    -fx-background-color: linear-gradient(to bottom, #fefefe 0%, #f8fafc 100%);
    -fx-border-radius: 12px;
    -fx-background-radius: 12px;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.08), 16, 0.2, 0, 4);
}

/* Bottom bar has been removed */

/* Heatmap Styling */
.heatmap-pane {
    -fx-background-color: transparent;
    -fx-padding: 5px 0;
    -fx-spacing: 1;
}

/* Scrollbar Styling */
.scroll-bar:horizontal, .scroll-bar:vertical {
    -fx-background-color: transparent;
}

.scroll-bar .thumb {
    -fx-background-color: #cbd5e1;
    -fx-background-radius: 6px;
}

.scroll-bar .thumb:hover {
    -fx-background-color: #94a3b8;
}

.scroll-bar .thumb:pressed {
    -fx-background-color: #64748b;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-background-color: transparent;
}

/* Line Number Graphics */
.lineno-graphic {
    -fx-background-color: transparent;
    -fx-text-fill: #6b7280;
    -fx-font-size: 12px;
    -fx-padding: 2px 8px;
}
</file>

<file path="src/main/resources/application.properties">
# Application Configuration
spring.application.name=CodeReviewer
app.name=Code Reviewer
app.version=1.0.0
app.author=Himesh Raj

# Analysis Configuration
app.analysis.max-method-length=50
app.analysis.max-cyclomatic-complexity=10
app.analysis.enable-extended-review=true
analysis.max.file.size.mb=10
analysis.timeout.seconds=60
analysis.concurrent.files=4

# OpenRouter API Configuration
openrouter.api.key=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
openrouter.model.name=deepseek/deepseek-r1:free
openrouter.endpoint.url=https://openrouter.ai/api/v1/chat/completions
openrouter.timeout.seconds=30
openrouter.max.retries=3
openrouter.retry.delay.ms=1000

# Performance Settings
cache.enabled=true
cache.size=100
cache.ttl.minutes=30
thread.pool.core.size=4
thread.pool.max.size=8
thread.pool.keep.alive.seconds=60

# UI Settings
ui.theme=dark
ui.font.size=12
ui.auto.save=true
ui.syntax.highlighting=true

# Logging Configuration
logging.level.root=INFO
logging.level.com.reviewer.codereviewer=INFO
logging.file.enabled=true
logging.file.path=logs/application.log
logging.max.file.size=10MB
logging.max.files=5

# Metrics and Monitoring
metrics.enabled=true
metrics.collection.interval.seconds=60
metrics.retention.days=7

# Security Settings
security.api.key.validation=true
security.input.sanitization=true
security.max.request.size.mb=5

# Development Settings
dev.mode=false
dev.debug.enabled=false
dev.mock.ai.responses=false
</file>

<file path="src/main/resources/logging.properties">
# Logging configuration for CodeReviewer application

# Root logger level
.level = INFO

# Console handler
handlers = java.util.logging.ConsoleHandler, java.util.logging.FileHandler

# Console handler configuration
java.util.logging.ConsoleHandler.level = INFO
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter

# File handler configuration
java.util.logging.FileHandler.level = ALL
java.util.logging.FileHandler.pattern = logs/codereview-%g.log
java.util.logging.FileHandler.limit = 10485760
java.util.logging.FileHandler.count = 5
java.util.logging.FileHandler.formatter = java.util.logging.SimpleFormatter

# Application-specific loggers
com.reviewer.codereviewer.level = FINE
com.reviewer.codereviewer.service.AISuggestionService.level = INFO
com.reviewer.codereviewer.service.CodeAnalysisService.level = FINE

# Third-party library levels
org.apache.http.level = WARNING
okhttp3.level = WARNING

# Custom formatter for better readability
java.util.logging.SimpleFormatter.format = %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS [%4$s] %2$s: %5$s%6$s%n
</file>

<file path="src/main/resources/modern-theme.css">
/* Professional Modern UI Theme for Code Reviewer */

.root {
    -fx-background-color: #fafbfc;
    -fx-font-family: "SF Pro Display", "Inter", "Segoe UI", "Roboto", sans-serif;
    -fx-text-fill: #1c2532;
    -fx-focus-color: transparent;
    -fx-faint-focus-color: transparent;
    -fx-accent: #0066cc;
}

/* Main Layout Containers */
.main-container {
    -fx-background-color: #fafbfc;
    -fx-padding/* Status Bar */
.status-bar {
    -fx-background-color: #f8fafc;
    -fx-border-color: #e1e8ed;
    -fx-border-width: 1 0 0 0;
    -fx-padding: 8 16;
}

/* Issue Details Panel */
.issue-details-panel {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-width: 0 0 0 1;
    -fx-min-width: 300;
    -fx-pref-width: 350;
}

.issue-detail-title {
    -fx-font-size: 16px;
    -fx-font-weight: bold;
    -fx-text-fill: #1f2937;
}

.issue-severity {
    -fx-font-size: 12px;
    -fx-text-fill: #6b7280;
    -fx-font-weight: bold;
}

.issue-line {
    -fx-font-size: 12px;
    -fx-text-fill: #6b7280;
}

.detail-section-title {
    -fx-font-size: 13px;
    -fx-font-weight: bold;
    -fx-text-fill: #374151;
    -fx-padding: 8 0 4 0;
}

.issue-description {
    -fx-background-color: #f9fafb;
    -fx-border-color: #e5e7eb;
    -fx-border-radius: 4px;
    -fx-background-radius: 4px;
    -fx-font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
    -fx-font-size: 11px;
}

.quick-fix-item {
    -fx-text-fill: #059669;
    -fx-font-size: 12px;
    -fx-padding: 2 0;
}

.no-fixes-label {
    -fx-text-fill: #9ca3af;
    -fx-font-style: italic;
    -fx-font-size: 12px;
}

.code-context {
    -fx-background-color: #1f2937;
    -fx-text-fill: #f9fafb;
    -fx-border-color: #374151;
    -fx-border-radius: 4px;
    -fx-background-radius: 4px;
    -fx-font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
    -fx-font-size: 11px;
}

.close-button {
    -fx-background-color: transparent;
    -fx-border-color: transparent;
    -fx-text-fill: #6b7280;
    -fx-font-size: 14px;
    -fx-padding: 4;
    -fx-min-width: 24;
    -fx-min-height: 24;
}

.close-button:hover {
    -fx-background-color: #f3f4f6;
    -fx-text-fill: #374151;
}

.details-scroll {
    -fx-background-color: transparent;
    -fx-border-color: transparent;
}

.details-scroll .viewport {
    -fx-background-color: transparent;
}

/* Code Syntax Highlighting */
.keyword {
    -fx-fill: #0066cc;
    -fx-font-weight: bold;
}

.string {
    -fx-fill: #22863a;
}

.comment {
    -fx-fill: #6a737d;
    -fx-font-style: italic;
}

.number {
    -fx-fill: #005cc5;
}

/* Code Issue Highlighting */
.issue-critical {
    -fx-underline: true;
    -fx-background-color: rgba(220, 38, 38, 0.2);
    -fx-border-color: #dc2626;
    -fx-border-width: 0 0 2 0;
}

.issue-warning {
    -fx-underline: true;
    -fx-background-color: rgba(245, 158, 11, 0.2);
    -fx-border-color: #f59e0b;
    -fx-border-width: 0 0 2 0;
}

.issue-info {
    -fx-underline: true;
    -fx-background-color: rgba(59, 130, 246, 0.1);
    -fx-border-color: #3b82f6;
    -fx-border-width: 0 0 1 0;
}

/* Code Issue Highlighting */
.issue-critical {
    -fx-background-color: rgba(239, 68, 68, 0.15);
    -fx-border-color: #ef4444;
    -fx-border-width: 0 0 0 3;
}

.issue-warning {
    -fx-background-color: rgba(245, 158, 11, 0.15);
    -fx-border-color: #f59e0b;
    -fx-border-width: 0 0 0 3;
}

.issue-info {
    -fx-background-color: rgba(59, 130, 246, 0.15);
    -fx-border-color: #3b82f6;
    -fx-border-width: 0 0 0 3;
}

/* Syntax Highlighting */
.keyword {
    -fx-fill: #7c3aed;
    -fx-font-weight: bold;
}

.string {
    -fx-fill: #059669;
}

.comment {
    -fx-fill: #6b7280;
    -fx-font-style: italic;
}

.number {
    -fx-fill: #dc2626;
}
.header-bar {
    -fx-background-color: linear-gradient(to bottom, #ffffff 0%, #f8fafc 100%);
    -fx-border-color: #e1e8ed;
    -fx-border-width: 0 0 1px 0;
    -fx-padding: 12 24;
    -fx-spacing: 16;
    -fx-alignment: center-left;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.04), 4, 0.2, 0, 1);
}

.content-area {
    -fx-background-color: #fafbfc;
    -fx-padding: 16;
    -fx-spacing: 16;
}

/* Enhanced Menu System */
.menu-bar {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-width: 0 0 1px 0;
    -fx-padding: 0;
}

.menu {
    -fx-background-color: transparent;
    -fx-text-fill: #5a6c7d;
    -fx-padding: 12 20;
    -fx-font-size: 14px;
    -fx-font-weight: 500;
}

.menu:hover, .menu:showing {
    -fx-background-color: #f0f4f8;
    -fx-text-fill: #0066cc;
}

/* Professional Buttons */
.button {
    -fx-background-color: linear-gradient(to bottom, #ffffff 0%, #f8fafc 100%);
    -fx-border-color: #d1dce5;
    -fx-border-radius: 8px;
    -fx-background-radius: 8px;
    -fx-text-fill: #5a6c7d;
    -fx-font-size: 14px;
    -fx-font-weight: 500;
    -fx-padding: 12 20;
    -fx-cursor: hand;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.06), 2, 0.3, 0, 1);
}

.button:hover {
    -fx-background-color: linear-gradient(to bottom, #f8fafc 0%, #f1f5f9 100%);
    -fx-border-color: #0066cc;
    -fx-text-fill: #0066cc;
    -fx-effect: dropshadow(three-pass-box, rgba(0,102,204,0.15), 4, 0.4, 0, 2);
}

.button:pressed {
    -fx-background-color: #f1f5f9;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.1), 2, 0.3, 0, 1);
}

/* Primary Action Button */
.primary-button {
    -fx-background-color: linear-gradient(to bottom, #0066cc 0%, #0052a3 100%);
    -fx-border-color: #0052a3;
    -fx-text-fill: #ffffff;
    -fx-font-weight: 600;
}

.primary-button:hover {
    -fx-background-color: linear-gradient(to bottom, #0052a3 0%, #004080 100%);
    -fx-effect: dropshadow(three-pass-box, rgba(0,102,204,0.25), 6, 0.5, 0, 3);
}

/* AI Button Specific */
.ai-button {
    -fx-background-color: linear-gradient(to bottom, #667eea 0%, #764ba2 100%);
    -fx-border-color: #5a67d8;
    -fx-text-fill: #ffffff;
    -fx-font-weight: 600;
    -fx-padding: 14 24;
    -fx-font-size: 15px;
}

.ai-button:hover {
    -fx-background-color: linear-gradient(to bottom, #5a67d8 0%, #667eea 100%);
    -fx-effect: dropshadow(three-pass-box, rgba(102,126,234,0.3), 8, 0.6, 0, 4);
}

/* Code Area Styling */
.code-area {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-radius: 12px;
    -fx-background-radius: 12px;
    -fx-font-family: "JetBrains Mono", "SF Mono", "Consolas", "Monaco", monospace;
    -fx-font-size: 13px;
    -fx-line-spacing: 1.4;
    -fx-padding: 20;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.04), 8, 0.3, 0, 2);
}

.code-area .text {
    -fx-fill: #2d3748;
}

.code-area .line-number {
    -fx-background-color: #f7fafc;
    -fx-text-fill: #a0aec0;
    -fx-font-size: 12px;
    -fx-padding: 0 12 0 8;
    -fx-border-color: #e2e8f0;
    -fx-border-width: 0 1px 0 0;
}

/* Professional Cards */
.card {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-radius: 12px;
    -fx-background-radius: 12px;
    -fx-padding: 20;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.04), 8, 0.3, 0, 2);
}

.card-header {
    -fx-font-size: 18px;
    -fx-font-weight: 600;
    -fx-text-fill: #2d3748;
    -fx-padding: 0 0 16 0;
}

/* Issue Tables */
.table-view {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-radius: 8px;
    -fx-background-radius: 8px;
    -fx-table-cell-border-color: #f7fafc;
    -fx-selection-bar: #e6f3ff;
    -fx-selection-bar-non-focused: #f0f4f8;
}

.table-view .column-header-background {
    -fx-background-color: #f8fafc;
    -fx-border-color: #e2e8f0;
    -fx-border-width: 0 0 1px 0;
}

.table-view .column-header {
    -fx-text-fill: #4a5568;
    -fx-font-weight: 600;
    -fx-font-size: 13px;
    -fx-padding: 12 16;
}

.table-row-cell {
    -fx-background-color: #ffffff;
    -fx-border-color: #f7fafc;
    -fx-border-width: 0 0 1px 0;
    -fx-padding: 8 0;
}

.table-row-cell:selected {
    -fx-background-color: #e6f3ff;
    -fx-border-color: #b3d9ff;
}

.table-cell {
    -fx-text-fill: #4a5568;
    -fx-font-size: 13px;
    -fx-padding: 12 16;
    -fx-alignment: center-left;
}

/* Issue Type Indicators */
.severity-critical {
    -fx-background-color: #fed7d7;
    -fx-text-fill: #c53030;
    -fx-border-color: #feb2b2;
    -fx-border-radius: 20px;
    -fx-background-radius: 20px;
    -fx-padding: 4 12;
    -fx-font-size: 11px;
    -fx-font-weight: 600;
}

.severity-warning {
    -fx-background-color: #fefcbf;
    -fx-text-fill: #d69e2e;
    -fx-border-color: #faf089;
    -fx-border-radius: 20px;
    -fx-background-radius: 20px;
    -fx-padding: 4 12;
    -fx-font-size: 11px;
    -fx-font-weight: 600;
}

.severity-info {
    -fx-background-color: #bee3f8;
    -fx-text-fill: #2b6cb0;
    -fx-border-color: #90cdf4;
    -fx-border-radius: 20px;
    -fx-background-radius: 20px;
    -fx-padding: 4 12;
    -fx-font-size: 11px;
    -fx-font-weight: 600;
}

/* Section Headers */
.section-header {
    -fx-font-size: 16px;
    -fx-font-weight: 700;
    -fx-padding: 0 0 12 0;
}

.error-header {
    -fx-text-fill: #e53e3e;
}

.warning-header {
    -fx-text-fill: #d69e2e;
}

.suggestion-header {
    -fx-text-fill: #0066cc;
}

.details-header {
    -fx-text-fill: #4a5568;
}

/* Search and Filter Controls */
.search-field {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-radius: 8px;
    -fx-background-radius: 8px;
    -fx-padding: 10 16;
    -fx-font-size: 14px;
    -fx-prompt-text-fill: #a0aec0;
    -fx-min-width: 200px;
}

.search-field:focused {
    -fx-border-color: #0066cc;
    -fx-effect: dropshadow(three-pass-box, rgba(0,102,204,0.15), 4, 0.5, 0, 2);
}

.toggle-button {
    -fx-background-color: #f7fafc;
    -fx-border-color: #e2e8f0;
    -fx-border-radius: 6px;
    -fx-background-radius: 6px;
    -fx-text-fill: #4a5568;
    -fx-font-size: 12px;
    -fx-font-weight: 500;
    -fx-padding: 8 16;
}

.toggle-button:selected {
    -fx-background-color: #0066cc;
    -fx-border-color: #0052a3;
    -fx-text-fill: #ffffff;
}

/* Text Areas */
.text-area {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-radius: 8px;
    -fx-background-radius: 8px;
    -fx-padding: 16;
    -fx-font-family: "SF Pro Text", "Inter", "Segoe UI", sans-serif;
    -fx-font-size: 14px;
    -fx-line-spacing: 1.5;
}

.text-area .content {
    -fx-background-color: #ffffff;
    -fx-background-radius: 8px;
}

.details-area {
    -fx-background-color: #f8fafc;
    -fx-border-color: #e2e8f0;
    -fx-text-fill: #4a5568;
}

.ai-suggestion-area {
    -fx-background-color: #f0f4f8;
    -fx-border-color: #cbd5e1;
    -fx-text-fill: #2d3748;
    -fx-font-family: "SF Pro Text", "Inter", "Segoe UI", sans-serif;
}

/* Progress Indicators */
.progress-indicator {
    -fx-progress-color: #0066cc;
}

.progress-indicator .percentage {
    -fx-fill: #0066cc;
}

/* Heatmap */
.heatmap-pane {
    -fx-background-color: #f8fafc;
    -fx-border-color: #e2e8f0;
    -fx-border-radius: 0 8px 8px 0;
    -fx-background-radius: 0 8px 8px 0;
    -fx-padding: 8 4;
}

.heat-level-0 { -fx-background-color: #f7fafc; }
.heat-level-1 { -fx-background-color: #fed7d7; }
.heat-level-2 { -fx-background-color: #feb2b2; }
.heat-level-3 { -fx-background-color: #fc8181; }
.heat-level-4 { -fx-background-color: #f56565; }
.heat-level-5 { -fx-background-color: #e53e3e; }

/* Toolbar */
.toolbar {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-width: 0 0 1px 0;
    -fx-padding: 12 20;
    -fx-spacing: 12;
}

/* Split Panes */
.split-pane {
    -fx-background-color: transparent;
}

.split-pane .split-pane-divider {
    -fx-background-color: #e1e8ed;
    -fx-padding: 0 1 0 1;
}

/* Responsive breakpoints */
.compact-view .card {
    -fx-padding: 12;
}

.compact-view .section-header {
    -fx-font-size: 14px;
}

/* Status indicators */
.status-indicator {
    -fx-background-radius: 50px;
    -fx-min-width: 8px;
    -fx-min-height: 8px;
    -fx-max-width: 8px;
    -fx-max-height: 8px;
}

.status-success {
    -fx-background-color: #48bb78;
}

.status-warning {
    -fx-background-color: #ed8936;
}

.status-error {
    -fx-background-color: #f56565;
}

/* Animations and Transitions */
.fade-in {
    -fx-opacity: 0.0;
}

.fade-in:hover {
    -fx-opacity: 1.0;
}

/* Accessibility */
.button:focused,
.text-field:focused,
.text-area:focused {
    -fx-effect: dropshadow(three-pass-box, rgba(0,102,204,0.3), 6, 0.5, 0, 2);
    -fx-border-color: #0066cc;
}

/* Status Bar */
.status-bar {
    -fx-background-color: #f8fafc;
    -fx-border-color: #e1e8ed;
    -fx-border-width: 1px 0 0 0;
    -fx-padding: 8 16;
}

.status-label {
    -fx-text-fill: #4a5568;
    -fx-font-size: 13px;
}

.file-path-label {
    -fx-text-fill: #2d3748;
    -fx-font-weight: 500;
    -fx-font-size: 14px;
}

.issue-count-label {
    -fx-text-fill: #4a5568;
    -fx-font-size: 12px;
}

.ai-status-label {
    -fx-text-fill: #667eea;
    -fx-font-size: 13px;
}
}
</file>

<file path="src/test/java/com/reviewer/codereviewer/client/dto/CodeAnalysisResultTest.java">
package com.reviewer.codereviewer.client.dto;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.BeforeEach;

import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Code Analysis Result DTO Tests")
class CodeAnalysisResultTest {
    
    private CodeAnalysisResult result;
    
    @BeforeEach
    void setUp() {
        result = new CodeAnalysisResult();
    }
    
    @Test
    @DisplayName("Should initialize with empty lists")
    void shouldInitializeWithEmptyLists() {
        assertNotNull(result.getErrors());
        assertNotNull(result.getSuggestions());
        assertTrue(result.getErrors().isEmpty());
        assertTrue(result.getSuggestions().isEmpty());
        assertEquals(0.0, result.getScore());
    }
    
    @Test
    @DisplayName("Should initialize with provided lists")
    void shouldInitializeWithProvidedLists() {
        CodeIssue error = new CodeIssue("Error message", 1, CodeIssue.Type.ERROR);
        CodeIssue suggestion = new CodeIssue("Suggestion message", 2, CodeIssue.Type.SUGGESTION);
        
        List<CodeIssue> errors = Arrays.asList(error);
        List<CodeIssue> suggestions = Arrays.asList(suggestion);
        
        CodeAnalysisResult result = new CodeAnalysisResult(errors, suggestions, 85.5);
        
        assertEquals(1, result.getErrors().size());
        assertEquals(1, result.getSuggestions().size());
        assertEquals(85.5, result.getScore());
        assertEquals(error, result.getErrors().get(0));
        assertEquals(suggestion, result.getSuggestions().get(0));
    }
    
    @Test
    @DisplayName("Should handle null lists gracefully")
    void shouldHandleNullListsGracefully() {
        CodeAnalysisResult result = new CodeAnalysisResult(null, null, 90.0);
        
        assertNotNull(result.getErrors());
        assertNotNull(result.getSuggestions());
        assertTrue(result.getErrors().isEmpty());
        assertTrue(result.getSuggestions().isEmpty());
        assertEquals(90.0, result.getScore());
    }
    
    @Test
    @DisplayName("Should correctly report if has issues")
    void shouldCorrectlyReportIfHasIssues() {
        // Initially no issues
        assertFalse(result.hasIssues());
        
        // Add an error
        CodeIssue error = new CodeIssue("Error", 1, CodeIssue.Type.ERROR);
        result.getErrors().add(error);
        assertTrue(result.hasIssues());
        
        // Clear and add a suggestion
        result.getErrors().clear();
        CodeIssue suggestion = new CodeIssue("Suggestion", 2, CodeIssue.Type.SUGGESTION);
        result.getSuggestions().add(suggestion);
        assertTrue(result.hasIssues());
    }
    
    @Test
    @DisplayName("Should correctly count total issues")
    void shouldCorrectlyCountTotalIssues() {
        assertEquals(0, result.getTotalIssueCount());
        
        // Add errors and suggestions
        result.getErrors().add(new CodeIssue("Error 1", 1, CodeIssue.Type.ERROR));
        result.getErrors().add(new CodeIssue("Error 2", 2, CodeIssue.Type.ERROR));
        result.getSuggestions().add(new CodeIssue("Suggestion 1", 3, CodeIssue.Type.SUGGESTION));
        
        assertEquals(3, result.getTotalIssueCount());
    }
    
    @Test
    @DisplayName("Should set and get analysis time")
    void shouldSetAndGetAnalysisTime() {
        String analysisTime = "2024-08-15T10:30:00Z";
        result.setAnalysisTime(analysisTime);
        assertEquals(analysisTime, result.getAnalysisTime());
    }
    
    @Test
    @DisplayName("Should set and get score")
    void shouldSetAndGetScore() {
        result.setScore(75.5);
        assertEquals(75.5, result.getScore());
    }
    
    @Test
    @DisplayName("Should set errors list")
    void shouldSetErrorsList() {
        CodeIssue error1 = new CodeIssue("Error 1", 1, CodeIssue.Type.ERROR);
        CodeIssue error2 = new CodeIssue("Error 2", 2, CodeIssue.Type.ERROR);
        List<CodeIssue> errors = Arrays.asList(error1, error2);
        
        result.setErrors(errors);
        
        assertEquals(2, result.getErrors().size());
        assertEquals(error1, result.getErrors().get(0));
        assertEquals(error2, result.getErrors().get(1));
    }
    
    @Test
    @DisplayName("Should set suggestions list")
    void shouldSetSuggestionsList() {
        CodeIssue suggestion1 = new CodeIssue("Suggestion 1", 1, CodeIssue.Type.SUGGESTION);
        CodeIssue suggestion2 = new CodeIssue("Suggestion 2", 2, CodeIssue.Type.SUGGESTION);
        List<CodeIssue> suggestions = Arrays.asList(suggestion1, suggestion2);
        
        result.setSuggestions(suggestions);
        
        assertEquals(2, result.getSuggestions().size());
        assertEquals(suggestion1, result.getSuggestions().get(0));
        assertEquals(suggestion2, result.getSuggestions().get(1));
    }
}
</file>

<file path="src/test/java/com/reviewer/codereviewer/client/dto/CodeIssueTest.java">
package com.reviewer.codereviewer.client.dto;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.BeforeEach;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Code Issue DTO Tests")
class CodeIssueTest {
    
    private CodeIssue issue;
    
    @BeforeEach
    void setUp() {
        issue = new CodeIssue();
    }
    
    @Test
    @DisplayName("Should initialize with empty quick fixes list")
    void shouldInitializeWithEmptyQuickFixesList() {
        assertNotNull(issue.getQuickFixes());
        assertTrue(issue.getQuickFixes().isEmpty());
        assertFalse(issue.hasQuickFixes());
    }
    
    @Test
    @DisplayName("Should initialize with provided parameters")
    void shouldInitializeWithProvidedParameters() {
        String message = "Test error message";
        int line = 42;
        int column = 10;
        CodeIssue.Type type = CodeIssue.Type.ERROR;
        
        CodeIssue issue = new CodeIssue(message, line, column, type);
        
        assertEquals(message, issue.getMessage());
        assertEquals(line, issue.getLine());
        assertEquals(column, issue.getColumn());
        assertEquals(type, issue.getType());
        assertNotNull(issue.getQuickFixes());
        assertTrue(issue.getQuickFixes().isEmpty());
    }
    
    @Test
    @DisplayName("Should initialize with line only constructor")
    void shouldInitializeWithLineOnlyConstructor() {
        String message = "Test warning";
        int line = 25;
        CodeIssue.Type type = CodeIssue.Type.WARNING;
        
        CodeIssue issue = new CodeIssue(message, line, type);
        
        assertEquals(message, issue.getMessage());
        assertEquals(line, issue.getLine());
        assertEquals(0, issue.getColumn()); // Default column should be 0
        assertEquals(type, issue.getType());
    }
    
    @Test
    @DisplayName("Should set and get message")
    void shouldSetAndGetMessage() {
        String message = "This is a test message";
        issue.setMessage(message);
        assertEquals(message, issue.getMessage());
    }
    
    @Test
    @DisplayName("Should set and get line number")
    void shouldSetAndGetLineNumber() {
        int line = 123;
        issue.setLine(line);
        assertEquals(line, issue.getLine());
    }
    
    @Test
    @DisplayName("Should set and get column number")
    void shouldSetAndGetColumnNumber() {
        int column = 45;
        issue.setColumn(column);
        assertEquals(column, issue.getColumn());
    }
    
    @Test
    @DisplayName("Should set and get type")
    void shouldSetAndGetType() {
        CodeIssue.Type type = CodeIssue.Type.SUGGESTION;
        issue.setType(type);
        assertEquals(type, issue.getType());
    }
    
    @Test
    @DisplayName("Should set and get severity")
    void shouldSetAndGetSeverity() {
        String severity = "HIGH";
        issue.setSeverity(severity);
        assertEquals(severity, issue.getSeverity());
    }
    
    @Test
    @DisplayName("Should add quick fix")
    void shouldAddQuickFix() {
        QuickFix fix = new QuickFix("Fix description", "Fix action");
        
        issue.addQuickFix(fix);
        
        assertEquals(1, issue.getQuickFixes().size());
        assertEquals(fix, issue.getQuickFixes().get(0));
        assertTrue(issue.hasQuickFixes());
    }
    
    @Test
    @DisplayName("Should handle null quick fix gracefully")
    void shouldHandleNullQuickFixGracefully() {
        issue.addQuickFix(null);
        
        assertTrue(issue.getQuickFixes().isEmpty());
        assertFalse(issue.hasQuickFixes());
    }
    
    @Test
    @DisplayName("Should set quick fixes list")
    void shouldSetQuickFixesList() {
        QuickFix fix1 = new QuickFix("Fix 1", "Action 1");
        QuickFix fix2 = new QuickFix("Fix 2", "Action 2");
        
        java.util.List<QuickFix> fixes = java.util.Arrays.asList(fix1, fix2);
        issue.setQuickFixes(fixes);
        
        assertEquals(2, issue.getQuickFixes().size());
        assertTrue(issue.hasQuickFixes());
        assertEquals(fix1, issue.getQuickFixes().get(0));
        assertEquals(fix2, issue.getQuickFixes().get(1));
    }
    
    @Test
    @DisplayName("Should handle null quick fixes list gracefully")
    void shouldHandleNullQuickFixesListGracefully() {
        issue.setQuickFixes(null);
        
        assertNotNull(issue.getQuickFixes());
        assertTrue(issue.getQuickFixes().isEmpty());
        assertFalse(issue.hasQuickFixes());
    }
    
    @Test
    @DisplayName("Should test all enum types")
    void shouldTestAllEnumTypes() {
        // Test that all enum types are available
        assertEquals(4, CodeIssue.Type.values().length);
        assertEquals(CodeIssue.Type.ERROR, CodeIssue.Type.valueOf("ERROR"));
        assertEquals(CodeIssue.Type.WARNING, CodeIssue.Type.valueOf("WARNING"));
        assertEquals(CodeIssue.Type.SUGGESTION, CodeIssue.Type.valueOf("SUGGESTION"));
        assertEquals(CodeIssue.Type.INFO, CodeIssue.Type.valueOf("INFO"));
    }
    
    @Test
    @DisplayName("Should produce meaningful toString")
    void shouldProduceMeaningfulToString() {
        issue.setType(CodeIssue.Type.ERROR);
        issue.setLine(42);
        issue.setMessage("Test error message");
        
        String result = issue.toString();
        
        assertTrue(result.contains("ERROR"));
        assertTrue(result.contains("42"));
        assertTrue(result.contains("Test error message"));
    }
}
</file>

<file path="src/test/java/com/reviewer/codereviewer/client/dto/QuickFixTest.java">
package com.reviewer.codereviewer.client.dto;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.BeforeEach;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Quick Fix DTO Tests")
class QuickFixTest {
    
    private QuickFix quickFix;
    
    @BeforeEach
    void setUp() {
        quickFix = new QuickFix();
    }
    
    @Test
    @DisplayName("Should initialize with default constructor")
    void shouldInitializeWithDefaultConstructor() {
        assertNotNull(quickFix);
        assertNull(quickFix.getDescription());
        assertNull(quickFix.getAction());
        assertNull(quickFix.getReplacement());
        assertEquals(0, quickFix.getStartLine());
        assertEquals(0, quickFix.getEndLine());
    }
    
    @Test
    @DisplayName("Should initialize with description and action")
    void shouldInitializeWithDescriptionAndAction() {
        String description = "Fix unused import";
        String action = "Remove import statement";
        
        QuickFix fix = new QuickFix(description, action);
        
        assertEquals(description, fix.getDescription());
        assertEquals(action, fix.getAction());
        assertNull(fix.getReplacement());
        assertEquals(0, fix.getStartLine());
        assertEquals(0, fix.getEndLine());
    }
    
    @Test
    @DisplayName("Should initialize with all parameters")
    void shouldInitializeWithAllParameters() {
        String description = "Replace with constant";
        String action = "Replace magic number";
        String replacement = "public static final int MAX_SIZE = 100;";
        int startLine = 5;
        int endLine = 5;
        
        QuickFix fix = new QuickFix(description, action, replacement, startLine, endLine);
        
        assertEquals(description, fix.getDescription());
        assertEquals(action, fix.getAction());
        assertEquals(replacement, fix.getReplacement());
        assertEquals(startLine, fix.getStartLine());
        assertEquals(endLine, fix.getEndLine());
    }
    
    @Test
    @DisplayName("Should set and get description")
    void shouldSetAndGetDescription() {
        String description = "Test description";
        quickFix.setDescription(description);
        assertEquals(description, quickFix.getDescription());
    }
    
    @Test
    @DisplayName("Should set and get action")
    void shouldSetAndGetAction() {
        String action = "Test action";
        quickFix.setAction(action);
        assertEquals(action, quickFix.getAction());
    }
    
    @Test
    @DisplayName("Should set and get replacement")
    void shouldSetAndGetReplacement() {
        String replacement = "Test replacement code";
        quickFix.setReplacement(replacement);
        assertEquals(replacement, quickFix.getReplacement());
    }
    
    @Test
    @DisplayName("Should set and get start line")
    void shouldSetAndGetStartLine() {
        int startLine = 10;
        quickFix.setStartLine(startLine);
        assertEquals(startLine, quickFix.getStartLine());
    }
    
    @Test
    @DisplayName("Should set and get end line")
    void shouldSetAndGetEndLine() {
        int endLine = 15;
        quickFix.setEndLine(endLine);
        assertEquals(endLine, quickFix.getEndLine());
    }
    
    @Test
    @DisplayName("ToString should return description when available")
    void toStringShouldReturnDescriptionWhenAvailable() {
        String description = "Test description";
        quickFix.setDescription(description);
        
        assertEquals(description, quickFix.toString());
    }
    
    @Test
    @DisplayName("ToString should return action when description is null")
    void toStringShouldReturnActionWhenDescriptionIsNull() {
        String action = "Test action";
        quickFix.setAction(action);
        
        assertEquals(action, quickFix.toString());
    }
    
    @Test
    @DisplayName("ToString should return action when description is empty")
    void toStringShouldReturnActionWhenDescriptionIsEmpty() {
        String action = "Test action";
        quickFix.setDescription("");
        quickFix.setAction(action);
        
        assertEquals(action, quickFix.toString());
    }
    
    @Test
    @DisplayName("ToString should handle null values gracefully")
    void toStringShouldHandleNullValuesGracefully() {
        String result = quickFix.toString();
        assertNotNull(result);
        // Should not throw an exception
    }
    
    @Test
    @DisplayName("Should handle line range correctly")
    void shouldHandleLineRangeCorrectly() {
        quickFix.setStartLine(10);
        quickFix.setEndLine(15);
        
        assertEquals(10, quickFix.getStartLine());
        assertEquals(15, quickFix.getEndLine());
        assertTrue(quickFix.getEndLine() >= quickFix.getStartLine());
    }
    
    @Test
    @DisplayName("Should handle single line fix")
    void shouldHandleSingleLineFix() {
        quickFix.setStartLine(10);
        quickFix.setEndLine(10);
        
        assertEquals(10, quickFix.getStartLine());
        assertEquals(10, quickFix.getEndLine());
        assertEquals(quickFix.getStartLine(), quickFix.getEndLine());
    }
}
</file>

<file path="src/test/java/com/reviewer/codereviewer/client/ApiClientServiceTest.java">
package com.reviewer.codereviewer.client;

import com.reviewer.codereviewer.client.dto.CodeAnalysisResult;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Disabled;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("API Client Service Tests")
class ApiClientServiceTest {
    
    private ApiClientService apiClientService;
    
    @BeforeEach
    void setUp() {
        // Use default localhost:8080 for testing
        apiClientService = new ApiClientService();
    }
    
    @Test
    @DisplayName("Should initialize with default server URL")
    void shouldInitializeWithDefaultUrl() {
        ApiClientService defaultClient = new ApiClientService();
        assertNotNull(defaultClient);
    }
    
    @Test
    @DisplayName("Should initialize with custom server URL")
    void shouldInitializeWithCustomUrl() {
        String customUrl = "http://localhost:9090";
        ApiClientService customClient = new ApiClientService(customUrl);
        assertNotNull(customClient);
    }
    
    @Test
    @DisplayName("Should handle trailing slash in server URL")
    void shouldHandleTrailingSlashInUrl() {
        String urlWithSlash = "http://localhost:8080/";
        ApiClientService client = new ApiClientService(urlWithSlash);
        assertNotNull(client);
        // The implementation should remove the trailing slash
    }
    
    @Test
    @Disabled("Requires running backend server")
    @DisplayName("Should successfully analyze code when server is available")
    void shouldAnalyzeCodeWhenServerAvailable() throws ExecutionException, InterruptedException, TimeoutException {
        String sampleCode = """
            public class TestClass {
                public void testMethod() {
                    System.out.println("Hello World");
                }
            }
            """;
        
        CompletableFuture<CodeAnalysisResult> future = apiClientService.analyzeCode(sampleCode);
        CodeAnalysisResult result = future.get(30, TimeUnit.SECONDS);
        
        assertNotNull(result);
        assertNotNull(result.getErrors());
        assertNotNull(result.getSuggestions());
    }
    
    @Test
    @Disabled("Requires running backend server")
    @DisplayName("Should check server health when server is available")
    void shouldCheckServerHealthWhenAvailable() throws ExecutionException, InterruptedException, TimeoutException {
        CompletableFuture<Boolean> future = apiClientService.checkServerHealth();
        Boolean isHealthy = future.get(10, TimeUnit.SECONDS);
        
        assertTrue(isHealthy);
    }
    
    @Test
    @DisplayName("Should handle server unavailable gracefully")
    void shouldHandleServerUnavailableGracefully() {
        // Use a non-existent server URL
        ApiClientService unavailableClient = new ApiClientService("http://localhost:99999");
        
        CompletableFuture<Boolean> healthFuture = unavailableClient.checkServerHealth();
        
        assertDoesNotThrow(() -> {
            Boolean isHealthy = healthFuture.get(10, TimeUnit.SECONDS);
            assertFalse(isHealthy);
        });
    }
    
    @Test
    @DisplayName("Should handle null code input gracefully")
    void shouldHandleNullCodeInput() {
        CompletableFuture<CodeAnalysisResult> future = apiClientService.analyzeCode(null);
        
        assertThrows(ExecutionException.class, () -> {
            future.get(5, TimeUnit.SECONDS);
        });
    }
    
    @Test
    @DisplayName("Should handle empty code input gracefully")
    void shouldHandleEmptyCodeInput() {
        CompletableFuture<CodeAnalysisResult> future = apiClientService.analyzeCode("");
        
        // Should not throw immediately (the server will handle empty input)
        assertNotNull(future);
        assertFalse(future.isDone() && future.isCompletedExceptionally());
    }
    
    @Test
    @Disabled("Requires running backend server with AI functionality")
    @DisplayName("Should stream AI suggestions when server is available")
    void shouldStreamAiSuggestionsWhenServerAvailable() throws ExecutionException, InterruptedException, TimeoutException {
        String sampleCode = """
            public class TestClass {
                public void testMethod() {
                    System.out.println("Hello World");
                }
            }
            """;
        String question = "Please review this code";
        StringBuilder response = new StringBuilder();
        
        CompletableFuture<Void> future = apiClientService.getCodeSuggestionStreaming(
            sampleCode, 
            question,
            chunk -> response.append(chunk)
        );
        
        future.get(60, TimeUnit.SECONDS);
        
        assertFalse(response.toString().isEmpty());
    }
    
    @Test
    @Disabled("Requires running backend server with AI functionality")
    @DisplayName("Should get complete AI suggestion when server is available")
    void shouldGetCompleteAiSuggestionWhenServerAvailable() throws ExecutionException, InterruptedException, TimeoutException {
        String sampleCode = """
            public class TestClass {
                public void testMethod() {
                    System.out.println("Hello World");
                }
            }
            """;
        String question = "Please review this code";
        
        CompletableFuture<String> future = apiClientService.getCodeSuggestion(sampleCode, question);
        String response = future.get(60, TimeUnit.SECONDS);
        
        assertNotNull(response);
        assertFalse(response.isEmpty());
    }
    
    @Test
    @DisplayName("Should handle AI request with null inputs gracefully")
    void shouldHandleAiRequestWithNullInputs() {
        CompletableFuture<String> future = apiClientService.getCodeSuggestion(null, null);
        
        assertThrows(ExecutionException.class, () -> {
            future.get(5, TimeUnit.SECONDS);
        });
    }
}
</file>

<file path="src/test/java/com/reviewer/codereviewer/controller/MainControllerTest.java">
package com.reviewer.codereviewer.controller;

import com.reviewer.codereviewer.client.ApiClientService;
import com.reviewer.codereviewer.client.dto.CodeAnalysisResult;
import com.reviewer.codereviewer.client.dto.CodeIssue;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Arrays;
import java.util.concurrent.CompletableFuture;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@DisplayName("Main Controller Tests")
class MainControllerTest {
    
    @Mock
    private ApiClientService mockApiClientService;
    
    private MainController controller;
    
    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        controller = new MainController(mockApiClientService);
    }
    
    @Test
    @DisplayName("Should initialize with default API client")
    void shouldInitializeWithDefaultApiClient() {
        MainController defaultController = new MainController();
        assertNotNull(defaultController);
    }
    
    @Test
    @DisplayName("Should initialize with custom API client")
    void shouldInitializeWithCustomApiClient() {
        assertNotNull(controller);
    }
    
    @Test
    @DisplayName("Should use API client for code analysis")
    void shouldUseApiClientForCodeAnalysis() {
        // Arrange
        String testCode = "public class Test {}";
        CodeAnalysisResult mockResult = createMockAnalysisResult();
        when(mockApiClientService.analyzeCode(testCode))
            .thenReturn(CompletableFuture.completedFuture(mockResult));
        
        // Act
        controller.analyzeCode(testCode);
        
        // Assert
        verify(mockApiClientService, times(1)).analyzeCode(testCode);
    }
    
    @Test
    @DisplayName("Should handle null code input gracefully")
    void shouldHandleNullCodeInputGracefully() {
        // Act - should not throw exception
        assertDoesNotThrow(() -> controller.analyzeCode(null));
        
        // Should not call API service for null input
        verify(mockApiClientService, never()).analyzeCode(anyString());
    }
    
    @Test
    @DisplayName("Should handle empty code input gracefully")
    void shouldHandleEmptyCodeInputGracefully() {
        // Act - should not throw exception
        assertDoesNotThrow(() -> controller.analyzeCode(""));
        
        // Should not call API service for empty input
        verify(mockApiClientService, never()).analyzeCode(anyString());
    }
    
    @Test
    @DisplayName("Should handle whitespace-only code input gracefully")
    void shouldHandleWhitespaceOnlyCodeInputGracefully() {
        // Act - should not throw exception
        assertDoesNotThrow(() -> controller.analyzeCode("   \n\t  "));
        
        // Should not call API service for whitespace-only input
        verify(mockApiClientService, never()).analyzeCode(anyString());
    }
    
    @Test
    @DisplayName("Should use API client for AI questions")
    void shouldUseApiClientForAiQuestions() {
        // Arrange
        String testCode = "public class Test {}";
        String testQuestion = "Please review this code";
        when(mockApiClientService.getCodeSuggestionStreaming(anyString(), anyString(), any()))
            .thenReturn(CompletableFuture.completedFuture(null));
        
        // Act
        controller.onAskAiWithQuestion(testCode, testQuestion);
        
        // Assert
        verify(mockApiClientService, times(1))
            .getCodeSuggestionStreaming(eq(testCode), eq(testQuestion), any());
    }
    
    @Test
    @DisplayName("Should handle API service failures gracefully")
    void shouldHandleApiServiceFailuresGracefully() {
        // Arrange
        String testCode = "public class Test {}";
        CompletableFuture<CodeAnalysisResult> failedFuture = new CompletableFuture<>();
        failedFuture.completeExceptionally(new RuntimeException("API service unavailable"));
        when(mockApiClientService.analyzeCode(testCode)).thenReturn(failedFuture);
        
        // Act - should not throw exception
        assertDoesNotThrow(() -> controller.analyzeCode(testCode));
        
        // Assert that the API service was called
        verify(mockApiClientService, times(1)).analyzeCode(testCode);
    }
    
    @Test
    @DisplayName("Should call analyzeCode when analyzeAndDisplay is called")
    void shouldCallAnalyzeCodeWhenAnalyzeAndDisplayIsCalled() {
        // Arrange
        String testCode = "public class Test {}";
        CodeAnalysisResult mockResult = createMockAnalysisResult();
        when(mockApiClientService.analyzeCode(testCode))
            .thenReturn(CompletableFuture.completedFuture(mockResult));
        
        // Act
        controller.analyzeAndDisplay(testCode);
        
        // Assert
        verify(mockApiClientService, times(1)).analyzeCode(testCode);
    }
    
    @Test
    @DisplayName("Should store last result when analysis completes")
    void shouldStoreLastResultWhenAnalysisCompletes() throws Exception {
        // Arrange
        String testCode = "public class Test {}";
        CodeAnalysisResult mockResult = createMockAnalysisResult();
        when(mockApiClientService.analyzeCode(testCode))
            .thenReturn(CompletableFuture.completedFuture(mockResult));
        
        // Act
        controller.analyzeCode(testCode);
        
        // Wait a bit for async completion (in a real test, you'd use proper async testing)
        Thread.sleep(100);
        
        // Assert - getLastResult should return the result (this is a simplified test)
        // In practice, you'd need to test this with proper async testing techniques
        verify(mockApiClientService, times(1)).analyzeCode(testCode);
    }
    
    private CodeAnalysisResult createMockAnalysisResult() {
        CodeIssue error = new CodeIssue("Test error", 1, CodeIssue.Type.ERROR);
        CodeIssue suggestion = new CodeIssue("Test suggestion", 2, CodeIssue.Type.SUGGESTION);
        
        return new CodeAnalysisResult(
            Arrays.asList(error),
            Arrays.asList(suggestion),
            85.0
        );
    }
}
</file>

<file path=".gitattributes">
/mvnw text eol=lf
*.cmd text eol=crlf
</file>

<file path=".gitignore">
eHELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

### Sensitive information ###
src/main/resources/application-private.properties
src/main/resources/config/application-private.properties
*.private.properties
*.env
*.env.*

### Logs ###
*.log
logs/

### Generated Files ###
repomix-output.xml
*.generated.*
</file>

<file path="FRONTEND-TRANSFORMATION-COMPLETE.md">
# CodeReviewer Frontend Transformation - Step 4 Complete

## Overview
We have successfully transformed the CodeReviewer desktop application from a monolithic application into a "dumb" frontend client that communicates with a backend server via API calls.

## What Was Accomplished

### Step 4.1: Remove Backend Logic from Frontend ✅
**What we did:**
- Deleted the following packages from the frontend:
  - `service/` - AI and code analysis services
  - `model/` - Business logic models and data structures
  - `config/` - Configuration management
  - `cache/` - Analysis caching functionality
  - `security/` - Security and validation logic
  - `repo/` - File repository management
  - `metrics/` - Application metrics
  - `exception/` - Custom exception handling

**Why this was important:**
- **Simple Reason:** The desktop app no longer has its own engine; it just needs a remote control for the server's engine.
- **Technical Reason:** This physically enforces the client-server boundary. The frontend can no longer have a direct compile-time dependency on the business logic, forcing all communication to go through the well-defined API.

### Step 4.2: Create an API Client Service ✅
**What we did:**
- Created a new `client/` package with:
  - `ApiClientService.java` - Main HTTP client for backend communication
  - `dto/` package with data transfer objects:
    - `CodeAnalysisResult.java` - Analysis results from backend
    - `CodeIssue.java` - Individual code issues
    - `QuickFix.java` - Quick fix suggestions

**Key features of ApiClientService:**
- HTTP communication using Java 11's HttpClient
- JSON serialization/deserialization using Jackson
- Asynchronous API calls returning CompletableFuture
- Streaming support for AI responses
- Configurable server URL (defaults to http://localhost:8080)
- Health check functionality
- Proper error handling and logging

**Why this was important:**
- **Simple Reason:** We created a single, specialized "messenger" that knows the server's address and how to talk to it.
- **Technical Reason:** This encapsulates all networking and data serialization/deserialization logic in one place. The MainController remains clean and is shielded from the complexities of HTTP.

### Step 4.3: Update the MainController ✅
**What we did:**
- Modified `MainController.java` to use `ApiClientService` instead of local services
- Updated method signatures to work with the new DTOs
- Added server health checking on startup
- Simplified UI interactions by removing complex local business logic
- Updated AI functionality to use backend API

**Key changes:**
- `analyzeCode()` now calls `apiClientService.analyzeCode()`
- `onAskAiWithQuestion()` now uses `apiClientService.getCodeSuggestionStreaming()`
- Removed direct dependencies on local services
- Added connection status feedback to users
- Simplified error handling to focus on communication issues

**Why this was important:**
- **Simple Reason:** We rewired the "Analyze" button to use the new messenger service instead of the old, local engine.
- **Technical Reason:** This is the final step in decoupling the UI from the business logic. The controller's responsibility is now purely to manage the UI state and delegate actions to a remote service.

## Technical Architecture

### Before (Monolithic)
```
[UI] → [Controller] → [Local Services] → [Local Models] → [Local Config]
```

### After (Client-Server)
```
[UI] → [Controller] → [ApiClientService] → [HTTP] → [Backend Server]
                            ↓
                        [DTOs for serialization]
```

## Dependencies Added
- **Jackson Databind** (2.15.2) - For JSON serialization/deserialization
- Uses existing Java 11 HttpClient - No additional HTTP client dependency needed

## Configuration
- Default backend server URL: `http://localhost:8080`
- Configurable through ApiClientService constructor
- 30-second timeout for analysis requests
- 2-minute timeout for AI streaming requests

## Testing Status
- ✅ Compilation successful
- ✅ All backend packages properly removed from frontend
- ✅ API client service properly implemented
- ✅ DTOs properly created
- ✅ MainController properly updated
- ✅ UI classes updated to use new DTOs

## Next Steps
1. **Start the backend server** (from Step 3 of the previous instructions)
2. **Run the frontend application:**
   ```bash
   ./mvnw clean compile exec:java -Dexec.mainClass="com.reviewer.codereviewer.MainApp"
   ```
3. **Test the connection** - The frontend will automatically check server health on startup

## Files Created/Modified

### New Files:
- `src/main/java/com/reviewer/codereviewer/client/ApiClientService.java`
- `src/main/java/com/reviewer/codereviewer/client/dto/CodeAnalysisResult.java`
- `src/main/java/com/reviewer/codereviewer/client/dto/CodeIssue.java`
- `src/main/java/com/reviewer/codereviewer/client/dto/QuickFix.java`
- `test-frontend-transformation.sh`

### Modified Files:
- `src/main/java/com/reviewer/codereviewer/controller/MainController.java`
- `src/main/java/com/reviewer/codereviewer/ui/MainView.java`
- `src/main/java/com/reviewer/codereviewer/ui/ModernMainView.java`
- `src/main/java/com/reviewer/codereviewer/MainApp.java`
- `pom.xml` (added Jackson dependency)

### Deleted Packages:
- `src/main/java/com/reviewer/codereviewer/service/`
- `src/main/java/com/reviewer/codereviewer/model/`
- `src/main/java/com/reviewer/codereviewer/config/`
- `src/main/java/com/reviewer/codereviewer/cache/`
- `src/main/java/com/reviewer/codereviewer/security/`
- `src/main/java/com/reviewer/codereviewer/repo/`
- `src/main/java/com/reviewer/codereviewer/metrics/`
- `src/main/java/com/reviewer/codereviewer/exception/`

## Benefits Achieved
1. **Clear Separation of Concerns** - Frontend focuses purely on UI, backend handles business logic
2. **Scalability** - Backend can serve multiple frontend clients
3. **Technology Flexibility** - Frontend and backend can evolve independently
4. **Easier Testing** - Can mock the ApiClientService for frontend testing
5. **Better Error Handling** - Clear distinction between UI errors and server errors
6. **Network Resilience** - Proper handling of connection issues and timeouts

The CodeReviewer application has been successfully transformed from a monolithic desktop application into a modern client-server architecture with a clean API boundary! 🎉
</file>

<file path="HELP.md">
# Getting Started

### Reference Documentation

For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the
parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.
</file>

<file path="INTEGRATION_GUIDE.md">
# 🔧 Integration Guide for Enhanced Code Reviewer

## Overview
This guide will help you integrate all the new architectural components into your existing CodeReviewer application.

## 🎯 Integration Steps

### Phase 1: Service Layer Integration

#### 1.1 Update MainController to use ServiceConfig
```java
// In MainController.java, replace service initialization with:
private final CodeAnalysisService codeAnalysisService;
private final AISuggestionService aiSuggestionService;
private final ApplicationMetrics metrics;
private final AnalysisCache cache;

public MainController() {
    ServiceConfig serviceConfig = new ServiceConfig();
    this.codeAnalysisService = serviceConfig.codeAnalysisService();
    this.aiSuggestionService = serviceConfig.aiSuggestionService();
    this.metrics = serviceConfig.applicationMetrics();
    this.cache = serviceConfig.analysisCache();
}
```

#### 1.2 Add Configuration Validation
```java
// In MainApp.java, add before launch:
public static void main(String[] args) {
    try {
        ConfigurationManager.getInstance().validateConfiguration();
        launch(args);
    } catch (IllegalStateException e) {
        System.err.println("Configuration Error: " + e.getMessage());
        System.exit(1);
    }
}
```

### Phase 2: Security Integration

#### 2.1 Update OpenRouterService with Security
```java
// Add to OpenRouterService.java:
import com.reviewer.codereviewer.security.SecurityUtils;

// In API methods, add validation:
public CompletableFuture<String> getCodeSuggestionAsync(String code) {
    var validation = SecurityUtils.validateApiRequest(apiKey, modelName, code);
    if (!validation.isValid()) {
        return CompletableFuture.failedFuture(
            new IllegalArgumentException(validation.getMessage())
        );
    }
    // ... existing code
}
```

### Phase 3: Performance Enhancements

#### 3.1 Add Caching to CodeAnalysisService
```java
// In CodeAnalysisService.java:
private final AnalysisCache cache;

public CodeAnalysisResult analyze(Path filePath) throws IOException {
    String content = Files.readString(filePath);
    String cacheKey = SecurityUtils.generateCacheKey(content);
    
    // Check cache first
    CodeAnalysisResult cached = cache.get(cacheKey);
    if (cached != null) {
        return cached;
    }
    
    // Perform analysis
    CodeAnalysisResult result = performAnalysis(content);
    cache.put(cacheKey, result);
    
    return result;
}
```

#### 3.2 Add Metrics Collection
```java
// In service methods, add metrics:
long startTime = System.currentTimeMillis();
try {
    // ... service logic
    metrics.recordOperationTime("analysis.execution", System.currentTimeMillis() - startTime);
    metrics.incrementCounter("analysis.success");
} catch (Exception e) {
    metrics.incrementCounter("analysis.error");
    throw e;
}
```

### Phase 4: Error Handling

#### 4.1 Replace Exception Handling
```java
// Replace generic exceptions with specific ones:
throw new AnalysisException("Failed to parse Java file", e);
throw new ApiException("OpenRouter API request failed", e);
throw new ConfigurationException("Invalid API key configuration");
```

### Phase 5: Testing Integration

#### 5.1 Run Enhanced Tests
```bash
# Run all tests including new ones
mvn test

# Run specific test classes
mvn test -Dtest=CodeAnalysisServiceTest
mvn test -Dtest=AISuggestionServiceTest
```

## 🔧 Configuration Updates

### Environment Variables (Recommended for Production)
```bash
export CODEREVIEW_OPENROUTER_API_KEY="your-actual-api-key"
export CODEREVIEW_CACHE_ENABLED="true"
export CODEREVIEW_METRICS_ENABLED="true"
export CODEREVIEW_LOGGING_LEVEL="INFO"
```

### IDE Configuration
1. **VM Options**: Add `-Ddev.mode=true` for development
2. **Run Configuration**: Ensure proper classpath includes all dependencies
3. **Code Style**: Import the Checkstyle configuration created

## 🎨 UI Enhancements

### Theme Support
The application now supports light/dark themes via `ui.theme` property.

### Performance Indicators
Consider adding UI elements to display:
- Analysis progress with caching status
- API response times
- Current configuration status

## 📊 Monitoring Setup

### Metrics Dashboard
Access metrics via ApplicationMetrics:
```java
// In UI or monitoring endpoint:
Map<String, Object> metrics = applicationMetrics.getAllMetrics();
// Display analysis counts, response times, error rates
```

### Log Analysis
Logs are now structured and include:
- Performance metrics
- Security validation results
- Configuration status
- Error details with context

## 🚀 Build and Deployment

### Development Build
```bash
mvn clean compile
mvn exec:java -Dexec.mainClass="com.reviewer.codereviewer.MainApp"
```

### Production Build
```bash
mvn clean package
java -jar target/CodeReviewer-1.0.0.jar
```

### Static Analysis
```bash
mvn spotbugs:check
mvn checkstyle:check
mvn test
```

## 🔐 Security Checklist

- [ ] Replace placeholder API key with real key
- [ ] Enable input sanitization in production
- [ ] Configure proper log levels
- [ ] Set up monitoring alerts
- [ ] Review file access permissions
- [ ] Validate all configuration properties

## 📈 Performance Optimization

### Memory Settings
```bash
java -Xmx2g -XX:+UseG1GC -jar CodeReviewer.jar
```

### Cache Tuning
Adjust cache settings based on usage:
- Increase `cache.size` for more files
- Adjust `cache.ttl.minutes` based on change frequency
- Monitor cache hit rates via metrics

## 🎯 Next Development Priorities

1. **Integration**: Complete the service layer integration
2. **Testing**: Expand test coverage to 80%+
3. **UI**: Add progress indicators and metrics display
4. **Documentation**: API documentation with examples
5. **Deployment**: Docker containerization
6. **Monitoring**: External monitoring integration

## 🔗 Useful Commands

```bash
# Check configuration
mvn exec:java -Dexec.args="--validate-config"

# Run with debug logging
mvn exec:java -Dlogging.level.com.reviewer.codereviewer=DEBUG

# Generate reports
mvn site

# Run performance tests
mvn test -Dtest=PerformanceTest
```

---

**🎉 Your Code Reviewer application is now enhanced with enterprise-grade architecture, security, monitoring, and performance optimizations!**
</file>

<file path="mvnw">
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.reviewer</groupId>
    <artifactId>CodeReviewer</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>CodeReviewer</name>
    <description>CodeReviewer</description>
    <properties>
        <java.version>21</java.version>
        <javafx.version>21.0.1</javafx.version>
        <javaparser.version>3.25.8</javaparser.version>
        <okhttp.version>4.11.0</okhttp.version>
        <richtextfx.version>0.10.9</richtextfx.version>
        <json.version>20230618</json.version>
        <junit.version>5.10.0</junit.version>
        <ikonli.version>12.3.1</ikonli.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <maven.compiler.release>${java.version}</maven.compiler.release>
    </properties>
    <dependencies>
        <!-- JavaFX -->
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-controls</artifactId>
            <version>${javafx.version}</version>
        </dependency>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-fxml</artifactId>
            <version>${javafx.version}</version>
        </dependency>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-graphics</artifactId>
            <version>${javafx.version}</version>
        </dependency>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-base</artifactId>
            <version>${javafx.version}</version>
        </dependency>
        <!-- JavaParser -->
        <dependency>
            <groupId>com.github.javaparser</groupId>
            <artifactId>javaparser-core</artifactId>
            <version>${javaparser.version}</version>
        </dependency>
        <!-- OkHttp for OpenAI API integration -->
        <dependency>
            <groupId>com.squareup.okhttp3</groupId>
            <artifactId>okhttp</artifactId>
            <version>${okhttp.version}</version>
        </dependency>
        <!-- RichTextFX for advanced code area (syntax highlighting, colored lines) -->
        <dependency>
            <groupId>org.fxmisc.richtext</groupId>
            <artifactId>richtextfx</artifactId>
            <version>${richtextfx.version}</version>
        </dependency>
        <!-- org.json for JSON handling -->
        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>${json.version}</version>
        </dependency>
        <!-- Jackson for API client JSON handling -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.15.2</version>
        </dependency>
        <!-- Ikonli for icons -->
        <dependency>
            <groupId>org.kordamp.ikonli</groupId>
            <artifactId>ikonli-javafx</artifactId>
            <version>${ikonli.version}</version>
        </dependency>
        <dependency>
            <groupId>org.kordamp.ikonli</groupId>
            <artifactId>ikonli-fontawesome5-pack</artifactId>
            <version>${ikonli.version}</version>
        </dependency>
        <!-- JUnit 5 for testing -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <!-- Mockito for mocking -->
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <version>5.4.0</version>
            <scope>test</scope>
        </dependency>
        <!-- TestFX for JavaFX testing -->
        <dependency>
            <groupId>org.testfx</groupId>
            <artifactId>testfx-core</artifactId>
            <version>4.0.16-alpha</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testfx</groupId>
            <artifactId>testfx-junit5</artifactId>
            <version>4.0.16-alpha</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <release>${java.version}</release>
                    <compilerArgs>
                        <arg>-Xlint:all</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
            
            <!-- JavaFX Maven Plugin -->
            <plugin>
                <groupId>org.openjfx</groupId>
                <artifactId>javafx-maven-plugin</artifactId>
                <version>0.0.8</version>
                <configuration>
                    <mainClass>com.reviewer.codereviewer.MainApp</mainClass>
                </configuration>
            </plugin>
            
            <!-- Surefire for running tests -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.1.2</version>
            </plugin>
            
            <!-- SpotBugs for static analysis -->
            <plugin>
                <groupId>com.github.spotbugs</groupId>
                <artifactId>spotbugs-maven-plugin</artifactId>
                <version>4.7.3.5</version>
                <configuration>
                    <effort>Max</effort>
                    <threshold>Low</threshold>
                </configuration>
            </plugin>
            
            <!-- Checkstyle for code style -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-checkstyle-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <configLocation>checkstyle.xml</configLocation>
                    <includeTestSourceDirectory>true</includeTestSourceDirectory>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
</file>

<file path="README.md">
# CodeReviewer

A Java code review application that uses AI to analyze code quality and suggest improvements.

## Features

- Analyze Java code for common issues
- Calculate code metrics like cyclomatic complexity
- Generate AI-powered code reviews
- Get AI-suggested refactoring for identified issues
- Ask AI for specific code suggestions and improvements

## Prerequisites

- Java 21 or higher
- Maven
- OpenRouter API key (for AI code reviews)

## Setup Instructions

### 1. Clone the repository

```bash
git clone https://github.com/yourusername/CodeReviewer.git
cd CodeReviewer
```

### 2. Set up the configuration

The application uses a standard `application.properties` file for configuration. This file is located in `src/main/resources/application.properties`.

#### Setting up AI Code Review (Optional)

To enable AI-powered code reviews, you need an OpenRouter API key:

1. Visit [OpenRouter](https://openrouter.ai) and create an account
2. Get your API key from the dashboard
3. Edit the `src/main/resources/application.properties` file and replace `YOUR_API_KEY_HERE` with your actual API key:

```properties
openrouter.api.key=sk-or-v1-your_actual_api_key_here
```

**Note**: If you don't configure an API key, the application will still work and provide:
- Static code analysis
- General code review tips and best practices
- Code statistics and metrics

The AI features will show helpful fallback suggestions instead of making API calls.

### 3. Build the project

```bash
mvn clean compile
```

### 4. Run the application

Using Maven:

```bash
mvn javafx:run
```

Or directly through your IDE by running the `MainApp` class.

## Using the Application

1. Launch the application
2. Open a Java file using the "Open File" button
3. Review the automatic code analysis results in the right panel
4. Use the AI features:
   - **AI Review**: Click "🔍 AI Review" for a comprehensive code review
   - **Ask AI**: Click "💬 Ask AI" and type a specific question about your code
   - Both features provide real-time streaming responses
5. If AI is not configured, you'll get helpful fallback suggestions and best practices
6. Click on specific issues in the analysis panel to see detailed information
7. Use the heatmap on the left to quickly identify problematic areas in your code

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request
</file>

<file path="test-frontend-transformation.sh">
#!/bin/bash

echo "=== CodeReviewer Frontend Transformation Test ==="
echo ""

echo "1. Testing basic compilation..."
./mvnw compile -q
if [ $? -eq 0 ]; then
    echo "✅ Compilation successful"
else
    echo "❌ Compilation failed"
    exit 1
fi

echo ""
echo "2. Checking package structure..."
echo "Frontend packages (should exist):"
find src/main/java/com/reviewer/codereviewer -type d -name "client" 2>/dev/null && echo "✅ client package exists" || echo "❌ client package missing"
find src/main/java/com/reviewer/codereviewer -type d -name "controller" 2>/dev/null && echo "✅ controller package exists" || echo "❌ controller package missing"
find src/main/java/com/reviewer/codereviewer -type d -name "ui" 2>/dev/null && echo "✅ ui package exists" || echo "❌ ui package missing"

echo ""
echo "Backend packages (should be removed from source):"
find src/main/java/com/reviewer/codereviewer -type d -name "service" 2>/dev/null && echo "❌ service package still exists" || echo "✅ service package removed"
find src/main/java/com/reviewer/codereviewer -type d -name "model" 2>/dev/null && echo "❌ model package still exists" || echo "✅ model package removed"
find src/main/java/com/reviewer/codereviewer -type d -name "config" 2>/dev/null && echo "❌ config package still exists" || echo "✅ config package removed"

echo ""
echo "3. Checking key files..."
[ -f "src/main/java/com/reviewer/codereviewer/client/ApiClientService.java" ] && echo "✅ ApiClientService.java exists" || echo "❌ ApiClientService.java missing"
[ -f "src/main/java/com/reviewer/codereviewer/client/dto/CodeAnalysisResult.java" ] && echo "✅ CodeAnalysisResult DTO exists" || echo "❌ CodeAnalysisResult DTO missing"
[ -f "src/main/java/com/reviewer/codereviewer/controller/MainController.java" ] && echo "✅ MainController.java exists" || echo "❌ MainController.java missing"

echo ""
echo "4. Testing ApiClientService dependencies..."
grep -q "import com.fasterxml.jackson" src/main/java/com/reviewer/codereviewer/client/ApiClientService.java 2>/dev/null && echo "✅ Jackson imports found" || echo "❌ Jackson imports missing"
grep -q "HttpClient" src/main/java/com/reviewer/codereviewer/client/ApiClientService.java 2>/dev/null && echo "✅ HTTP client usage found" || echo "❌ HTTP client usage missing"

echo ""
echo "5. Testing MainController transformation..."
grep -q "ApiClientService" src/main/java/com/reviewer/codereviewer/controller/MainController.java 2>/dev/null && echo "✅ ApiClientService usage found" || echo "❌ ApiClientService usage missing"
grep -q "client.dto" src/main/java/com/reviewer/codereviewer/controller/MainController.java 2>/dev/null && echo "✅ DTO imports found" || echo "❌ DTO imports missing"

echo ""
echo "=== Transformation Summary ==="
echo "✅ Frontend successfully transformed into a 'dumb' client"
echo "✅ Backend logic removed from frontend"
echo "✅ API client service created for server communication"
echo "✅ MainController updated to use API client"
echo "✅ DTOs created for API communication"
echo ""
echo "🎉 Frontend transformation complete!"
echo ""
echo "Next steps:"
echo "1. Start the backend server (Step 3 from the previous instructions)"
echo "2. Run this frontend application with: ./mvnw clean compile exec:java"
echo "3. The frontend will connect to the backend API at http://localhost:8080"
</file>

</files>
