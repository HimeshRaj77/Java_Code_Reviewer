This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/
  src/
    main/
      java/
        com/
          project/
            codereviewer/
              cache/
                AnalysisCache.java
              config/
                AppConfig.java
              controller/
                AnalysisController.java
                MainController.java
              model/
                AnalysisRecord.java
                CodeAnalysisResult.java
                CodeIssue.java
                CommonQuickFixes.java
                QuickFix.java
                QuickFixHistory.java
              repo/
                JavaFileRepository.java
              security/
                SecurityUtils.java
              service/
                AISuggestionService.java
                CodeAnalysisService.java
                ThreadPoolManager.java
              Application.java
      resources/
        application-production.properties
        application.properties
    test/
      java/
        com/
          project/
            codereviewer/
              ApplicationTests.java
  build-docker.sh
  DEPLOYMENT.md
  docker-compose.yml
  Dockerfile
  HELP.md
  pom.xml
  test-analysis-controller.sh
frontend/
  META-INF/
    MANIFEST.MF
  src/
    main/
      java/
        com/
          reviewer/
            codereviewer/
              client/
                dto/
                  CodeAnalysisResult.java
                  CodeIssue.java
                  QuickFix.java
                ApiClientService.java
              controller/
                MainController.java
              ui/
                MainView.java
              MainApp.java
      resources/
        ai-style.css
        app-theme.css
        application.properties
        logging.properties
        modern-theme.css
    test/
      java/
        com/
          reviewer/
            codereviewer/
              client/
                dto/
                  CodeAnalysisResultTest.java
                  CodeIssueTest.java
                  QuickFixTest.java
                ApiClientServiceTest.java
              controller/
                MainControllerTest.java
  FRONTEND-TRANSFORMATION-COMPLETE.md
  HELP.md
  INTEGRATION_GUIDE.md
  pom.xml
  README.md
  test-frontend-transformation.sh
scripts/
  build-all.sh
  start-dev.sh
.gitignore
docker-compose.yml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/main/java/com/project/codereviewer/cache/AnalysisCache.java">
package com.project.codereviewer.cache;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

/**
 * Simple LRU-style cache with time-based expiration for code analysis results.
 * Thread-safe implementation using ConcurrentHashMap.
 */
public class AnalysisCache<K, V> {
    private static final Logger logger = Logger.getLogger(AnalysisCache.class.getName());
    
    private final ConcurrentHashMap<K, CacheEntry<V>> cache;
    private final long maxAgeMs;
    private final int maxSize;
    private final ScheduledExecutorService cleanupExecutor;
    
    private static class CacheEntry<V> {
        final V value;
        final long timestamp;
        volatile long lastAccessed;
        
        CacheEntry(V value) {
            this.value = value;
            this.timestamp = System.currentTimeMillis();
            this.lastAccessed = timestamp;
        }
    }
    
    public AnalysisCache(int maxSize, long maxAgeMs) {
        this.cache = new ConcurrentHashMap<>(maxSize);
        this.maxSize = maxSize;
        this.maxAgeMs = maxAgeMs;
        this.cleanupExecutor = Executors.newScheduledThreadPool(1, r -> {
            Thread t = new Thread(r, "Cache-Cleanup");
            t.setDaemon(true);
            return t;
        });
        
        // Schedule periodic cleanup
        cleanupExecutor.scheduleAtFixedRate(this::cleanup, 60, 60, TimeUnit.SECONDS);
        logger.info("AnalysisCache initialized with maxSize=" + maxSize + ", maxAge=" + maxAgeMs + "ms");
    }
    
    public V get(K key) {
        CacheEntry<V> entry = cache.get(key);
        if (entry == null) {
            return null;
        }
        
        // Check if expired
        if (System.currentTimeMillis() - entry.timestamp > maxAgeMs) {
            cache.remove(key);
            return null;
        }
        
        entry.lastAccessed = System.currentTimeMillis();
        return entry.value;
    }
    
    public void put(K key, V value) {
        // Simple size-based eviction
        if (cache.size() >= maxSize) {
            evictOldest();
        }
        
        cache.put(key, new CacheEntry<>(value));
    }
    
    private void evictOldest() {
        K oldestKey = null;
        long oldestTime = Long.MAX_VALUE;
        
        for (var entry : cache.entrySet()) {
            if (entry.getValue().lastAccessed < oldestTime) {
                oldestTime = entry.getValue().lastAccessed;
                oldestKey = entry.getKey();
            }
        }
        
        if (oldestKey != null) {
            cache.remove(oldestKey);
        }
    }
    
    private void cleanup() {
        long now = System.currentTimeMillis();
        int removed = 0;
        
        var iterator = cache.entrySet().iterator();
        while (iterator.hasNext()) {
            var entry = iterator.next();
            if (now - entry.getValue().timestamp > maxAgeMs) {
                iterator.remove();
                removed++;
            }
        }
        
        if (removed > 0) {
            logger.fine("Cache cleanup removed " + removed + " expired entries");
        }
    }
    
    public void clear() {
        cache.clear();
    }
    
    public int size() {
        return cache.size();
    }
    
    public void shutdown() {
        cleanupExecutor.shutdown();
        try {
            if (!cleanupExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                cleanupExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/config/AppConfig.java">
package com.project.codereviewer.config;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Centralized configuration class for handling application settings and secrets.
 * It loads API keys from a 'secrets.properties' file which should be excluded from version control.
 */
public final class AppConfig {
    private static final Logger LOGGER = Logger.getLogger(AppConfig.class.getName());
    
    private static final String CONFIG_FILE = "application.properties";
    private static final String OPENROUTER_API_KEY_PROP = "openrouter.api.key";
    private static final String OPENROUTER_MODEL_NAME_PROP = "openrouter.model.name";
    
    private static volatile Properties config;

    // Private constructor to prevent instantiation of this utility class.
    private AppConfig() {
        throw new AssertionError("AppConfig is a utility class and should not be instantiated.");
    }

    /**
     * Get the OpenRouter API key from the secrets.properties file.
     * * @return The API key as a String.
     * @throws IOException If the API key cannot be retrieved.
     */
    public static String getOpenRouterApiKey() throws IOException {
        Properties props = getConfig();
        String apiKey = props.getProperty(OPENROUTER_API_KEY_PROP);
        if (apiKey == null || apiKey.isBlank() || apiKey.equals("YOUR_API_KEY_HERE")) {
            throw new IOException("OpenRouter API key not found or not set in application.properties file. Please add 'openrouter.api.key=YOUR_API_KEY' to your configuration.");
        }
        return apiKey;
    }

    /**
     * Get the OpenRouter model name from the application.properties file, or use a default.
     * * @param defaultModel The default model to use if one is not specified in the properties file.
     * @return The model name as a String.
     */
    public static String getOpenRouterModelName(String defaultModel) {
        try {
            Properties props = getConfig();
            String model = props.getProperty(OPENROUTER_MODEL_NAME_PROP);
            
            if (model != null && !model.isBlank()) {
                LOGGER.log(Level.INFO, "Using AI model from configuration: {0}", model);
                return model;
            } else {
                LOGGER.log(Level.WARNING, "Model not specified in configuration. Using default model: {0}", defaultModel);
                return defaultModel;
            }
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "Could not load secrets.properties to check for a model name. Using default: {0}", defaultModel);
            return defaultModel;
        }
    }

    /**
     * Loads secrets from the properties file using a synchronized, double-checked locking pattern.
     * It searches for the 'secrets.properties' file in the classpath, current directory, and user's home directory.
     * * @return A Properties object containing the secrets.
     * @throws IOException If the secrets file cannot be found or loaded.
     */
    private static Properties getConfig() throws IOException {
        if (config == null) {
            synchronized (AppConfig.class) {
                if (config == null) {
                    config = loadProperties();
                }
            }
        }
        return config;
    }
    
    private static Properties loadProperties() throws IOException {
        Properties props = new Properties();
        
        // Try loading from classpath
        try (InputStream in = AppConfig.class.getClassLoader().getResourceAsStream(CONFIG_FILE)) {
            if (in != null) {
                LOGGER.info("Found application.properties in classpath.");
                props.load(in);
                return props;
            }
        }
        
        // Try loading from current directory
        Path configPath = Paths.get(CONFIG_FILE);
        if (Files.exists(configPath)) {
            LOGGER.info("Found application.properties in current directory: " + configPath.toAbsolutePath());
            try (InputStream in = Files.newInputStream(configPath)) {
                props.load(in);
                return props;
            }
        }

        // Try loading from user home directory
        Path homeConfigPath = Paths.get(System.getProperty("user.home"), CONFIG_FILE);
        if (Files.exists(homeConfigPath)) {
            LOGGER.info("Found application.properties in user home directory: " + homeConfigPath.toAbsolutePath());
            try (InputStream in = Files.newInputStream(homeConfigPath)) {
                props.load(in);
                return props;
            }
        }

        throw new IOException("application.properties file not found. Please create it in the classpath or current directory.");
    }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/controller/AnalysisController.java">
package com.project.codereviewer.controller;

import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import com.project.codereviewer.model.CodeAnalysisResult;
import com.project.codereviewer.service.CodeAnalysisService;
import com.project.codereviewer.service.AISuggestionService;
import java.util.logging.Logger;

/**
 * REST Controller for handling code analysis requests.
 * Acts as a switchboard operator that listens for incoming HTTP requests
 * and directs them to the appropriate service methods.
 */
@RestController
@RequestMapping("/api/analysis")
public class AnalysisController {
    
    private static final Logger logger = Logger.getLogger(AnalysisController.class.getName());
    
    /**
     * Dependency Injection: Instead of creating service instances ourselves,
     * we ask Spring framework to provide ready-to-use instances.
     * This applies Inversion of Control (IoC) principle.
     */
    @Autowired
    private CodeAnalysisService analysisService;
    
    @Autowired
    private AISuggestionService aiService;
    
    /**
     * Health check endpoint - like checking if the phone line is working
     * @return Simple status message
     */
    @GetMapping("/health")
    public ResponseEntity<String> health() {
        return ResponseEntity.ok("Analysis service is running!");
    }
    
    /**
     * Static code analysis endpoint - the main "phone extension" for code analysis
     * This method handles requests to analyze Java source code statically
     * 
     * @param code The Java source code to analyze (sent in request body)
     * @return CodeAnalysisResult containing errors, suggestions, and metrics
     */
    @PostMapping("/static")
    public ResponseEntity<CodeAnalysisResult> analyzeStatic(@RequestBody String code) {
        logger.info("Received static analysis request for code of length: " + code.length());
        
        try {
            // Use the injected service to perform analysis
            CodeAnalysisResult result = analysisService.analyze(code);
            logger.info("Analysis completed. Found " + result.getErrors().size() + 
                       " errors and " + result.getSuggestions().size() + " suggestions");
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            logger.severe("Analysis failed: " + e.getMessage());
            return ResponseEntity.internalServerError().build();
        }
    }
    
    /**
     * AI-powered code analysis endpoint - another "phone extension" for AI review
     * This method handles requests for AI-powered code suggestions
     * 
     * @param code The Java source code to get AI suggestions for
     * @return AI suggestions and recommendations
     */
    @PostMapping("/ai")
    public ResponseEntity<String> analyzeWithAI(@RequestBody String code) {
        logger.info("Received AI analysis request for code of length: " + code.length());
        
        try {
            // Use the injected AI service to get suggestions
            String suggestion = aiService.getCodeSuggestion(code);
            logger.info("AI analysis completed successfully");
            return ResponseEntity.ok(suggestion);
        } catch (Exception e) {
            logger.severe("AI analysis failed: " + e.getMessage());
            return ResponseEntity.ok("Error getting AI suggestion: " + e.getMessage());
        }
    }
    
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/controller/MainController.java">
package com.project.codereviewer.controller;

import com.project.codereviewer.model.CodeIssue;
import com.project.codereviewer.model.CodeAnalysisResult;
import com.project.codereviewer.model.AnalysisRecord;
import com.project.codereviewer.model.CommonQuickFixes;
import com.project.codereviewer.service.AISuggestionService;
import com.project.codereviewer.service.CodeAnalysisService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.logging.Level;
import java.util.logging.Logger;

@RestController
@RequestMapping("/api/code-review")
@CrossOrigin(origins = "*")
public class MainController {
    private static final Logger logger = Logger.getLogger(MainController.class.getName());
    
    @Autowired
    private CodeAnalysisService analysisService;
    
    @Autowired
    private AISuggestionService aiService;
    
    private String currentFileName = "";

    /**
     * Health check endpoint
     * @return Simple status message
     */
    @GetMapping("/health")
    public ResponseEntity<String> health() {
        return ResponseEntity.ok("Code Reviewer Backend is running!");
    }

    /**
     * Analyzes the provided code and returns results.
     * @param request The code analysis request containing the code to analyze
     * @return CodeAnalysisResult with analysis findings
     */
    @PostMapping("/analyze")
    public ResponseEntity<CodeAnalysisResult> analyzeCode(@RequestBody CodeAnalysisRequest request) {
        if (request.getCode() == null || request.getCode().trim().isEmpty()) {
            return ResponseEntity.badRequest().build();
        }
        
        try {
            CodeAnalysisResult result = analysisService.analyze(request.getCode());
            
            // Add quick fixes to applicable issues
            addQuickFixes(result);
            
            // Store analysis record for trend tracking
            if (request.getFileName() != null && !request.getFileName().isEmpty()) {
                currentFileName = request.getFileName();
                storeAnalysisRecord(result);
            }
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Analysis failed", e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Uploads and analyzes a Java file
     * @param file The Java file to analyze
     * @return CodeAnalysisResult with analysis findings
     */
    @PostMapping("/upload")
    public ResponseEntity<CodeAnalysisResult> uploadAndAnalyze(@RequestParam("file") MultipartFile file) {
        if (file.isEmpty()) {
            return ResponseEntity.badRequest().build();
        }
        
        try {
            String content = new String(file.getBytes(), StandardCharsets.UTF_8);
            currentFileName = file.getOriginalFilename();
            
            CodeAnalysisResult result = analysisService.analyze(content);
            addQuickFixes(result);
            storeAnalysisRecord(result);
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "File analysis failed", e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get AI suggestions for code with a specific question
     * @param request The AI suggestion request
     * @return AI response
     */
    @PostMapping("/ai-suggest")
    public ResponseEntity<AISuggestionResponse> getAISuggestion(@RequestBody AISuggestionRequest request) {
        if (request.getCode() == null || request.getCode().trim().isEmpty()) {
            return ResponseEntity.badRequest().build();
        }
        
        try {
            String question = request.getQuestion() != null ? request.getQuestion() : 
                            "Please review this code and suggest improvements.";
            
            logger.info("Starting AI request with question: \"" + question + "\"");
            
            String promptWithQuestion = buildPrompt(request.getCode(), question);
            
            // Get synchronous response
            String suggestion = aiService.getCodeSuggestion(promptWithQuestion);
            
            return ResponseEntity.ok(new AISuggestionResponse(suggestion));
        } catch (Exception e) {
            logger.log(Level.SEVERE, "AI suggestion failed", e);
            return ResponseEntity.ok(new AISuggestionResponse("Error getting AI suggestion: " + e.getMessage()));
        }
    }

    private void addQuickFixes(CodeAnalysisResult result) {
        for (CodeIssue issue : result.getErrors()) {
            if (issue.getMessage().toLowerCase().contains("unused import")) {
                issue.addQuickFix(CommonQuickFixes.unusedImportFix());
            } else if (issue.getMessage().toLowerCase().contains("magic number")) {
                issue.addQuickFix(CommonQuickFixes.magicNumberFix());
            } else if (issue.getMessage().toLowerCase().contains("method is too long")) {
                issue.addQuickFix(CommonQuickFixes.longMethodFix());
            } else if (issue.getMessage().toLowerCase().contains("empty catch block")) {
                issue.addQuickFix(CommonQuickFixes.emptyCatchBlockFix());
            } else if (issue.getMessage().toLowerCase().contains("poor variable name")) {
                issue.addQuickFix(CommonQuickFixes.poorVariableNameFix());
            }
        }
    }

    private String buildPrompt(String code, String question) {
        if (question.toLowerCase().contains("review") || question.toLowerCase().contains("analyze")) {
            return "CODE:\n```java\n" + code + "\n```\n\n" + 
                   "USER REQUEST: " + question + "\n\n" +
                   "Please provide a clear and specific response focusing on the user's request. " +
                   "If this is a code review request, focus on the most important issues first.";
        } else {
            return "CODE:\n```java\n" + code + "\n```\n\n" + 
                   "USER QUESTION: " + question + "\n\n" +
                   "Please answer this specific question about the code above.";
        }
    }
    
    private void storeAnalysisRecord(CodeAnalysisResult result) {
        try {
            AnalysisRecord record = new AnalysisRecord(currentFileName);
            record.setTotalIssues(result.getErrors().size() + result.getSuggestions().size());
            record.setTotalErrors(result.getErrors().size());
            record.setTotalSuggestions(result.getSuggestions().size());
            
            // Extract complexity metrics from suggestions
            for (CodeIssue issue : result.getSuggestions()) {
                if (issue.getMessage().contains("Cyclomatic complexity:")) {
                    String methodName = issue.getMessage().split(":")[0];
                    String complexityStr = issue.getMessage().split(":")[2].trim();
                    try {
                        int complexity = Integer.parseInt(complexityStr);
                        record.addComplexityMetric(methodName, complexity);
                    } catch (NumberFormatException e) {
                        // Ignore parsing errors
                    }
                }
            }
            
            // Append to analysis history file
            String homeDir = System.getProperty("user.home");
            String historyFile = homeDir + "/analysis_history.json";
            
            try (FileWriter writer = new FileWriter(historyFile, true)) {
                writer.write(record.toString() + "\n");
            }
        } catch (IOException e) {
            // Silently fail - trend tracking is not critical
            System.err.println("Failed to store analysis record: " + e.getMessage());
        }
    }

    // Request/Response DTOs
    public static class CodeAnalysisRequest {
        private String code;
        private String fileName;
        
        public String getCode() { return code; }
        public void setCode(String code) { this.code = code; }
        public String getFileName() { return fileName; }
        public void setFileName(String fileName) { this.fileName = fileName; }
    }
    
    public static class AISuggestionRequest {
        private String code;
        private String question;
        
        public String getCode() { return code; }
        public void setCode(String code) { this.code = code; }
        public String getQuestion() { return question; }
        public void setQuestion(String question) { this.question = question; }
    }
    
    public static class AISuggestionResponse {
        private String suggestion;
        
        public AISuggestionResponse(String suggestion) {
            this.suggestion = suggestion;
        }
        
        public String getSuggestion() { return suggestion; }
        public void setSuggestion(String suggestion) { this.suggestion = suggestion; }
    }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/model/AnalysisRecord.java">
package com.project.codereviewer.model;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.HashMap;

public class AnalysisRecord {
    private LocalDateTime timestamp;
    private String fileName;
    private Map<String, Integer> complexityMetrics;
    private int totalIssues;
    private int totalErrors;
    private int totalSuggestions;
    
    public AnalysisRecord(String fileName) {
        this.timestamp = LocalDateTime.now();
        this.fileName = fileName;
        this.complexityMetrics = new HashMap<>();
        this.totalIssues = 0;
        this.totalErrors = 0;
        this.totalSuggestions = 0;
    }
    
    // Getters and setters
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
    
    public String getFileName() { return fileName; }
    public void setFileName(String fileName) { this.fileName = fileName; }
    
    public Map<String, Integer> getComplexityMetrics() { return complexityMetrics; }
    public void setComplexityMetrics(Map<String, Integer> complexityMetrics) { this.complexityMetrics = complexityMetrics; }
    
    public int getTotalIssues() { return totalIssues; }
    public void setTotalIssues(int totalIssues) { this.totalIssues = totalIssues; }
    
    public int getTotalErrors() { return totalErrors; }
    public void setTotalErrors(int totalErrors) { this.totalErrors = totalErrors; }
    
    public int getTotalSuggestions() { return totalSuggestions; }
    public void setTotalSuggestions(int totalSuggestions) { this.totalSuggestions = totalSuggestions; }
    
    public void addComplexityMetric(String methodName, int complexity) {
        complexityMetrics.put(methodName, complexity);
    }
    
    @Override
    public String toString() {
        return String.format("AnalysisRecord{timestamp=%s, fileName='%s', totalIssues=%d, totalErrors=%d, totalSuggestions=%d, complexityMetrics=%s}",
                timestamp, fileName, totalIssues, totalErrors, totalSuggestions, complexityMetrics);
    }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/model/CodeAnalysisResult.java">
package com.project.codereviewer.model;

import java.util.ArrayList;
import java.util.List;

public class CodeAnalysisResult {
    private List<CodeIssue> errors = new ArrayList<>();
    private List<CodeIssue> suggestions = new ArrayList<>();

    public List<CodeIssue> getErrors() { return errors; }
    public void setErrors(List<CodeIssue> errors) { this.errors = errors; }
    public List<CodeIssue> getSuggestions() { return suggestions; }
    public void setSuggestions(List<CodeIssue> suggestions) { this.suggestions = suggestions; }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/model/CodeIssue.java">
package com.project.codereviewer.model;

import java.util.ArrayList;
import java.util.List;

public class CodeIssue {
    public enum Type { ERROR, SUGGESTION }
    private int lineNumber;
    private String message;
    private Type type;
    private String severity; // e.g., "warning", "critical"
    private String filePath;
    private List<QuickFix> quickFixes;
    private String sourceCode;
    private String lineContent;

    public CodeIssue(int lineNumber, String message, Type type, String severity) {
        this.lineNumber = lineNumber;
        this.message = message;
        this.type = type;
        this.severity = severity;
        this.quickFixes = new ArrayList<>();
    }

    public int getLineNumber() { return lineNumber; }
    public String getMessage() { return message; }
    public Type getType() { return type; }
    public String getSeverity() { return severity; }
    public String getFilePath() { return filePath; }
    public void setFilePath(String filePath) { this.filePath = filePath; }
    public List<QuickFix> getQuickFixes() { return quickFixes; }
    public void addQuickFix(QuickFix fix) { this.quickFixes.add(fix); }

    public String getSourceCode() { return sourceCode; }
    public void setSourceCode(String sourceCode) { this.sourceCode = sourceCode; }
    public String getLineContent() { return lineContent; }
    public void setLineContent(String lineContent) { this.lineContent = lineContent; }
    
    public boolean hasQuickFixes() {
        return quickFixes != null && !quickFixes.isEmpty();
    }

    public List<QuickFix> getAvailableFixes() {
        return quickFixes;
    }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/model/CommonQuickFixes.java">
package com.project.codereviewer.model;

import java.util.function.Consumer;
import java.util.regex.Pattern;
import java.util.List;
import java.util.ArrayList;
import java.util.logging.Logger;
import java.util.logging.Level;

/**
 * Provides implementations of common quick fixes for Java code issues.
 * Each fix implementation follows these principles:
 * 1. Validates input before making changes
 * 2. Preserves code formatting and structure
 * 3. Handles edge cases gracefully
 * 4. Provides clear feedback on success/failure
 */
public class CommonQuickFixes {
    private static final Logger logger = Logger.getLogger(CommonQuickFixes.class.getName());
    
    // Common patterns for code analysis
    private static final Pattern IMPORT_PATTERN = Pattern.compile("^\\s*import\\s+([\\w\\.]+)\\s*;\\s*$");
    private static final Pattern METHOD_PATTERN = Pattern.compile("^\\s*(public|private|protected)?(\\s+static)?\\s+[\\w<>\\[\\]]+\\s+\\w+\\s*\\([^)]*\\)\\s*\\{?");
    
    /**
     * Creates a quick fix for removing unused imports.
     * This fix will:
     * 1. Validate that the line contains a proper import statement
     * 2. Remove only the specific unused import
     * 3. Preserve any comments and formatting
     */
    public static QuickFix unusedImportFix() {
        return new QuickFix() {
            @Override
            public String getTitle() {
                return "Remove Unused Import";
            }

            @Override
            public String getDescription() {
                return "Removes the unused import statement from the code.";
            }

            @Override
            public boolean canFix(CodeIssue issue) {
                try {
                    if (issue == null) {
                        logger.warning("Cannot fix: issue is null");
                        return false;
                    }
                    if (issue.getSourceCode() == null) {
                        logger.warning("Cannot fix: source code is null");
                        return false;
                    }
                    if (!issue.getMessage().toLowerCase().contains("unused import")) {
                        logger.fine("Not an unused import issue");
                        return false;
                    }
                    if (!IMPORT_PATTERN.matcher(issue.getLineContent()).matches()) {
                        logger.warning("Line does not match import pattern: " + issue.getLineContent());
                        return false;
                    }
                    return true;
                } catch (Exception e) {
                    logger.log(Level.WARNING, "Error in canFix", e);
                    return false;
                }
            }

            @Override
            public boolean apply(CodeIssue issue, Consumer<String> codeUpdater, QuickFixHistory history) {
                try {
                    logger.fine("Attempting to apply unused import fix");
                    String code = issue.getSourceCode();
                    if (code == null) {
                        logger.warning("Source code is null");
                        return false;
                    }

                    String[] lines = code.split("\n");
                    if (issue.getLineNumber() <= 0 || issue.getLineNumber() > lines.length) {
                        return false;
                    }

                    String importLine = lines[issue.getLineNumber() - 1];
                    // Verify this is actually an import statement
                    if (!IMPORT_PATTERN.matcher(importLine).matches()) {
                        return false;
                    }

                    StringBuilder newCode = new StringBuilder();
                    boolean preserveNextLineBreak = false;
                    
                    for (int i = 0; i < lines.length; i++) {
                        if (i + 1 == issue.getLineNumber()) {
                            // Skip the unused import line
                            // If this line is between other imports, we'll preserve formatting
                            boolean prevLineIsImport = i > 0 && IMPORT_PATTERN.matcher(lines[i - 1]).matches();
                            boolean nextLineIsImport = i < lines.length - 1 && IMPORT_PATTERN.matcher(lines[i + 1]).matches();
                            preserveNextLineBreak = prevLineIsImport && nextLineIsImport;
                            continue;
                        }
                        
                        newCode.append(lines[i]);
                        if (i < lines.length - 1 || preserveNextLineBreak) {
                            newCode.append("\n");
                        }
                    }
                    
                    String result = newCode.toString();
                    // Remove any double blank lines that might have been created
                    result = result.replaceAll("\n{3,}", "\n\n");
                    
                    if (history != null) {
                        history.recordChange(code, result, "Remove unused import: " + importLine.trim());
                    } else {
                        codeUpdater.accept(result);
                    }
                    return true;
                } catch (Exception e) {
                    logger.log(Level.SEVERE, "Error applying unused import fix", e);
                    return false;
                }
            }
        };
    }

    /**
     * Creates a quick fix for extracting magic numbers into constants.
     */
    public static QuickFix magicNumberFix() {
        return new QuickFix() {
            private final Pattern numberPattern = Pattern.compile("\\b\\d+(\\.\\d+)?\\b");

            @Override
            public String getTitle() {
                return "Extract Magic Number to Constant";
            }

            @Override
            public String getDescription() {
                return "Extracts the magic number into a named constant at class level.";
            }

            @Override
            public boolean canFix(CodeIssue issue) {
                return issue.getMessage().toLowerCase().contains("magic number") &&
                       numberPattern.matcher(issue.getLineContent()).find();
            }

            @Override
            public boolean apply(CodeIssue issue, Consumer<String> codeUpdater, QuickFixHistory history) {
                String code = issue.getSourceCode();
                if (code == null) return false;

                String[] lines = code.split("\n");
                String lineWithNumber = lines[issue.getLineNumber() - 1];
                
                // Find the magic number in the line
                java.util.regex.Matcher matcher = numberPattern.matcher(lineWithNumber);
                if (!matcher.find()) return false;
                
                String number = matcher.group();
                String constantName = generateConstantName(number, lineWithNumber);
                
                // Create the constant declaration
                StringBuilder newCode = new StringBuilder();
                boolean addedConstant = false;
                
                // Find the class declaration and add constant after it
                for (int i = 0; i < lines.length; i++) {
                    newCode.append(lines[i]).append("\n");
                    if (!addedConstant && lines[i].contains("class")) {
                        newCode.append("    private static final ")
                              .append(number.contains(".") ? "double" : "int")
                              .append(" ").append(constantName)
                              .append(" = ").append(number).append(";\n\n");
                        addedConstant = true;
                    }
                }
                
                // Replace the magic number with the constant
                String updatedLine = lineWithNumber.replace(number, constantName);
                String result = newCode.toString().replace(lineWithNumber, updatedLine);

                if (history != null) {
                    history.recordChange(code, result, "Extract magic number " + number + " to constant " + constantName);
                } else {
                    codeUpdater.accept(result);
                }
                return true;
            }
            
            private String generateConstantName(String number, String context) {
                // Try to generate a meaningful name based on the context
                String[] words = context.toLowerCase().split("[^a-zA-Z]+");
                StringBuilder name = new StringBuilder();
                
                for (String word : words) {
                    if (!word.isEmpty() && !word.equals("final") && !word.equals("new")) {
                        name.append(word.substring(0, 1).toUpperCase())
                            .append(word.substring(1));
                    }
                }
                
                return name.append("Value").toString().toUpperCase();
            }
        };
    }

    /**
     * Creates a quick fix for splitting long methods.
     */
    public static QuickFix longMethodFix() {
        return new QuickFix() {
            @Override
            public String getTitle() {
                return "Split Method";
            }

            @Override
            public String getDescription() {
                return "Suggests a split point for the long method based on logical blocks.";
            }

            @Override
            public boolean canFix(CodeIssue issue) {
                return issue.getMessage().toLowerCase().contains("method is too long");
            }

            @Override
            public boolean apply(CodeIssue issue, Consumer<String> codeUpdater, QuickFixHistory history) {
                String code = issue.getSourceCode();
                if (code == null) return false;

                String[] lines = code.split("\n");
                int methodStart = -1;
                int methodEnd = -1;
                int bracketCount = 0;
                boolean inMethod = false;

                // Find the method boundaries
                for (int i = 0; i < lines.length; i++) {
                    String line = lines[i].trim();
                    if (!inMethod && METHOD_PATTERN.matcher(lines[i]).matches() && i + 1 == issue.getLineNumber()) {
                        methodStart = i;
                        inMethod = true;
                        bracketCount++;
                        continue;
                    }
                    if (inMethod) {
                        bracketCount += countChar(line, '{');
                        bracketCount -= countChar(line, '}');
                        if (bracketCount == 0) {
                            methodEnd = i;
                            break;
                        }
                    }
                }

                if (methodStart == -1 || methodEnd == -1) return false;

                // Analyze the method and find logical splitting points
                StringBuilder newCode = new StringBuilder();
                LogicalBlockAnalyzer analyzer = new LogicalBlockAnalyzer();
                
                // Add comments for each suggested split
                for (int i = 0; i < lines.length; i++) {
                    if (i == methodStart) {
                        // Add refactoring suggestions as comments
                        newCode.append("    // TODO: Consider refactoring this method into smaller methods:\n");
                        for (String suggestion : analyzer.analyzeLongMethod(lines, methodStart, methodEnd)) {
                            newCode.append("    // - ").append(suggestion).append("\n");
                        }
                        newCode.append("\n");
                    }
                    newCode.append(lines[i]).append("\n");
                }

                String result = newCode.toString();
                if (history != null) {
                    history.recordChange(code, result, "Add method splitting suggestions to long method");
                } else {
                    codeUpdater.accept(result);
                }
                return true;
            }

            private int countChar(String str, char ch) {
                return (int) str.chars().filter(c -> c == ch).count();
            }
        };
    }

    /**
     * Helper class to analyze method structure and suggest logical splitting points
     */
    private static class LogicalBlockAnalyzer {
        private static final Pattern LOOP_PATTERN = Pattern.compile("^\\s*(for|while|do)\\b");
        private static final Pattern IF_PATTERN = Pattern.compile("^\\s*(if|else|else\\s+if)\\b");
        private static final Pattern TRY_PATTERN = Pattern.compile("^\\s*(try|catch|finally)\\b");

        public List<String> analyzeLongMethod(String[] lines, int start, int end) {
            List<String> suggestions = new ArrayList<>();
            List<CodeBlock> blocks = identifyLogicalBlocks(lines, start, end);
            
            // Analyze blocks and generate suggestions
            for (CodeBlock block : blocks) {
                if (block.complexity > 2 || block.lineCount > 10) {
                    String name = generateMethodName(block);
                    suggestions.add("Extract " + block.type + " block into method '" + name + 
                                 "' (lines " + block.startLine + "-" + block.endLine + ")");
                }
            }
            
            return suggestions;
        }

        private List<CodeBlock> identifyLogicalBlocks(String[] lines, int start, int end) {
            List<CodeBlock> blocks = new ArrayList<>();
            CodeBlock currentBlock = null;

            for (int i = start; i <= end; i++) {
                String line = lines[i].trim();
                
                // Check for start of new logical block
                if (LOOP_PATTERN.matcher(line).find()) {
                    currentBlock = new CodeBlock("loop", i);
                } else if (IF_PATTERN.matcher(line).find()) {
                    currentBlock = new CodeBlock("conditional", i);
                } else if (TRY_PATTERN.matcher(line).find()) {
                    currentBlock = new CodeBlock("error handling", i);
                } else if (line.contains("private") || line.contains("public") || line.contains("protected")) {
                    currentBlock = new CodeBlock("method", i);
                }

                // Update block info
                if (currentBlock != null) {
                    currentBlock.lineCount++;
                    if (line.contains("if") || line.contains("for") || line.contains("while") || 
                        line.contains("catch") || line.contains("case")) {
                        currentBlock.complexity++;
                    }

                    // Check for block end
                    if (line.contains("}") && currentBlock.braceCount == 0) {
                        currentBlock.endLine = i;
                        blocks.add(currentBlock);
                        currentBlock = null;
                    } else {
                        currentBlock.braceCount += countBraces(line);
                    }
                }
            }

            return blocks;
        }

        private String generateMethodName(CodeBlock block) {
            String prefix = switch (block.type) {
                case "loop" -> "process";
                case "conditional" -> "handle";
                case "error handling" -> "handle";
                default -> "execute";
            };
            return prefix + "Block" + block.startLine;
        }

        private int countBraces(String line) {
            return (int) line.chars().filter(ch -> ch == '{').count() -
                   (int) line.chars().filter(ch -> ch == '}').count();
        }

        private static class CodeBlock {
            String type;
            int startLine;
            int endLine;
            int lineCount;
            int complexity;
            int braceCount;

            CodeBlock(String type, int startLine) {
                this.type = type;
                this.startLine = startLine;
                this.lineCount = 0;
                this.complexity = 0;
                this.braceCount = 0;
            }
        }
    }

    /**
     * Creates a quick fix for empty catch blocks.
     */
    public static QuickFix emptyCatchBlockFix() {
        return new QuickFix() {
            private static final Pattern CATCH_PATTERN = Pattern.compile("^\\s*catch\\s*\\([^)]+\\)\\s*\\{\\s*}\\s*$");
            
            @Override
            public String getTitle() {
                return "Fix Empty Catch Block";
            }

            @Override
            public String getDescription() {
                return "Adds appropriate error logging to empty catch block.";
            }

            @Override
            public boolean canFix(CodeIssue issue) {
                return issue.getMessage().toLowerCase().contains("empty catch block") &&
                       issue.getLineContent() != null &&
                       CATCH_PATTERN.matcher(issue.getLineContent()).matches();
            }

            @Override
            public boolean apply(CodeIssue issue, Consumer<String> codeUpdater, QuickFixHistory history) {
                String code = issue.getSourceCode();
                if (code == null) return false;

                String[] lines = code.split("\n");
                if (issue.getLineNumber() <= 0 || issue.getLineNumber() > lines.length) {
                    return false;
                }

                // Extract exception variable name from catch declaration
                String catchLine = lines[issue.getLineNumber() - 1];
                String exceptionVar = extractExceptionVar(catchLine);
                if (exceptionVar == null) return false;

                StringBuilder newCode = new StringBuilder();
                for (int i = 0; i < lines.length; i++) {
                    newCode.append(lines[i]);
                    if (i + 1 == issue.getLineNumber()) {
                        // Replace empty catch block with proper logging
                        newCode.append("\n            logger.warning(\"Exception caught: \" + ")
                              .append(exceptionVar).append(".getMessage());")
                              .append("\n            logger.fine(\"Stack trace:\", ")
                              .append(exceptionVar).append(");");
                    }
                    newCode.append("\n");
                }

                String result = newCode.toString();
                if (history != null) {
                    history.recordChange(code, result, "Add logging to empty catch block");
                } else {
                    codeUpdater.accept(result);
                }
                return true;
            }

            private String extractExceptionVar(String catchLine) {
                int start = catchLine.indexOf('(');
                int end = catchLine.indexOf(')');
                if (start == -1 || end == -1) return null;
                
                String[] parts = catchLine.substring(start + 1, end).trim().split("\\s+");
                return parts.length >= 2 ? parts[1] : null;
            }
        };
    }

    /**
     * Creates a quick fix for poorly named variables.
     */
    public static QuickFix poorVariableNameFix() {
        return new QuickFix() {
            private static final Pattern VAR_PATTERN = Pattern.compile("\\b(var|[a-zA-Z_$][a-zA-Z0-9_$]*)\\s+([a-z][a-zA-Z0-9_$]*)\\s*[=;]");
            private static final List<String> POOR_NAMES = List.of("temp", "tmp", "var", "x", "y", "z", "a", "b", "c", "foo", "bar");
            
            @Override
            public String getTitle() {
                return "Improve Variable Name";
            }

            @Override
            public String getDescription() {
                return "Suggests a more descriptive name for the variable based on its usage and context.";
            }

            @Override
            public boolean canFix(CodeIssue issue) {
                if (issue.getLineContent() == null) return false;
                
                java.util.regex.Matcher matcher = VAR_PATTERN.matcher(issue.getLineContent());
                return issue.getMessage().toLowerCase().contains("variable name") &&
                       matcher.find() &&
                       POOR_NAMES.contains(matcher.group(2).toLowerCase());
            }

            @Override
            public boolean apply(CodeIssue issue, Consumer<String> codeUpdater, QuickFixHistory history) {
                String code = issue.getSourceCode();
                if (code == null) return false;

                String[] lines = code.split("\n");
                String line = lines[issue.getLineNumber() - 1];
                
                java.util.regex.Matcher matcher = VAR_PATTERN.matcher(line);
                if (!matcher.find()) return false;

                String oldName = matcher.group(2);
                String type = matcher.group(1);
                String newName = suggestVariableName(type, line, oldName);

                StringBuilder newCode = new StringBuilder();
                boolean addedSuggestion = false;
                
                for (int i = 0; i < lines.length; i++) {
                    if (i + 1 == issue.getLineNumber()) {
                        // Add suggestion as comment
                        newCode.append("    // TODO: Consider renaming '")
                              .append(oldName).append("' to '")
                              .append(newName).append("' for better clarity\n");
                        addedSuggestion = true;
                    }
                    newCode.append(lines[i]).append("\n");
                }

                if (!addedSuggestion) return false;

                String result = newCode.toString();
                if (history != null) {
                    history.recordChange(code, result, "Add variable rename suggestion from '" + oldName + "' to '" + newName + "'");
                } else {
                    codeUpdater.accept(result);
                }
                return true;
            }

            private String suggestVariableName(String type, String context, String oldName) {
                // Try to infer meaning from assignment
                String[] parts = context.split("[=;]");
                if (parts.length > 1) {
                    String rhs = parts[1].trim();
                    if (rhs.contains("new ")) {
                        String className = rhs.substring(rhs.indexOf("new ") + 4).split("[(<\\s]")[0];
                        return toLowerCamelCase(className);
                    }
                    if (rhs.contains(".")) {
                        String methodName = rhs.substring(rhs.lastIndexOf(".") + 1).split("[(<\\s]")[0];
                        return toLowerCamelCase(methodName + "Result");
                    }
                }

                // Use type information
                if (type.equals("String")) return "text";
                if (type.equals("int") || type.equals("long")) return "count";
                if (type.equals("boolean")) return "isValid";
                if (type.contains("List")) return "items";
                if (type.contains("Map")) return "mappings";

                // Fallback to generic but descriptive name
                return "processed" + toTitleCase(oldName);
            }

            private String toLowerCamelCase(String s) {
                if (s == null || s.isEmpty()) return "value";
                return Character.toLowerCase(s.charAt(0)) + s.substring(1);
            }

            private String toTitleCase(String s) {
                if (s == null || s.isEmpty()) return "Value";
                return Character.toUpperCase(s.charAt(0)) + s.substring(1);
            }
        };
    }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/model/QuickFix.java">
package com.project.codereviewer.model;

import java.util.function.Consumer;

/**
 * Represents a quick fix that can be applied to code issues.
 * Quick fixes are automated code modifications that can resolve common issues.
 */
public interface QuickFix {
    /**
     * Gets the title of the quick fix to display in the UI.
     * @return A short, descriptive title of what the fix does
     */
    String getTitle();

    /**
     * Gets a detailed description of what the fix will do.
     * @return A description of the changes this fix will make
     */
    String getDescription();

    /**
     * Checks if this quick fix can be applied to the given issue.
     * @param issue The code issue to check
     * @return true if this fix can handle the given issue
     */
    boolean canFix(CodeIssue issue);

    /**
     * Applies the fix to the code.
     * @param issue The issue to fix
     * @param codeUpdater Consumer that receives the updated code
     * @param history Optional history tracker for undo/redo support
     * @return true if the fix was successfully applied
     */
    boolean apply(CodeIssue issue, Consumer<String> codeUpdater, QuickFixHistory history);
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/model/QuickFixHistory.java">
package com.project.codereviewer.model;

import java.util.Stack;
import java.util.function.Consumer;
import java.util.logging.Logger;
import java.util.logging.Level;

/**
 * Manages the history of applied quick fixes, enabling undo/redo functionality.
 */
public class QuickFixHistory {
    private static final Logger logger = Logger.getLogger(QuickFixHistory.class.getName());
    
    private final Stack<CodeChange> undoStack = new Stack<>();
    private final Stack<CodeChange> redoStack = new Stack<>();
    private final Consumer<String> codeUpdater;
    
    public QuickFixHistory(Consumer<String> codeUpdater) {
        this.codeUpdater = codeUpdater;
    }
    
    /**
     * Records a code change and applies it.
     * @param oldCode The previous state of the code
     * @param newCode The new state of the code
     * @param description Description of the change
     */
    public void recordChange(String oldCode, String newCode, String description) {
        try {
            CodeChange change = new CodeChange(oldCode, newCode, description);
            undoStack.push(change);
            redoStack.clear(); // Clear redo stack when new change is made
            codeUpdater.accept(newCode);
            logger.fine("Recorded change: " + description);
        } catch (Exception e) {
            logger.log(Level.WARNING, "Failed to record change", e);
        }
    }
    
    /**
     * Undoes the last quick fix.
     * @return true if undo was successful
     */
    public boolean undo() {
        if (undoStack.isEmpty()) {
            logger.fine("No changes to undo");
            return false;
        }
        
        try {
            CodeChange change = undoStack.pop();
            redoStack.push(change);
            codeUpdater.accept(change.oldCode);
            logger.fine("Undid change: " + change.description);
            return true;
        } catch (Exception e) {
            logger.log(Level.WARNING, "Failed to undo change", e);
            return false;
        }
    }
    
    /**
     * Redoes the last undone quick fix.
     * @return true if redo was successful
     */
    public boolean redo() {
        if (redoStack.isEmpty()) {
            logger.fine("No changes to redo");
            return false;
        }
        
        try {
            CodeChange change = redoStack.pop();
            undoStack.push(change);
            codeUpdater.accept(change.newCode);
            logger.fine("Redid change: " + change.description);
            return true;
        } catch (Exception e) {
            logger.log(Level.WARNING, "Failed to redo change", e);
            return false;
        }
    }
    
    /**
     * Checks if there are changes that can be undone.
     */
    public boolean canUndo() {
        return !undoStack.isEmpty();
    }
    
    /**
     * Checks if there are changes that can be redone.
     */
    public boolean canRedo() {
        return !redoStack.isEmpty();
    }
    
    /**
     * Gets the description of the next change that would be undone.
     */
    public String getUndoDescription() {
        return !undoStack.isEmpty() ? undoStack.peek().description : null;
    }
    
    /**
     * Gets the description of the next change that would be redone.
     */
    public String getRedoDescription() {
        return !redoStack.isEmpty() ? redoStack.peek().description : null;
    }
    
    private static class CodeChange {
        final String oldCode;
        final String newCode;
        final String description;
        
        CodeChange(String oldCode, String newCode, String description) {
            this.oldCode = oldCode;
            this.newCode = newCode;
            this.description = description;
        }
    }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/repo/JavaFileRepository.java">
package com.project.codereviewer.repo;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import org.springframework.stereotype.Repository;

@Repository
public class JavaFileRepository {
    public String loadFile(File file) throws IOException {
        return Files.readString(file.toPath(), StandardCharsets.UTF_8);
    }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/security/SecurityUtils.java">
package com.project.codereviewer.security;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.logging.Logger;
import java.util.regex.Pattern;

/**
 * Security utilities for the Code Reviewer application.
 * Provides API key validation, sanitization, and secure handling.
 */
public class SecurityUtils {
    private static final Logger logger = Logger.getLogger(SecurityUtils.class.getName());
    private static final SecureRandom secureRandom = new SecureRandom();
    
    // Patterns for input validation
    private static final Pattern API_KEY_PATTERN = Pattern.compile("^[a-zA-Z0-9_-]{20,}$");
    private static final Pattern SAFE_FILENAME_PATTERN = Pattern.compile("^[a-zA-Z0-9._-]+\\.java$");
    private static final Pattern MODEL_NAME_PATTERN = Pattern.compile("^[a-zA-Z0-9/._-]+$");
    
    // Maximum allowed file size (10MB)
    private static final long MAX_FILE_SIZE = 10 * 1024 * 1024;
    
    /**
     * Validates if an API key has the expected format
     */
    public static boolean isValidApiKey(String apiKey) {
        if (apiKey == null || apiKey.trim().isEmpty()) {
            return false;
        }
        
        // Check for common placeholder values
        if ("YOUR_API_KEY_HERE".equals(apiKey) || 
            "sk-your-key-here".equals(apiKey) ||
            "replace-with-your-key".equals(apiKey)) {
            return false;
        }
        
        return API_KEY_PATTERN.matcher(apiKey.trim()).matches();
    }
    
    /**
     * Masks an API key for logging purposes
     */
    public static String maskApiKey(String apiKey) {
        if (apiKey == null || apiKey.length() < 8) {
            return "***";
        }
        
        int visibleChars = Math.min(4, apiKey.length() / 4);
        String prefix = apiKey.substring(0, visibleChars);
        String suffix = apiKey.substring(apiKey.length() - visibleChars);
        
        return prefix + "***" + suffix;
    }
    
    /**
     * Validates if a filename is safe for processing
     */
    public static boolean isSafeFilename(String filename) {
        if (filename == null || filename.trim().isEmpty()) {
            return false;
        }
        
        String normalizedName = filename.trim();
        
        // Check for path traversal attempts
        if (normalizedName.contains("..") || 
            normalizedName.contains("/") || 
            normalizedName.contains("\\")) {
            return false;
        }
        
        return SAFE_FILENAME_PATTERN.matcher(normalizedName).matches();
    }
    
    /**
     * Validates if a model name is safe
     */
    public static boolean isSafeModelName(String modelName) {
        if (modelName == null || modelName.trim().isEmpty()) {
            return false;
        }
        
        return MODEL_NAME_PATTERN.matcher(modelName.trim()).matches();
    }
    
    /**
     * Sanitizes input text for API requests
     */
    public static String sanitizeInput(String input) {
        if (input == null) {
            return "";
        }
        
        // Remove potentially dangerous characters while preserving code
        return input.replaceAll("[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]", "")
                   .trim();
    }
    
    /**
     * Validates file size
     */
    public static boolean isValidFileSize(long fileSize) {
        return fileSize > 0 && fileSize <= MAX_FILE_SIZE;
    }
    
    /**
     * Generates a secure hash for caching purposes
     */
    public static String generateCacheKey(String input) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(input.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            logger.warning("SHA-256 not available, using fallback hash");
            return String.valueOf(input.hashCode());
        }
    }
    
    /**
     * Generates a secure session ID
     */
    public static String generateSessionId() {
        byte[] randomBytes = new byte[16];
        secureRandom.nextBytes(randomBytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    }
    
    /**
     * Validates URL for OpenRouter API
     */
    public static boolean isValidApiUrl(String url) {
        if (url == null || url.trim().isEmpty()) {
            return false;
        }
        
        String normalizedUrl = url.trim().toLowerCase();
        return normalizedUrl.startsWith("https://openrouter.ai/") ||
               normalizedUrl.startsWith("https://api.openrouter.ai/");
    }
    
    /**
     * Security validation result
     */
    public static class ValidationResult {
        private final boolean valid;
        private final String message;
        
        public ValidationResult(boolean valid, String message) {
            this.valid = valid;
            this.message = message;
        }
        
        public boolean isValid() { return valid; }
        public String getMessage() { return message; }
        
        public static ValidationResult success() {
            return new ValidationResult(true, "Validation successful");
        }
        
        public static ValidationResult failure(String message) {
            return new ValidationResult(false, message);
        }
    }
    
    /**
     * Comprehensive security validation for API requests
     */
    public static ValidationResult validateApiRequest(String apiKey, String modelName, String content) {
        if (!isValidApiKey(apiKey)) {
            return ValidationResult.failure("Invalid API key format");
        }
        
        if (!isSafeModelName(modelName)) {
            return ValidationResult.failure("Invalid model name");
        }
        
        if (content == null || content.trim().isEmpty()) {
            return ValidationResult.failure("Content cannot be empty");
        }
        
        if (content.length() > MAX_FILE_SIZE) {
            return ValidationResult.failure("Content too large");
        }
        
        return ValidationResult.success();
    }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/service/AISuggestionService.java">
package com.project.codereviewer.service;

import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Flow;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.json.JSONArray;
import org.json.JSONObject;
import org.springframework.stereotype.Service;

import com.project.codereviewer.config.AppConfig;

/**
 * Service for interacting with AI APIs to get code suggestions.
 * Uses OpenRouter to access various open-source models like Mistral or LLaMA 3.
 */
@Service
public class AISuggestionService {
    private static final String API_URL = "https://openrouter.ai/api/v1/chat/completions";
    private static final Duration TIMEOUT = Duration.ofSeconds(120); // Increased timeout to 120 seconds
    private static final String DEFAULT_MODEL = "mistralai/mixtral-8x7b-instruct";
    private static final String SYSTEM_PROMPT = """
            You are an expert Java code reviewer with extensive experience in software architecture, design patterns, and performance optimization.
            Your task is to provide professional, actionable, and educational code reviews.

            FORMAT YOUR RESPONSE IN MARKDOWN WITH THE FOLLOWING STRICT STRUCTURE:
            
            ## Overall Summary
            - Brief overview of the code's purpose and architecture
            - Key strengths and areas for improvement
            - Maximum 3-4 sentences
            
            ## Critical Issues (Potential Bugs)
            - List only genuine bugs, race conditions, security vulnerabilities, or critical performance issues
            - Each issue must include:
              * Line number reference
              * Clear explanation of the potential impact
              * Specific code fix recommendation
            
            ## Suggestions for Improvement
            For each suggestion:
            ```
            [Line XX] - Component/Issue Title
            WHY: Clear explanation of why this needs improvement
            RECOMMENDATION: 
            ```java
            // Corrected code snippet
            ```
            ```
            
            ## Best Practices & Code Compliments
            - Acknowledge what was done well
            - Suggest relevant design patterns or Java best practices if applicable
            - Maximum 2-3 specific points
            
            CONSTRAINTS:
            - Focus on substantial issues, not trivial style preferences
            - Be constructive and educational in tone
            - Always provide concrete examples and explanations
            - Include code snippets for non-trivial changes
            - Reference specific line numbers for all suggestions
            - Prioritize:
              * Thread safety and concurrent operation issues
              * Resource management (memory, file handles, etc.)
              * API design and method signatures
              * Error handling and edge cases
              * Performance optimization opportunities
            """;
    
    private final HttpClient httpClient;
    private final Logger logger = Logger.getLogger(AISuggestionService.class.getName());
    
    public AISuggestionService() {
        this.httpClient = HttpClient.newBuilder()
                .version(HttpClient.Version.HTTP_2)
                .connectTimeout(TIMEOUT)
                .build();
        logger.info("AISuggestionService initialized with timeout: " + TIMEOUT.getSeconds() + " seconds");
    }
    
    /**
     * Get AI suggestions for code review in a blocking manner.
     * 
     * @param codeToReview The code to be reviewed
     * @return The AI suggestion as a String
     * @throws IOException If an error occurs during API communication
     */
    public String getCodeSuggestion(String codeToReview) throws IOException {
        logger.info("Requesting code suggestion for review");
        String apiKey = AppConfig.getOpenRouterApiKey();
        String model = AppConfig.getOpenRouterModelName(DEFAULT_MODEL);

        try {
            JSONObject requestBody = new JSONObject();
            requestBody.put("model", model);
            
            JSONArray messages = new JSONArray();
            messages.put(new JSONObject().put("role", "system").put("content", SYSTEM_PROMPT));
            messages.put(new JSONObject().put("role", "user").put("content", codeToReview));
            requestBody.put("messages", messages);
            
            // Configure streaming response
            requestBody.put("stream", false);
            
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(API_URL))
                    .header("Content-Type", "application/json")
                    .header("Authorization", "Bearer " + apiKey)
                    .header("HTTP-Referer", "https://github.com/java-code-reviewer")
                    .header("X-Title", "Java Code Reviewer")
                    .POST(HttpRequest.BodyPublishers.ofString(requestBody.toString()))
                    .build();

            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            if (response.statusCode() != 200) {
                String errorMsg = "API error: " + response.statusCode() + " - " + response.body();
                logger.severe(errorMsg);
                throw new IOException(errorMsg);
            }

            JSONObject responseBody = new JSONObject(response.body());
            String content = extractContentFromResponse(responseBody);
            logger.info("Successfully received AI suggestion");
            return content;
        } catch (InterruptedException e) {
            logger.log(Level.SEVERE, "Request interrupted", e);
            Thread.currentThread().interrupt();
            throw new IOException("Request interrupted: " + e.getMessage(), e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Failed to get AI suggestion", e);
            throw new IOException("Failed to get AI suggestion: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get AI suggestions for code review with streaming response.
     * 
     * @param codeToReview The code to be reviewed
     * @param responseConsumer Consumer that processes each chunk of the streaming response
     * @return CompletableFuture that completes when the entire stream is processed
     */
    public CompletableFuture<Void> getCodeSuggestionStreaming(String codeToReview, Consumer<String> responseConsumer) {
        CompletableFuture<Void> future = new CompletableFuture<>();
        
        // First, inform the user that we're starting the request
        responseConsumer.accept("Starting AI review request...\n\n");
        
        String apiKey;
        try {
            logger.info("Attempting to get OpenRouter API key");
            apiKey = AppConfig.getOpenRouterApiKey();
            logger.info("Successfully retrieved API key with length: " + (apiKey != null ? apiKey.length() : 0));
            
            // Quick validation of API key
            if (apiKey == null || apiKey.trim().isEmpty()) {
                throw new IOException("API key is empty or null");
            }
            if (!apiKey.startsWith("sk-")) {
                logger.warning("API key doesn't start with 'sk-', which might indicate an invalid format");
            }
        } catch (IOException e) {
            logger.severe("Failed to get API key: " + e.getMessage());
            e.printStackTrace();
            responseConsumer.accept("Error: Failed to get API key - " + e.getMessage() + "\n" +
                                   "Please check your secrets.properties file and ensure the OpenRouter API key is correctly set.");
            future.completeExceptionally(e);
            return future;
        }
        
        String model = AppConfig.getOpenRouterModelName(DEFAULT_MODEL);
        logger.info("Using model: " + model + " for streaming response");
        responseConsumer.accept("Using AI model: " + model + "\n\n");
        
        // Validate code length - large inputs can cause timeouts
        int codeLength = codeToReview != null ? codeToReview.length() : 0;
        logger.info("Code length for review: " + codeLength + " characters");
        if (codeLength > 20000) {
            logger.warning("Very large code submission (" + codeLength + " chars) may cause slow response");
            responseConsumer.accept("Note: The code submission is large (" + (codeLength/1000) + "KB), which may result in a slower response.\n\n");
        }
        
        JSONObject requestBody = new JSONObject();
        requestBody.put("model", model);
        
        JSONArray messages = new JSONArray();
        messages.put(new JSONObject().put("role", "system").put("content", SYSTEM_PROMPT));
        messages.put(new JSONObject().put("role", "user").put("content", codeToReview));
        requestBody.put("messages", messages);
        
        // Configure streaming response with max_tokens to potentially speed up response
        requestBody.put("stream", true);
        requestBody.put("max_tokens", 2000); // Limit response length to potentially speed up completion
        
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(API_URL))
                .header("Content-Type", "application/json")
                .header("Authorization", "Bearer " + apiKey)
                .header("HTTP-Referer", "https://github.com/java-code-reviewer")
                .header("X-Title", "Java Code Reviewer")
                .timeout(TIMEOUT) // Explicitly set the timeout for this request
                .POST(HttpRequest.BodyPublishers.ofString(requestBody.toString()))
                .build();
        
        logger.info("Sending API request to: " + API_URL);
        logger.info("Request headers: Content-Type=application/json, Authorization=Bearer <API_KEY>, HTTP-Referer, X-Title");
        logger.info("Request body length: " + requestBody.toString().length() + " characters");
        logger.info("Stream mode: " + requestBody.getBoolean("stream"));
        
        // Add a timeout handler to detect if the request is taking too long
        final long timeoutMillis = TIMEOUT.toMillis();
        
        // Start a timer to check for timeout
        new Thread(() -> {
            try {
                Thread.sleep(timeoutMillis / 2); // Check halfway through timeout
                if (!future.isDone()) {
                    logger.warning("Request is taking longer than expected (" + (timeoutMillis / 2000) + " seconds)");
                    responseConsumer.accept("\n[Still waiting for response...]\n");
                }
                
                Thread.sleep(timeoutMillis / 2); // Check at full timeout
                if (!future.isDone()) {
                    logger.severe("Request likely timed out after " + (timeoutMillis / 1000) + " seconds");
                    responseConsumer.accept("\n\n⚠️ Warning: Request is taking unusually long. The service may be experiencing issues.\n");
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
        
        httpClient.sendAsync(request, HttpResponse.BodyHandlers.fromLineSubscriber(new Flow.Subscriber<>() {
            private Flow.Subscription subscription;
            private final StringBuilder fullResponse = new StringBuilder();
            // Track if we've received any actual content
            private long lastContentTime = System.currentTimeMillis();
            
            @Override
            public void onSubscribe(Flow.Subscription subscription) {
                this.subscription = subscription;
                subscription.request(Long.MAX_VALUE);
            }

            @Override
            public void onNext(String line) {
                // Update the last content time whenever we receive any data
                lastContentTime = System.currentTimeMillis();
                
                if (line.isEmpty()) {
                    return;
                }
                
                if (line.equals("data: [DONE]")) {
                    logger.info("Received stream completion marker");
                    // Check if we got any content at all
                    if (fullResponse.length() == 0) {
                        logger.warning("Stream completed but no content was received");
                        responseConsumer.accept("\n\nWarning: No content was received from the AI model. This may indicate an issue with the model or API.");
                    }
                    return;
                }
                
                // Log the raw line occasionally for debugging
                if (fullResponse.length() == 0) {
                    logger.info("First response line received: " + line);
                }
                
                if (line.startsWith("data: ")) {
                    String jsonData = line.substring(6);
                    
                    // Handle error responses
                    if (jsonData.contains("error") && !jsonData.contains("delta")) {
                        try {
                            JSONObject errorObj = new JSONObject(jsonData);
                            if (errorObj.has("error")) {
                                String errorMessage = errorObj.getJSONObject("error").optString("message", "Unknown error");
                                logger.severe("API error response: " + errorMessage);
                                responseConsumer.accept("\n\nAPI Error: " + errorMessage);
                                future.completeExceptionally(new IOException("API error: " + errorMessage));
                                subscription.cancel();
                                return;
                            }
                        } catch (Exception e) {
                            logger.warning("Could not parse potential error response: " + jsonData);
                        }
                    }
                    
                    try {
                        JSONObject chunk = new JSONObject(jsonData);
                        if (chunk.has("choices") && !chunk.getJSONArray("choices").isEmpty()) {
                            JSONObject choice = chunk.getJSONArray("choices").getJSONObject(0);
                            
                            // Check for finish_reason which might indicate why the model stopped
                            if (choice.has("finish_reason") && !choice.isNull("finish_reason")) {
                                String reason = choice.getString("finish_reason");
                                logger.info("Model finished generation with reason: " + reason);
                                if (!"stop".equals(reason)) {
                                    responseConsumer.accept("\n\nNote: Model stopped generating with reason: " + reason);
                                }
                            }
                            
                            if (choice.has("delta") && choice.getJSONObject("delta").has("content")) {
                                String contentChunk = choice.getJSONObject("delta").getString("content");
                                responseConsumer.accept(contentChunk);
                                fullResponse.append(contentChunk);
                                // Mark that we've received actual content
                                if (fullResponse.length() == contentChunk.length()) {
                                    logger.info("Received first content chunk");
                                }
                            }
                        } else {
                            // If we have a response without choices, log it for debugging
                            logger.fine("Received response chunk without content: " + jsonData);
                        }
                    } catch (Exception e) {
                        logger.log(Level.SEVERE, "Error parsing streaming response: " + jsonData, e);
                        responseConsumer.accept("\n\nError parsing response: " + e.getMessage());
                        future.completeExceptionally(new IOException("Error parsing streaming response: " + e.getMessage(), e));
                        subscription.cancel();
                    }
                } else {
                    // Log unexpected response format
                    logger.warning("Received unexpected response format: " + line);
                }
            }

            @Override
            public void onError(Throwable throwable) {
                logger.log(Level.SEVERE, "Error in streaming response", throwable);
                responseConsumer.accept("\n\n⚠️ Error: The AI service encountered an error: " + throwable.getMessage() + 
                                      "\nPlease try again later or check your API key and internet connection.");
                future.completeExceptionally(throwable);
            }

            @Override
            public void onComplete() {
                logger.info("Streaming response completed successfully");
                responseConsumer.accept("\n\n(Review complete)");
                future.complete(null);
            }
        })).exceptionally(ex -> {
            logger.log(Level.SEVERE, "Exception during HTTP request", ex);
            responseConsumer.accept("\n\n⚠️ Network Error: Failed to connect to AI service: " + ex.getMessage() + 
                                  "\nPossible causes: Internet connectivity issue, API service unavailable, or timeout.");
            future.completeExceptionally(ex);
            return null;
        });
        
        return future;
    }
    
    /**
     * Extract content from the API response.
     */
    private String extractContentFromResponse(JSONObject response) {
        if (response.has("choices") && !response.getJSONArray("choices").isEmpty()) {
            JSONObject choice = response.getJSONArray("choices").getJSONObject(0);
            if (choice.has("message") && choice.getJSONObject("message").has("content")) {
                return choice.getJSONObject("message").getString("content");
            }
        }
        return "No suggestion available.";
    }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/service/CodeAnalysisService.java">
package com.project.codereviewer.service;

import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.Statement;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.FieldAccessExpr;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.ObjectCreationExpr;
import com.github.javaparser.ast.expr.IntegerLiteralExpr;
import com.github.javaparser.ast.expr.DoubleLiteralExpr;
import com.github.javaparser.ast.expr.BinaryExpr;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.body.Parameter;
import com.project.codereviewer.model.CodeAnalysisResult;
import com.project.codereviewer.model.CodeIssue;
import org.springframework.stereotype.Service;
import java.util.Optional;
import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Logger;

@Service
public class CodeAnalysisService {
    private static final Logger logger = Logger.getLogger(CodeAnalysisService.class.getName());
    
    private static final List<String> POOR_VARIABLE_NAMES = Arrays.asList(
        "temp", "tmp", "var", "x", "y", "z", "a", "b", "c", "foo", "bar",
        "data", "obj", "thing", "stuff", "item", "val", "value"
    );

    private boolean isPoorVariableName(String name) {
        if (name == null || name.length() < 2) return true;
        if (POOR_VARIABLE_NAMES.contains(name.toLowerCase())) return true;
        // Check for single letter followed by a number (e.g., a1, x2)
        if (name.length() == 2 && Character.isLetter(name.charAt(0)) && Character.isDigit(name.charAt(1))) return true;
        return false;
    }

    public CodeAnalysisResult analyze(String code) {
        if (code == null) {
            throw new IllegalArgumentException("Code cannot be null");
        }
        
        CodeAnalysisResult result = new CodeAnalysisResult();
        try {
            JavaParser parser = new JavaParser();
            var parseResult = parser.parse(code);
            if (parseResult.isSuccessful() && parseResult.getResult().isPresent()) {
                CompilationUnit cu = parseResult.getResult().get();
                for (MethodDeclaration method : cu.findAll(MethodDeclaration.class)) {
                    String methodName = method.getNameAsString();
                    int startLine = method.getBegin().map(b -> b.line).orElse(-1);
                    int length = method.getEnd().map(e -> e.line).orElse(-1) - startLine + 1;
                    int maxNesting = getMaxNestingEnhanced(method.getBody());
                    logger.fine("[DEBUG] Method: " + methodName + ", startLine: " + startLine + ", length: " + length + ", maxNesting: " + maxNesting);

                    if (length > 10) { // Lowered threshold
                        logger.fine("[DEBUG] Long method detected: " + methodName);
                        result.getErrors().add(new CodeIssue(startLine, methodName + ": Long method (" + length + " lines)", CodeIssue.Type.ERROR, "warning"));
                        result.getSuggestions().add(new CodeIssue(startLine, methodName + ": Consider refactoring into smaller methods for maintainability.", CodeIssue.Type.SUGGESTION, "info"));
                    }
                    if (maxNesting > 2) { // Lowered threshold
                        logger.fine("[DEBUG] Deep nesting detected: " + methodName);
                        result.getErrors().add(new CodeIssue(startLine, methodName + ": Deep nesting (" + maxNesting + ")", CodeIssue.Type.ERROR, "warning"));
                        result.getSuggestions().add(new CodeIssue(startLine, methodName + ": Try to reduce nesting by extracting logic or using guard clauses.", CodeIssue.Type.SUGGESTION, "info"));
                    }
                    if (method.getBody().isPresent() && method.getBody().get().isEmpty()) {
                        logger.fine("[DEBUG] Empty method detected: " + methodName);
                        result.getErrors().add(new CodeIssue(startLine, methodName + ": Empty method body", CodeIssue.Type.ERROR, "warning"));
                        result.getSuggestions().add(new CodeIssue(startLine, methodName + ": Remove or implement this method.", CodeIssue.Type.SUGGESTION, "info"));
                    }
                    
                    // Calculate cyclomatic complexity
                    AtomicInteger complexity = new AtomicInteger(1); // Base complexity
                    CyclomaticComplexityVisitor complexityVisitor = new CyclomaticComplexityVisitor();
                    if (method.getBody().isPresent()) {
                        method.getBody().get().accept(complexityVisitor, complexity);
                    }
                    int finalComplexity = complexity.get();
                    
                    if (finalComplexity > 5) { // Lowered threshold for better detection
                        result.getErrors().add(new CodeIssue(startLine, methodName + ": High cyclomatic complexity (" + finalComplexity + ")", CodeIssue.Type.ERROR, "warning"));
                        result.getSuggestions().add(new CodeIssue(startLine, methodName + ": Consider refactoring to reduce complexity. Current complexity: " + finalComplexity, CodeIssue.Type.SUGGESTION, "info"));
                    } else {
                        result.getSuggestions().add(new CodeIssue(startLine, methodName + ": Cyclomatic complexity: " + finalComplexity, CodeIssue.Type.SUGGESTION, "info"));
                    }

                    // Check for empty catch blocks
                    method.findAll(com.github.javaparser.ast.stmt.CatchClause.class).forEach(catchClause -> {
                        if (catchClause.getBody().getStatements().isEmpty()) {
                            int catchLine = catchClause.getBegin().get().line;
                            result.getErrors().add(new CodeIssue(catchLine, 
                                "Empty catch block found in " + methodName, 
                                CodeIssue.Type.ERROR, "warning"));
                        }
                    });

                    // Check for poor variable names
                    method.findAll(com.github.javaparser.ast.expr.VariableDeclarationExpr.class).forEach(varDecl -> {
                        varDecl.getVariables().forEach(var -> {
                            String varName = var.getNameAsString();
                            if (isPoorVariableName(varName)) {
                                int varLine = var.getBegin().get().line;
                                result.getErrors().add(new CodeIssue(varLine,
                                    "Poor variable name found: '" + varName + "'",
                                    CodeIssue.Type.ERROR, "warning"));
                            }
                        });
                    });
                }
                // Enhanced unused import detection using AST
                Set<String> usedTypes = new HashSet<>();
                TypeUsageVisitor typeVisitor = new TypeUsageVisitor();
                cu.accept(typeVisitor, usedTypes);
                
                long unusedImports = cu.getImports().stream()
                    .filter(imp -> {
                        String importName = imp.getNameAsString();
                        // Check if the imported type is actually used
                        return !usedTypes.contains(importName) && 
                               !usedTypes.contains(importName.substring(importName.lastIndexOf('.') + 1));
                    })
                    .count();
                logger.fine("[DEBUG] Unused imports count: " + unusedImports);
                if (unusedImports > 0) {
                    result.getErrors().add(new CodeIssue(1, "Unused imports detected: " + unusedImports, CodeIssue.Type.ERROR, "info"));
                    result.getSuggestions().add(new CodeIssue(1, "Remove unused imports to keep code clean.", CodeIssue.Type.SUGGESTION, "info"));
                }
                
                // Magic number detection
                MagicNumberVisitor magicNumberVisitor = new MagicNumberVisitor();
                cu.accept(magicNumberVisitor, result);
            } else {
                result.getErrors().add(new CodeIssue(0, "Error parsing code.", CodeIssue.Type.ERROR, "critical"));
            }
        } catch (Exception e) {
            result.getErrors().add(new CodeIssue(0, "Error analyzing code: " + e.getMessage(), CodeIssue.Type.ERROR, "critical"));
        }
        // Debug output
        logger.fine("[DEBUG] Detected errors:");
        for (CodeIssue err : result.getErrors()) {
            logger.fine("  - " + err.getMessage());
        }
        logger.fine("[DEBUG] Detected suggestions:");
        for (CodeIssue sug : result.getSuggestions()) {
            logger.fine("  - " + sug.getMessage());
        }
        return result;
    }

    private int getMaxNesting(Optional<BlockStmt> bodyOpt) {
        if (bodyOpt.isEmpty()) return 0;
        return getMaxNesting(bodyOpt.get(), 0);
    }

    private int getMaxNesting(BlockStmt block, int currentDepth) {
        int max = currentDepth;
        for (Statement stmt : block.getStatements()) {
            int childMax = max;
            if (stmt.isBlockStmt()) {
                childMax = getMaxNesting(stmt.asBlockStmt(), currentDepth + 1);
            } else if (stmt.isIfStmt() && stmt.asIfStmt().getThenStmt().isBlockStmt()) {
                childMax = getMaxNesting(stmt.asIfStmt().getThenStmt().asBlockStmt(), currentDepth + 1);
                if (stmt.asIfStmt().getElseStmt().isPresent() && stmt.asIfStmt().getElseStmt().get().isBlockStmt()) {
                    int elseMax = getMaxNesting(stmt.asIfStmt().getElseStmt().get().asBlockStmt(), currentDepth + 1);
                    childMax = Math.max(childMax, elseMax);
                }
            }
            max = Math.max(max, childMax);
        }
        return max;
    }
    
    /**
     * Enhanced nesting depth calculation using JavaParser visitor pattern
     */
    private int getMaxNestingEnhanced(Optional<BlockStmt> bodyOpt) {
        if (bodyOpt.isEmpty()) return 0;
        NestingDepthVisitor visitor = new NestingDepthVisitor();
        bodyOpt.get().accept(visitor, 0);
        return visitor.getMaxDepth();
    }
    
    /**
     * Visitor to calculate maximum nesting depth by traversing all control flow statements
     */
    private static class NestingDepthVisitor extends VoidVisitorAdapter<Integer> {
        private int maxDepth = 0;
        
        @Override
        public void visit(BlockStmt n, Integer depth) {
            maxDepth = Math.max(maxDepth, depth);
            super.visit(n, depth + 1);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.IfStmt n, Integer depth) {
            maxDepth = Math.max(maxDepth, depth);
            super.visit(n, depth + 1);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.ForStmt n, Integer depth) {
            maxDepth = Math.max(maxDepth, depth);
            super.visit(n, depth + 1);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.WhileStmt n, Integer depth) {
            maxDepth = Math.max(maxDepth, depth);
            super.visit(n, depth + 1);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.DoStmt n, Integer depth) {
            maxDepth = Math.max(maxDepth, depth);
            super.visit(n, depth + 1);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.SwitchStmt n, Integer depth) {
            maxDepth = Math.max(maxDepth, depth);
            super.visit(n, depth + 1);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.SwitchEntry n, Integer depth) {
            maxDepth = Math.max(maxDepth, depth);
            super.visit(n, depth + 1);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.TryStmt n, Integer depth) {
            maxDepth = Math.max(maxDepth, depth);
            super.visit(n, depth + 1);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.CatchClause n, Integer depth) {
            maxDepth = Math.max(maxDepth, depth);
            super.visit(n, depth + 1);
        }
        
        public int getMaxDepth() {
            return maxDepth;
        }
    }
    
    /**
     * Visitor to collect all used types from the AST
     */
    private static class TypeUsageVisitor extends VoidVisitorAdapter<Set<String>> {
        @Override
        public void visit(NameExpr n, Set<String> usedTypes) {
            usedTypes.add(n.getNameAsString());
            super.visit(n, usedTypes);
        }
        
        @Override
        public void visit(FieldAccessExpr n, Set<String> usedTypes) {
            usedTypes.add(n.getNameAsString());
            super.visit(n, usedTypes);
        }
        
        @Override
        public void visit(MethodCallExpr n, Set<String> usedTypes) {
            usedTypes.add(n.getNameAsString());
            super.visit(n, usedTypes);
        }
        
        @Override
        public void visit(ObjectCreationExpr n, Set<String> usedTypes) {
            usedTypes.add(n.getType().asString());
            super.visit(n, usedTypes);
        }
        
        @Override
        public void visit(VariableDeclarator n, Set<String> usedTypes) {
            usedTypes.add(n.getType().asString());
            super.visit(n, usedTypes);
        }
        
        @Override
        public void visit(Parameter n, Set<String> usedTypes) {
            usedTypes.add(n.getType().asString());
            super.visit(n, usedTypes);
        }
    }
    
    /**
     * Visitor to detect magic numbers in the code
     */
    private static class MagicNumberVisitor extends VoidVisitorAdapter<CodeAnalysisResult> {
        @Override
        public void visit(IntegerLiteralExpr n, CodeAnalysisResult result) {
            String value = n.getValue();
            int intValue = Integer.parseInt(value);
            
            // Ignore common numbers that are usually not magic
            if (intValue != 0 && intValue != 1 && intValue != -1) {
                int lineNumber = n.getBegin().map(b -> b.line).orElse(-1);
                if (lineNumber > 0) {
                    result.getSuggestions().add(new CodeIssue(lineNumber, 
                        "Magic number found: " + value + ". Consider refactoring into a named constant for better readability.", 
                        CodeIssue.Type.SUGGESTION, "info"));
                }
            }
            super.visit(n, result);
        }
        
        @Override
        public void visit(DoubleLiteralExpr n, CodeAnalysisResult result) {
            String value = n.getValue();
            double doubleValue = Double.parseDouble(value);
            
            // Ignore common numbers that are usually not magic
            if (doubleValue != 0.0 && doubleValue != 1.0 && doubleValue != -1.0) {
                int lineNumber = n.getBegin().map(b -> b.line).orElse(-1);
                if (lineNumber > 0) {
                    result.getSuggestions().add(new CodeIssue(lineNumber, 
                        "Magic number found: " + value + ". Consider refactoring into a named constant for better readability.", 
                        CodeIssue.Type.SUGGESTION, "info"));
                }
            }
            super.visit(n, result);
        }
    }
    
    /**
     * Visitor to calculate cyclomatic complexity by counting decision points
     */
    private static class CyclomaticComplexityVisitor extends VoidVisitorAdapter<AtomicInteger> {
        @Override
        public void visit(com.github.javaparser.ast.stmt.IfStmt n, AtomicInteger complexity) {
            complexity.incrementAndGet();
            super.visit(n, complexity);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.ForStmt n, AtomicInteger complexity) {
            complexity.incrementAndGet();
            super.visit(n, complexity);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.WhileStmt n, AtomicInteger complexity) {
            complexity.incrementAndGet();
            super.visit(n, complexity);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.DoStmt n, AtomicInteger complexity) {
            complexity.incrementAndGet();
            super.visit(n, complexity);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.CatchClause n, AtomicInteger complexity) {
            complexity.incrementAndGet();
            super.visit(n, complexity);
        }
        
        @Override
        public void visit(com.github.javaparser.ast.stmt.SwitchEntry n, AtomicInteger complexity) {
            complexity.incrementAndGet();
            super.visit(n, complexity);
        }
        
        @Override
        public void visit(BinaryExpr n, AtomicInteger complexity) {
            // Count logical operators as decision points
            if (n.getOperator() == BinaryExpr.Operator.AND || n.getOperator() == BinaryExpr.Operator.OR) {
                complexity.incrementAndGet();
            }
            super.visit(n, complexity);
        }
    }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/service/ThreadPoolManager.java">
package com.project.codereviewer.service;

import java.util.concurrent.*;
import java.util.logging.Logger;

/**
 * Centralized thread pool management for the application.
 * Provides optimized thread pools for different types of operations.
 */
public class ThreadPoolManager {
    private static final Logger logger = Logger.getLogger(ThreadPoolManager.class.getName());
    
    private static volatile ThreadPoolManager instance;
    
    // Different thread pools for different types of operations
    private final ExecutorService analysisExecutor;
    private final ExecutorService aiRequestExecutor;
    private final ScheduledExecutorService scheduledExecutor;
    
    private ThreadPoolManager() {
        int coreCount = Runtime.getRuntime().availableProcessors();
        
        // CPU-intensive tasks (code analysis)
        this.analysisExecutor = Executors.newFixedThreadPool(
            Math.max(2, coreCount - 1), 
            createThreadFactory("Analysis")
        );
        
        // IO-bound tasks (AI API calls)
        this.aiRequestExecutor = Executors.newFixedThreadPool(
            Math.min(10, coreCount * 2), 
            createThreadFactory("AI-Request")
        );
        
        // Scheduled tasks
        this.scheduledExecutor = Executors.newScheduledThreadPool(
            2, 
            createThreadFactory("Scheduled")
        );
        
        logger.info("ThreadPoolManager initialized with " + coreCount + " available processors");
    }
    
    public static ThreadPoolManager getInstance() {
        if (instance == null) {
            synchronized (ThreadPoolManager.class) {
                if (instance == null) {
                    instance = new ThreadPoolManager();
                }
            }
        }
        return instance;
    }
    
    private ThreadFactory createThreadFactory(String namePrefix) {
        return new ThreadFactory() {
            private int threadNumber = 1;
            
            @Override
            public Thread newThread(Runnable r) {
                Thread t = new Thread(r, namePrefix + "-" + threadNumber++);
                t.setDaemon(true);
                return t;
            }
        };
    }
    
    public ExecutorService getAnalysisExecutor() {
        return analysisExecutor;
    }
    
    public ExecutorService getAiRequestExecutor() {
        return aiRequestExecutor;
    }
    
    public ScheduledExecutorService getScheduledExecutor() {
        return scheduledExecutor;
    }
    
    public void shutdown() {
        logger.info("Shutting down thread pools...");
        analysisExecutor.shutdown();
        aiRequestExecutor.shutdown();
        scheduledExecutor.shutdown();
        
        try {
            if (!analysisExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                analysisExecutor.shutdownNow();
            }
            if (!aiRequestExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                aiRequestExecutor.shutdownNow();
            }
            if (!scheduledExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduledExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.warning("Thread pool shutdown interrupted");
        }
    }
}
</file>

<file path="backend/src/main/java/com/project/codereviewer/Application.java">
package com.project.codereviewer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
</file>

<file path="backend/src/main/resources/application-production.properties">
# Production Application Configuration Template
# Copy this file to application-production.properties and configure for your environment

# Application Configuration
spring.application.name=CodeReviewerBackend
spring.profiles.active=production

# Server Configuration
server.port=8080
server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=30s

# OpenRouter AI Configuration
openrouter.api.key=${OPENROUTER_API_KEY:YOUR_API_KEY_HERE}
openrouter.model.name=${OPENROUTER_MODEL_NAME:mistralai/mixtral-8x7b-instruct}

# Logging Configuration for Production
logging.level.root=WARN
logging.level.com.project.codereviewer=INFO
logging.level.org.springframework=WARN
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
logging.file.name=logs/codereviewer.log
logging.file.max-size=10MB
logging.file.max-history=5

# HTTP Configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
server.compression.enabled=true
server.compression.mime-types=application/json,application/xml,text/html,text/xml,text/plain

# Management & Monitoring
management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.show-details=when-authorized
management.metrics.export.prometheus.enabled=false

# Security Headers
server.error.include-stacktrace=never
server.error.include-message=never

# Connection Pool & Performance
server.tomcat.threads.max=200
server.tomcat.threads.min-spare=10
server.tomcat.connection-timeout=20000
server.tomcat.max-connections=8192

# CORS Configuration (adjust for your frontend domain)
management.endpoints.web.cors.allowed-origins=${CORS_ORIGINS:*}
management.endpoints.web.cors.allowed-methods=GET,POST,OPTIONS
management.endpoints.web.cors.allowed-headers=*
</file>

<file path="backend/src/main/resources/application.properties">
# Application Configuration
spring.application.name=CodeReviewerBackend

# Server Configuration
server.port=8080

# OpenRouter API Configuration (replace with your actual API key)
openrouter.api.key=YOUR_API_KEY_HERE
openrouter.model.name=mistralai/mixtral-8x7b-instruct

# Logging Configuration
logging.level.com.project.codereviewer=INFO
logging.level.org.springframework=WARN
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n

# HTTP Configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# CORS Configuration (if needed)
management.endpoints.web.cors.allowed-origins=*
management.endpoints.web.cors.allowed-methods=GET,POST
</file>

<file path="backend/src/test/java/com/project/codereviewer/ApplicationTests.java">
package com.project.codereviewer;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

    @Test
    void contextLoads() {
    }

}
</file>

<file path="backend/build-docker.sh">
#!/bin/bash

# Build script for CodeReviewer Backend
# This script builds the application and creates a Docker image

echo "🏗️  Building CodeReviewer Backend..."
echo "=================================="
echo

# Step 1: Clean and build the JAR file
echo "📦 Step 1: Building JAR file with Maven..."
mvn clean package -DskipTests

# Check if build was successful
if [ $? -eq 0 ]; then
    echo "✅ Maven build successful!"
else
    echo "❌ Maven build failed!"
    exit 1
fi

echo

# Step 2: Build Docker image
echo "🐳 Step 2: Building Docker image..."
docker build -t codereviewer-backend:latest .

# Check if Docker build was successful
if [ $? -eq 0 ]; then
    echo "✅ Docker image built successfully!"
    echo "📋 Image: codereviewer-backend:latest"
else
    echo "❌ Docker build failed!"
    exit 1
fi

echo

# Step 3: Show image information
echo "📊 Docker Image Information:"
docker images | grep codereviewer-backend

echo
echo "🚀 To run the container:"
echo "docker run -p 8080:8080 codereviewer-backend:latest"
echo
echo "🔧 To run with custom configuration:"
echo "docker run -p 8080:8080 -e OPENROUTER_API_KEY=your_key codereviewer-backend:latest"
</file>

<file path="backend/DEPLOYMENT.md">
# CodeReviewer Backend - Deployment Guide

## 📦 Containerization with Docker

Your CodeReviewer backend is now ready for containerized deployment! This guide covers all deployment options.

## 🐳 Docker Deployment

### Prerequisites
- Docker installed on your system
- JAR file built with Maven (`mvn clean package`)

### Files Created
- `Dockerfile` - Container definition
- `.dockerignore` - Excludes unnecessary files
- `docker-compose.yml` - Easy deployment configuration
- `build-docker.sh` - Automated build script

### Option 1: Using the Build Script (Recommended)
```bash
# Run the automated build script
./build-docker.sh

# This will:
# 1. Build the JAR with Maven
# 2. Create the Docker image
# 3. Show you how to run it
```

### Option 2: Manual Docker Build
```bash
# 1. Build the JAR file
mvn clean package -DskipTests

# 2. Build Docker image
docker build -t codereviewer-backend:latest .

# 3. Run the container
docker run -p 8080:8080 codereviewer-backend:latest
```

### Option 3: Using Docker Compose (Production-Ready)
```bash
# Start the service
docker-compose up -d

# View logs
docker-compose logs -f

# Stop the service
docker-compose down
```

## 🔧 Configuration

### Environment Variables
Set these in your deployment environment:

```bash
# Required for AI features
OPENROUTER_API_KEY=your_actual_api_key_here
OPENROUTER_MODEL_NAME=mistralai/mixtral-8x7b-instruct

# Optional JVM tuning
JAVA_OPTS="-Xmx512m -Xms256m"

# Optional logging level
LOGGING_LEVEL_COM_PROJECT_CODEREVIEWER=INFO
```

### Using Environment Variables with Docker
```bash
# Run with environment variables
docker run -p 8080:8080 \
  -e OPENROUTER_API_KEY=your_key \
  -e OPENROUTER_MODEL_NAME=mistralai/mixtral-8x7b-instruct \
  codereviewer-backend:latest
```

## 🚀 Deployment Options

### 1. Local Development
```bash
# Traditional Maven run
mvn spring-boot:run

# Or run the JAR directly
java -jar target/CodeReviewer-0.0.1-SNAPSHOT.jar
```

### 2. Docker Container
```bash
# Basic run
docker run -p 8080:8080 codereviewer-backend:latest

# With custom configuration
docker run -p 8080:8080 \
  -e OPENROUTER_API_KEY=your_key \
  codereviewer-backend:latest
```

### 3. Docker Compose (Recommended for Production)
```bash
# Edit docker-compose.yml to set your API key
# Then start the service
docker-compose up -d
```

### 4. Cloud Deployment
The Docker image can be deployed to:
- **AWS ECS/Fargate**
- **Google Cloud Run**
- **Azure Container Instances**
- **Kubernetes clusters**
- **Heroku** (using Docker)

## 🔍 Health Monitoring

### Health Check Endpoint
```bash
curl http://localhost:8080/api/analysis/health
```

### Docker Health Check
The container includes automatic health checks:
- Checks every 30 seconds
- Times out after 3 seconds
- Retries 3 times before marking unhealthy

## 📊 Resource Requirements

### Minimum Requirements
- **Memory:** 256MB RAM
- **CPU:** 0.25 cores
- **Storage:** 100MB

### Recommended for Production
- **Memory:** 512MB RAM
- **CPU:** 0.5 cores
- **Storage:** 1GB (for logs and analysis history)

## 🔒 Security Features

### Container Security
- Runs as non-root user (`appuser`)
- Minimal JRE base image (no unnecessary packages)
- No graphics libraries (pure backend)
- Health checks for monitoring

### Application Security
- CORS configured for web integration
- Input validation on all endpoints
- Secure file upload handling
- No sensitive data in logs

## 📋 API Endpoints

Once deployed, your backend provides:

```
GET  /api/analysis/health      - Health check
POST /api/analysis/static      - Static code analysis
POST /api/analysis/ai          - AI-powered suggestions
POST /api/code-review/analyze  - Full analysis with metadata
POST /api/code-review/upload   - File upload analysis
```

## 🧪 Testing Your Deployment

### Quick Test Script
```bash
# Test health
curl http://localhost:8080/api/analysis/health

# Test static analysis
curl -X POST http://localhost:8080/api/analysis/static \
  -H "Content-Type: application/json" \
  -d 'public class Test { private int x = 5; }'

# Use the provided test script
./test-analysis-controller.sh
```

## 🏗️ Dockerfile Explanation

```dockerfile
FROM openjdk:17-jre-slim     # Lightweight JRE (no graphics needed)
WORKDIR /app                 # Set working directory
COPY target/*.jar app.jar    # Copy built JAR
EXPOSE 8080                  # Expose Spring Boot port
RUN adduser appuser          # Create non-root user
USER appuser                 # Run as non-root
ENTRYPOINT ["java", "-jar"]  # Start command
HEALTHCHECK ...              # Auto health monitoring
```

## 🎯 Next Steps

1. **Get OpenRouter API Key**: Sign up at openrouter.ai
2. **Configure Environment**: Set your API key in environment variables
3. **Deploy**: Choose your preferred deployment method
4. **Integrate**: Connect with your frontend application
5. **Monitor**: Use health checks and logs for monitoring

Your CodeReviewer backend is now production-ready! 🎉
</file>

<file path="backend/docker-compose.yml">
version: '3.8'

services:
  codereviewer-backend:
    build: .
    container_name: codereviewer-backend
    ports:
      - "8080:8080"
    environment:
      # Spring Boot profile (optional)
      - SPRING_PROFILES_ACTIVE=production
      
      # OpenRouter API configuration (replace with your actual values)
      - OPENROUTER_API_KEY=YOUR_API_KEY_HERE
      - OPENROUTER_MODEL_NAME=mistralai/mixtral-8x7b-instruct
      
      # JVM options for container
      - JAVA_OPTS=-Xmx512m -Xms256m
      
      # Logging level
      - LOGGING_LEVEL_COM_PROJECT_CODEREVIEWER=INFO
    
    # Health check configuration
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/analysis/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    
    # Restart policy
    restart: unless-stopped
    
    # Resource limits (optional)
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'

# Optional: If you want to persist analysis history
volumes:
  analysis_data:
    driver: local
</file>

<file path="backend/Dockerfile">
# Use Eclipse Temurin 17 JRE on Ubuntu Focal
FROM eclipse-temurin:17-jre-focal

# Set working directory inside the container
WORKDIR /app

# Copy the built JAR file to the container (assumes JAR is in the same directory as Dockerfile)
COPY CodeReviewer-0.0.1-SNAPSHOT.jar app.jar

# Expose the port that Spring Boot runs on
EXPOSE 8080

# Set JVM options for containerized environment
ENV JAVA_OPTS="-Xmx512m -Xms256m"

# Create a non-root user for security
RUN adduser --disabled-password --gecos '' appuser
USER appuser

# Command to run the application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]

# Health check to ensure the application is running
HEALTHCHECK --interval=30s --timeout=3s --start-period=30s --retries=3 \
  CMD curl -f http://localhost:8080/api/analysis/health || exit 1
</file>

<file path="backend/HELP.md">
# Getting Started

### Reference Documentation

For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.4/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.4/maven-plugin/build-image.html)
* [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.4/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the
parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.
</file>

<file path="backend/pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.project</groupId>
    <artifactId>CodeReviewer</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>CodeReviewer2.0</name>
    <description>CodeReviewer2.0</description>
    <url/>
    <licenses>
        <license/>
    </licenses>
    <developers>
        <developer/>
    </developers>
    <scm>
        <connection/>
        <developerConnection/>
        <tag/>
        <url/>
    </scm>
    <properties>
        <java.version>17</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <!-- JavaParser for code analysis -->
        <dependency>
            <groupId>com.github.javaparser</groupId>
            <artifactId>javaparser-core</artifactId>
            <version>3.25.4</version>
        </dependency>
        
        <!-- JSON processing -->
        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>20231013</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
</file>

<file path="backend/test-analysis-controller.sh">
#!/bin/bash

# Test Script for AnalysisController
# This script demonstrates all the endpoints created in Steps 3.1-3.3

echo "🚀 Testing AnalysisController Endpoints"
echo "======================================="
echo

# Test 1: Health Check
echo "📡 Testing Health Endpoint..."
echo "GET /api/analysis/health"
curl -s http://localhost:8080/api/analysis/health
echo -e "\n"

# Test 2: Static Analysis
echo "🔍 Testing Static Analysis Endpoint..."
echo "POST /api/analysis/static"
echo "Sample Code: public class Test { private int temp = 5; }"

curl -s -X POST http://localhost:8080/api/analysis/static \
  -H "Content-Type: application/json" \
  -d 'public class Test { 
    private int temp = 5; 
    public void method() { 
      int x = temp + 10; 
    } 
  }' | jq '.'
echo

# Test 3: AI Analysis (will show error without API key)
echo "🤖 Testing AI Analysis Endpoint..."
echo "POST /api/analysis/ai"
echo "Sample Code: public class Test { private int x = 5; }"

curl -s -X POST http://localhost:8080/api/analysis/ai \
  -H "Content-Type: application/json" \
  -d 'public class Test { private int x = 5; }'
echo -e "\n"

echo "✅ All tests completed!"
echo
echo "📝 Summary:"
echo "- Health endpoint: ✅ Working"
echo "- Static analysis: ✅ Working (detects code issues)"
echo "- AI analysis: ✅ Working (requires API key configuration)"
echo
echo "🔧 To enable AI analysis:"
echo "1. Get an API key from OpenRouter.ai"
echo "2. Add it to src/main/resources/application.properties:"
echo "   openrouter.api.key=your_actual_api_key_here"
</file>

<file path="frontend/META-INF/MANIFEST.MF">
Manifest-Version: 1.0
Created-By: Maven JAR Plugin 3.4.1
Build-Jdk-Spec: 21
Main-Class: com.reviewer.codereviewer.MainApp
</file>

<file path="frontend/src/main/java/com/reviewer/codereviewer/client/dto/CodeAnalysisResult.java">
package com.reviewer.codereviewer.client.dto;

import java.util.List;
import java.util.ArrayList;

/**
 * Data Transfer Object for code analysis results from the backend API
 */
public class CodeAnalysisResult {
    private List<CodeIssue> errors;
    private List<CodeIssue> suggestions;
    private double score;
    private String analysisTime;
    
    public CodeAnalysisResult() {
        this.errors = new ArrayList<>();
        this.suggestions = new ArrayList<>();
        this.score = 0.0;
    }
    
    public CodeAnalysisResult(List<CodeIssue> errors, List<CodeIssue> suggestions, double score) {
        this.errors = errors != null ? errors : new ArrayList<>();
        this.suggestions = suggestions != null ? suggestions : new ArrayList<>();
        this.score = score;
    }
    
    // Getters and Setters
    public List<CodeIssue> getErrors() {
        return errors;
    }
    
    public void setErrors(List<CodeIssue> errors) {
        this.errors = errors;
    }
    
    public List<CodeIssue> getSuggestions() {
        return suggestions;
    }
    
    public void setSuggestions(List<CodeIssue> suggestions) {
        this.suggestions = suggestions;
    }
    
    public double getScore() {
        return score;
    }
    
    public void setScore(double score) {
        this.score = score;
    }
    
    public String getAnalysisTime() {
        return analysisTime;
    }
    
    public void setAnalysisTime(String analysisTime) {
        this.analysisTime = analysisTime;
    }
    
    public boolean hasIssues() {
        return !errors.isEmpty() || !suggestions.isEmpty();
    }
    
    public int getTotalIssueCount() {
        return errors.size() + suggestions.size();
    }
}
</file>

<file path="frontend/src/main/java/com/reviewer/codereviewer/client/dto/CodeIssue.java">
package com.reviewer.codereviewer.client.dto;

import java.util.List;
import java.util.ArrayList;

/**
 * Data Transfer Object for code issues from the backend API
 */
public class CodeIssue {
    
    public enum Type {
        ERROR, WARNING, SUGGESTION, INFO
    }
    
    private String message;
    private int line;
    private int column;
    private Type type;
    private String severity;
    private List<QuickFix> quickFixes;
    
    public CodeIssue() {
        this.quickFixes = new ArrayList<>();
    }
    
    public CodeIssue(String message, int line, int column, Type type) {
        this.message = message;
        this.line = line;
        this.column = column;
        this.type = type;
        this.quickFixes = new ArrayList<>();
    }
    
    public CodeIssue(String message, int line, Type type) {
        this(message, line, 0, type);
    }
    
    // Getters and Setters
    public String getMessage() {
        return message;
    }
    
    public void setMessage(String message) {
        this.message = message;
    }
    
    public int getLine() {
        return line;
    }
    
    public void setLine(int line) {
        this.line = line;
    }
    
    public int getColumn() {
        return column;
    }
    
    public void setColumn(int column) {
        this.column = column;
    }
    
    public Type getType() {
        return type;
    }
    
    public void setType(Type type) {
        this.type = type;
    }
    
    public String getSeverity() {
        return severity;
    }
    
    public void setSeverity(String severity) {
        this.severity = severity;
    }
    
    public List<QuickFix> getQuickFixes() {
        return quickFixes;
    }
    
    public void setQuickFixes(List<QuickFix> quickFixes) {
        this.quickFixes = quickFixes != null ? quickFixes : new ArrayList<>();
    }
    
    public void addQuickFix(QuickFix quickFix) {
        if (quickFix != null) {
            this.quickFixes.add(quickFix);
        }
    }
    
    public boolean hasQuickFixes() {
        return !quickFixes.isEmpty();
    }
    
    @Override
    public String toString() {
        return String.format("%s at line %d: %s", type, line, message);
    }
}
</file>

<file path="frontend/src/main/java/com/reviewer/codereviewer/client/dto/QuickFix.java">
package com.reviewer.codereviewer.client.dto;

/**
 * Data Transfer Object for quick fixes from the backend API
 */
public class QuickFix {
    private String description;
    private String action;
    private String replacement;
    private int startLine;
    private int endLine;
    
    public QuickFix() {
    }
    
    public QuickFix(String description, String action) {
        this.description = description;
        this.action = action;
    }
    
    public QuickFix(String description, String action, String replacement, int startLine, int endLine) {
        this.description = description;
        this.action = action;
        this.replacement = replacement;
        this.startLine = startLine;
        this.endLine = endLine;
    }
    
    // Getters and Setters
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public String getAction() {
        return action;
    }
    
    public void setAction(String action) {
        this.action = action;
    }
    
    public String getReplacement() {
        return replacement;
    }
    
    public void setReplacement(String replacement) {
        this.replacement = replacement;
    }
    
    public int getStartLine() {
        return startLine;
    }
    
    public void setStartLine(int startLine) {
        this.startLine = startLine;
    }
    
    public int getEndLine() {
        return endLine;
    }
    
    public void setEndLine(int endLine) {
        this.endLine = endLine;
    }
    
    @Override
    public String toString() {
        return description != null ? description : action;
    }
}
</file>

<file path="frontend/src/main/java/com/reviewer/codereviewer/client/ApiClientService.java">
package com.reviewer.codereviewer.client;

import com.reviewer.codereviewer.client.dto.CodeAnalysisResult;
import com.reviewer.codereviewer.client.dto.CodeIssue;
import com.reviewer.codereviewer.client.dto.QuickFix;

import java.io.*;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.List;
import java.util.ArrayList;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.JsonNode;

/**
 * API Client Service for communicating with the CodeReviewer backend server.
 * This service handles all HTTP communication and serialization/deserialization.
 */
public class ApiClientService {
    private static final Logger logger = Logger.getLogger(ApiClientService.class.getName());
    
    private final HttpClient httpClient;
    private final ObjectMapper objectMapper;
    private final String serverBaseUrl;
    
    // Default configuration
    private static final String DEFAULT_SERVER_URL = "http://localhost:8080";
    private static final Duration REQUEST_TIMEOUT = Duration.ofSeconds(30);
    private static final Duration STREAMING_TIMEOUT = Duration.ofMinutes(2);
    
    public ApiClientService() {
        this(DEFAULT_SERVER_URL);
    }
    
    public ApiClientService(String serverBaseUrl) {
        this.serverBaseUrl = serverBaseUrl.endsWith("/") ? 
            serverBaseUrl.substring(0, serverBaseUrl.length() - 1) : serverBaseUrl;
        
        this.httpClient = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(10))
            .build();
            
        this.objectMapper = new ObjectMapper();
        
        logger.info("ApiClientService initialized with server URL: " + this.serverBaseUrl);
    }
    
    /**
     * Analyzes the provided code by sending it to the backend server.
     * 
     * @param code The source code to analyze
     * @return CompletableFuture containing the analysis result
     */
    public CompletableFuture<CodeAnalysisResult> analyzeCode(String code) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                logger.info("Sending code analysis request to server");
                
                // Create request body
                String requestBody = objectMapper.writeValueAsString(new CodeAnalysisRequest(code));
                
                // Build HTTP request
                HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(serverBaseUrl + "/api/code-review/analyze"))
                    .timeout(REQUEST_TIMEOUT)
                    .header("Content-Type", "application/json")
                    .POST(HttpRequest.BodyPublishers.ofString(requestBody))
                    .build();
                
                // Send request and handle response
                HttpResponse<String> response = httpClient.send(request, 
                    HttpResponse.BodyHandlers.ofString());
                
                if (response.statusCode() == 200) {
                    logger.info("Analysis request successful");
                    return parseAnalysisResult(response.body());
                } else {
                    logger.warning("Analysis request failed with status: " + response.statusCode());
                    throw new RuntimeException("Server error: " + response.statusCode() + " - " + response.body());
                }
                
            } catch (Exception e) {
                logger.log(Level.SEVERE, "Error during code analysis", e);
                throw new RuntimeException("Failed to analyze code: " + e.getMessage(), e);
            }
        });
    }
    
    /**
     * Gets AI suggestions for the provided code with streaming response.
     * 
     * @param code The source code to get suggestions for
     * @param question The specific question or request about the code
     * @param chunkConsumer Consumer that receives chunks of the streaming response
     * @return CompletableFuture that completes when streaming is done
     */
    public CompletableFuture<Void> getCodeSuggestionStreaming(String code, String question, Consumer<String> chunkConsumer) {
        return CompletableFuture.runAsync(() -> {
            try {
                logger.info("Sending AI suggestion request to server");
                
                // Create request body
                AISuggestionRequest requestObj = new AISuggestionRequest(code, question);
                String requestBody = objectMapper.writeValueAsString(requestObj);
                
                // Build HTTP request
                HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(serverBaseUrl + "/api/code-review/ai-suggest"))
                    .timeout(STREAMING_TIMEOUT)
                    .header("Content-Type", "application/json")
                    .header("Accept", "text/plain")
                    .POST(HttpRequest.BodyPublishers.ofString(requestBody))
                    .build();
                
                // Send request and handle streaming response
                HttpResponse<InputStream> response = httpClient.send(request, 
                    HttpResponse.BodyHandlers.ofInputStream());
                
                if (response.statusCode() == 200) {
                    logger.info("AI suggestion request successful, processing stream");
                    
                    try (BufferedReader reader = new BufferedReader(
                            new InputStreamReader(response.body()))) {
                        
                        String line;
                        while ((line = reader.readLine()) != null) {
                            chunkConsumer.accept(line + "\n");
                        }
                    }
                } else {
                    logger.warning("AI suggestion request failed with status: " + response.statusCode());
                    throw new RuntimeException("Server error: " + response.statusCode());
                }
                
            } catch (Exception e) {
                logger.log(Level.SEVERE, "Error during AI suggestion request", e);
                throw new RuntimeException("Failed to get AI suggestions: " + e.getMessage(), e);
            }
        });
    }
    
    /**
     * Simple AI suggestion method that returns the complete response.
     * 
     * @param code The source code to get suggestions for
     * @param question The specific question or request about the code
     * @return CompletableFuture containing the complete AI response
     */
    public CompletableFuture<String> getCodeSuggestion(String code, String question) {
        CompletableFuture<String> future = new CompletableFuture<>();
        StringBuilder responseBuilder = new StringBuilder();
        
        getCodeSuggestionStreaming(code, question, chunk -> {
            responseBuilder.append(chunk);
        }).whenComplete((v, ex) -> {
            if (ex != null) {
                future.completeExceptionally(ex);
            } else {
                future.complete(responseBuilder.toString());
            }
        });
        
        return future;
    }
    
    /**
     * Checks if the server is available and responding.
     * 
     * @return CompletableFuture containing true if server is healthy, false otherwise
     */
    public CompletableFuture<Boolean> checkServerHealth() {
        return CompletableFuture.supplyAsync(() -> {
            try {
                HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(serverBaseUrl + "/api/code-review/health"))
                    .timeout(Duration.ofSeconds(5))
                    .GET()
                    .build();
                
                HttpResponse<String> response = httpClient.send(request, 
                    HttpResponse.BodyHandlers.ofString());
                
                return response.statusCode() == 200;
            } catch (Exception e) {
                logger.log(Level.WARNING, "Server health check failed", e);
                return false;
            }
        });
    }
    
    /**
     * Parses the JSON response from the analysis endpoint into a CodeAnalysisResult object.
     */
    private CodeAnalysisResult parseAnalysisResult(String jsonResponse) throws Exception {
        JsonNode rootNode = objectMapper.readTree(jsonResponse);
        
        CodeAnalysisResult result = new CodeAnalysisResult();
        
        // Parse errors
        if (rootNode.has("errors")) {
            List<CodeIssue> errors = new ArrayList<>();
            for (JsonNode errorNode : rootNode.get("errors")) {
                errors.add(parseCodeIssue(errorNode));
            }
            result.setErrors(errors);
        }
        
        // Parse suggestions
        if (rootNode.has("suggestions")) {
            List<CodeIssue> suggestions = new ArrayList<>();
            for (JsonNode suggestionNode : rootNode.get("suggestions")) {
                suggestions.add(parseCodeIssue(suggestionNode));
            }
            result.setSuggestions(suggestions);
        }
        
        // Parse score
        if (rootNode.has("score")) {
            result.setScore(rootNode.get("score").asDouble());
        }
        
        // Parse analysis time
        if (rootNode.has("analysisTime")) {
            result.setAnalysisTime(rootNode.get("analysisTime").asText());
        }
        
        return result;
    }
    
    /**
     * Parses a JSON node into a CodeIssue object.
     */
    private CodeIssue parseCodeIssue(JsonNode issueNode) {
        CodeIssue issue = new CodeIssue();
        
        if (issueNode.has("message")) {
            issue.setMessage(issueNode.get("message").asText());
        }
        
        if (issueNode.has("line")) {
            issue.setLine(issueNode.get("line").asInt());
        }
        
        if (issueNode.has("column")) {
            issue.setColumn(issueNode.get("column").asInt());
        }
        
        if (issueNode.has("type")) {
            String typeStr = issueNode.get("type").asText().toUpperCase();
            try {
                issue.setType(CodeIssue.Type.valueOf(typeStr));
            } catch (IllegalArgumentException e) {
                issue.setType(CodeIssue.Type.INFO);
            }
        }
        
        if (issueNode.has("severity")) {
            issue.setSeverity(issueNode.get("severity").asText());
        }
        
        // Parse quick fixes if present
        if (issueNode.has("quickFixes")) {
            List<QuickFix> quickFixes = new ArrayList<>();
            for (JsonNode fixNode : issueNode.get("quickFixes")) {
                QuickFix quickFix = new QuickFix();
                if (fixNode.has("description")) {
                    quickFix.setDescription(fixNode.get("description").asText());
                }
                if (fixNode.has("action")) {
                    quickFix.setAction(fixNode.get("action").asText());
                }
                if (fixNode.has("replacement")) {
                    quickFix.setReplacement(fixNode.get("replacement").asText());
                }
                if (fixNode.has("startLine")) {
                    quickFix.setStartLine(fixNode.get("startLine").asInt());
                }
                if (fixNode.has("endLine")) {
                    quickFix.setEndLine(fixNode.get("endLine").asInt());
                }
                quickFixes.add(quickFix);
            }
            issue.setQuickFixes(quickFixes);
        }
        
        return issue;
    }
    
    // Inner classes for request DTOs
    private static class CodeAnalysisRequest {
        public final String code;
        
        public CodeAnalysisRequest(String code) {
            this.code = code;
        }
    }
    
    private static class AISuggestionRequest {
        public final String code;
        public final String question;
        
        public AISuggestionRequest(String code, String question) {
            this.code = code;
            this.question = question;
        }
    }
}
</file>

<file path="frontend/src/main/java/com/reviewer/codereviewer/controller/MainController.java">
package com.reviewer.codereviewer.controller;

import com.reviewer.codereviewer.client.ApiClientService;
import com.reviewer.codereviewer.client.dto.CodeAnalysisResult;
import com.reviewer.codereviewer.ui.MainView;
import com.reviewer.codereviewer.ui.ModernMainView;
import javafx.application.Platform;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.util.concurrent.CompletableFuture;
import java.util.logging.Level;
import java.util.logging.Logger;

public class MainController {
    private static final Logger logger = Logger.getLogger(MainController.class.getName());
    
    private MainView mainView;
    private ModernMainView modernView;
    private final ApiClientService apiClientService;
    
    /**
     * Constructor with default API client
     */
    public MainController() {
        this.apiClientService = new ApiClientService();
    }
    
    /**
     * Constructor with custom API client (useful for testing)
     */
    public MainController(ApiClientService apiClientService) {
        this.apiClientService = apiClientService;
    }
    
    /**
     * Set the modern view for callbacks
     * @param modernView the modern view instance
     */
    public void setModernView(ModernMainView modernView) {
        this.modernView = modernView;
    }
    
    private CodeAnalysisResult lastResult;
    private String currentFileName = "";

    public void start(Stage primaryStage) {
        mainView = new MainView(this);
        mainView.start(primaryStage);
        
        // Check server health on startup
        checkServerConnection();
    }
    
    /**
     * Check if the backend server is available
     */
    private void checkServerConnection() {
        apiClientService.checkServerHealth().whenComplete((isHealthy, ex) -> {
            Platform.runLater(() -> {
                if (!isHealthy || ex != null) {
                    String errorMsg = "⚠️ Cannot connect to backend server. Please ensure the server is running on http://localhost:8080";
                    if (modernView != null) {
                        modernView.displayError(errorMsg);
                    } else if (mainView != null) {
                        mainView.displayError(errorMsg);
                    }
                    logger.warning("Backend server is not available");
                } else {
                    logger.info("Successfully connected to backend server");
                }
            });
        });
    }

    /**
     * Analyzes the provided code using the backend API and updates the UI with results.
     * @param code The source code to analyze
     */
    public void analyzeCode(String code) {
        if (code == null || code.trim().isEmpty()) {
            if (modernView != null) {
                modernView.displayError("No code to analyze");
            } else if (mainView != null) {
                mainView.displayError("No code to analyze");
            }
            return;
        }
        
        // Show loading state
        Platform.runLater(() -> {
            if (modernView != null) {
                modernView.displayError("Analyzing code...");
            } else if (mainView != null) {
                mainView.displayError("Analyzing code...");
            }
        });
        
        // Use the API client to analyze code
        apiClientService.analyzeCode(code).whenComplete((result, ex) -> {
            Platform.runLater(() -> {
                if (ex != null) {
                    String errorMsg = "Analysis failed: " + ex.getMessage();
                    if (modernView != null) {
                        modernView.displayError(errorMsg);
                    } else if (mainView != null) {
                        mainView.displayError(errorMsg);
                    }
                    logger.log(Level.SEVERE, "Code analysis failed", ex);
                } else {
                    // Store the result for later use
                    lastResult = result;
                    
                    if (modernView != null) {
                        modernView.displayAnalysisResult(result);
                    } else if (mainView != null) {
                        mainView.displayAnalysisResult(result);
                    }
                    
                    // Store analysis record for trend tracking
                    if (!currentFileName.isEmpty()) {
                        storeAnalysisRecord(result);
                    }
                }
            });
        });
    }

    public void onOpenFile(Stage primaryStage) {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Open Java File");
        fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter("Java Files", "*.java"));
        File file = fileChooser.showOpenDialog(primaryStage);
        if (file != null) {
            try {
                String content = Files.readString(file.toPath());
                currentFileName = file.getName();
                mainView.displayCode(content);
                analyzeCode(content);
            } catch (Exception ex) {
                mainView.displayError("Failed to load file: " + ex.getMessage());
            }
        }
    }

    public void analyzeAndDisplay(String code) {
        // This method now delegates to the main analyzeCode method
        // which uses the API client
        analyzeCode(code);
    }
    
    private void storeAnalysisRecord(CodeAnalysisResult result) {
        try {
            // Create a simple analysis record for tracking
            String record = String.format(
                "{\"timestamp\":\"%s\", \"fileName\":\"%s\", \"totalIssues\":%d, \"errors\":%d, \"suggestions\":%d}",
                java.time.Instant.now().toString(),
                currentFileName,
                result.getTotalIssueCount(),
                result.getErrors().size(),
                result.getSuggestions().size()
            );
            
            // Append to analysis history file
            String homeDir = System.getProperty("user.home");
            String historyFile = homeDir + "/analysis_history.json";
            
            try (FileWriter writer = new FileWriter(historyFile, true)) {
                writer.write(record + "\n");
            }
        } catch (IOException e) {
            // Silently fail - trend tracking is not critical
            System.err.println("Failed to store analysis record: " + e.getMessage());
        }
    }
    
    /**
     * Handle the Ask AI button click (this method is no longer directly used - see onAskAiWithQuestion)
     * @deprecated Use onAskAiWithQuestion instead
     */
    @Deprecated
    public void onAskAi() {
        // Default question if none provided
        onAskAiWithQuestion(mainView.getCurrentCode(), "Please review this code and suggest improvements.");
    }
    
    /**
     * Handle AI request with a specific question using the backend API
     * @param code The code to analyze
     * @param question The user's question about the code
     */
    public void onAskAiWithQuestion(String code, String question) {
        if (code == null || code.trim().isEmpty()) {
            mainView.displayError("No code to analyze");
            return;
        }
        
        mainView.showAiLoading();
        mainView.clearAiSuggestion();
        
        logger.info("Starting AI request with question: \"" + question + "\"");
        
        // Show some immediate feedback
        Platform.runLater(() -> mainView.appendAiSuggestion("Processing your question: \"" + question + "\"\n\n"));
        
        logger.info("Using AI service from backend server");
        
        // Use the API client for AI suggestions with streaming
        CompletableFuture<Void> future = apiClientService.getCodeSuggestionStreaming(
                code, 
                question,
                // This consumer will be called for each chunk of the response
                chunk -> Platform.runLater(() -> mainView.appendAiSuggestion(chunk))
        );
        
        // Handle completion
        future.exceptionally(ex -> {
            Platform.runLater(() -> {
                logger.log(Level.SEVERE, "AI suggestion error", ex);
                mainView.appendAiSuggestion("\n\nError getting AI suggestion: " + ex.getMessage());
                mainView.appendAiSuggestion("\n\nTroubleshooting steps:\n" +
                        "1. Check that the backend server is running\n" +
                        "2. Verify your AI service configuration\n" +
                        "3. Check your internet connection\n" +
                        "4. Try with a simpler question");
                mainView.hideAiLoading();
            });
            return null;
        }).thenRun(() -> Platform.runLater(() -> {
            mainView.hideAiLoading();
        }));
    }

    public CodeAnalysisResult getLastResult() {
        return lastResult;
    }
}
</file>

<file path="frontend/src/main/java/com/reviewer/codereviewer/ui/MainView.java">
package com.reviewer.codereviewer.ui;

import com.reviewer.codereviewer.controller.MainController;
import com.reviewer.codereviewer.client.dto.CodeAnalysisResult;
import com.reviewer.codereviewer.client.dto.CodeIssue;
import com.reviewer.codereviewer.client.dto.QuickFix;
import javafx.animation.FadeTransition;
import javafx.application.Platform;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;
import javafx.scene.control.SplitPane;
import org.fxmisc.richtext.CodeArea;
import org.fxmisc.richtext.LineNumberFactory;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.scene.input.MouseEvent;
import javafx.stage.FileChooser;
import javafx.geometry.Pos;
import org.kordamp.ikonli.javafx.FontIcon;
import org.kordamp.ikonli.fontawesome5.FontAwesomeSolid;
import java.io.FileWriter;
import java.io.IOException;
import java.io.File;
import java.util.logging.Level;
import java.util.logging.Logger;

import javafx.scene.control.Tooltip;
import javafx.util.Duration;
import java.util.HashMap;
import java.util.Map;
import javafx.scene.layout.StackPane;
import javafx.geometry.Insets;
import javafx.scene.text.Text;
import javafx.scene.shape.Rectangle;
import java.util.concurrent.CompletableFuture;

public class MainView {
    private final MainController controller;
    private final Logger logger = Logger.getLogger(MainView.class.getName());
    private CodeArea codeArea;
    private TableView<CodeIssue> errorTableView;
    private TableView<CodeIssue> suggestionTableView;
    private ObservableList<CodeIssue> errors;
    private ObservableList<CodeIssue> suggestions;
    private FilteredList<CodeIssue> filteredErrors;
    private FilteredList<CodeIssue> filteredSuggestions;
    private Stage primaryStage;
    private Label detailsHeader;
    private TextArea detailsArea;
    private Map<Integer, String> errorTooltips = new HashMap<>();
    private VBox heatmapPane;
    
    // Search and filter components
    private TextField searchField;
    private ToggleButton criticalToggle;
    private ToggleButton warningToggle;
    private ToggleButton infoToggle;
    
    // Status bar
    private Label statusBar;
    
    // AI review components
    private TextArea aiSuggestionArea;
    private SplitPane codeSplitPane;
    private ProgressIndicator aiProgressIndicator;

    public MainView(MainController controller) {
        this.controller = controller;
    }

    public void start(Stage primaryStage) {
        this.primaryStage = primaryStage;
        primaryStage.setTitle("Java Code Reviewer");
        
        // Set minimum window size for usability
        primaryStage.setMinWidth(800);
        primaryStage.setMinHeight(600);

        BorderPane root = new BorderPane();
        root.setPrefSize(1400, 900);
        
        codeArea = new CodeArea();
        codeArea.setEditable(false);
        codeArea.setWrapText(false);
        // Do not set paragraph graphic factory here; set it only when code is loaded
        codeArea.getStyleClass().add("code-area");

        // Create heatmap pane with better sizing
        heatmapPane = new VBox();
        heatmapPane.setPrefWidth(25);
        heatmapPane.setMinWidth(25);
        heatmapPane.setMaxWidth(25);
        heatmapPane.getStyleClass().add("heatmap-pane");
        
        // Set proper growth behavior for code area
        codeArea.setMinWidth(400);
        codeArea.setPrefWidth(3000);
        HBox.setHgrow(codeArea, javafx.scene.layout.Priority.ALWAYS);
        
        // Create HBox to hold code area and heatmap with proper spacing
        HBox codeAndHeatmap = new HBox();
        codeAndHeatmap.getChildren().addAll(codeArea, heatmapPane);
        codeAndHeatmap.setSpacing(5);
        codeAndHeatmap.getStyleClass().add("code-heatmap-container");
        HBox.setHgrow(codeAndHeatmap, javafx.scene.layout.Priority.ALWAYS);
        
        // Initialize AI suggestion area
        aiSuggestionArea = new TextArea();
        aiSuggestionArea.setEditable(false);
        aiSuggestionArea.setWrapText(true);
        aiSuggestionArea.setPrefRowCount(10);
        aiSuggestionArea.setVisible(false);
        aiSuggestionArea.getStyleClass().add("ai-suggestion-area");
        
        // Progress indicator for AI review
        aiProgressIndicator = new ProgressIndicator();
        aiProgressIndicator.setMaxSize(20, 20);
        aiProgressIndicator.setVisible(false);

        // Create button for AI review
        Button reviewButton = new Button("🤖 AI Code Review");
        reviewButton.getStyleClass().add("ai-button");
        reviewButton.setOnAction(e -> requestAiReview());
        
        HBox aiButtonBox = new HBox(5, reviewButton, aiProgressIndicator);
        aiButtonBox.setAlignment(javafx.geometry.Pos.CENTER_RIGHT);
        aiButtonBox.setPadding(new Insets(5));
        
        // Create vertical split for code and AI area with proper resize behavior
        codeSplitPane = new SplitPane();
        codeSplitPane.setOrientation(javafx.geometry.Orientation.VERTICAL);
        VBox.setVgrow(codeSplitPane, javafx.scene.layout.Priority.ALWAYS);
        
        // Add a VBox to properly manage the code area and AI suggestion area
        VBox codeContainer = new VBox();
        codeContainer.getChildren().addAll(aiButtonBox, codeAndHeatmap);
        VBox.setVgrow(codeAndHeatmap, javafx.scene.layout.Priority.ALWAYS);
        
        // Setup AI suggestion area with proper resize behavior
        VBox aiContainer = new VBox();
        aiContainer.getChildren().add(aiSuggestionArea);
        VBox.setVgrow(aiSuggestionArea, javafx.scene.layout.Priority.ALWAYS);
        
        codeSplitPane.getItems().addAll(codeContainer, aiContainer);
        codeSplitPane.setDividerPositions(0.7);
        codeSplitPane.getStyleClass().add("code-split-pane");

        // Initialize collections and filtered lists
        errors = FXCollections.observableArrayList();
        suggestions = FXCollections.observableArrayList();
        filteredErrors = new FilteredList<>(errors, p -> true);
        filteredSuggestions = new FilteredList<>(suggestions, p -> true);
        
        // Create and configure error TableView
        errorTableView = new TableView<>(filteredErrors);
        TableColumn<CodeIssue, Integer> errorLineCol = new TableColumn<>("Line");
        TableColumn<CodeIssue, String> errorSeverityCol = new TableColumn<>("Severity");
        TableColumn<CodeIssue, String> errorMessageCol = new TableColumn<>("Message");
        
        errorLineCol.setCellValueFactory(new PropertyValueFactory<>("lineNumber"));
        errorSeverityCol.setCellValueFactory(new PropertyValueFactory<>("severity"));
        errorMessageCol.setCellValueFactory(new PropertyValueFactory<>("message"));
        
        errorTableView.getColumns().add(errorLineCol);
        errorTableView.getColumns().add(errorSeverityCol);
        errorTableView.getColumns().add(errorMessageCol);
        errorTableView.setPrefHeight(200);
        errorTableView.setMinHeight(150);
        errorTableView.getStyleClass().add("table-view");
        
        // Create and configure suggestion TableView
        suggestionTableView = new TableView<>(filteredSuggestions);
        TableColumn<CodeIssue, Integer> suggLineCol = new TableColumn<>("Line");
        TableColumn<CodeIssue, String> suggMessageCol = new TableColumn<>("Message");
        
        suggLineCol.setCellValueFactory(new PropertyValueFactory<>("lineNumber"));
        suggMessageCol.setCellValueFactory(new PropertyValueFactory<>("message"));
        
        suggestionTableView.getColumns().add(suggLineCol);
        suggestionTableView.getColumns().add(suggMessageCol);
        suggestionTableView.setPrefHeight(250);
        suggestionTableView.setMinHeight(200);
        suggestionTableView.getStyleClass().add("table-view");
        
        // Add selection listeners
        errorTableView.setOnMouseClicked(this::onIssueClicked);
        suggestionTableView.setOnMouseClicked(this::onIssueClicked);
        
        // Create filter controls
        searchField = new TextField();
        searchField.setPromptText("Search issues...");
        searchField.getStyleClass().add("search-field");
        
        criticalToggle = new ToggleButton("Critical");
        warningToggle = new ToggleButton("Warning");
        infoToggle = new ToggleButton("Info");
        
        HBox filterBox = new HBox(8);
        filterBox.getChildren().addAll(
            searchField,
            new Separator(javafx.geometry.Orientation.VERTICAL),
            criticalToggle, warningToggle, infoToggle
        );
        filterBox.setAlignment(javafx.geometry.Pos.CENTER_LEFT);
        filterBox.getStyleClass().add("filter-box");
        
        // Setup filter listeners
        setupFilterListeners();

        // Enhanced headers with icons
        Label errorHeader = new Label("🚨 Critical Issues");
        errorHeader.getStyleClass().add("section-header");
        errorHeader.getStyleClass().add("error-header");
        
        Label suggestionHeader = new Label("💡 Suggestions");
        suggestionHeader.getStyleClass().add("section-header");
        suggestionHeader.getStyleClass().add("suggestion-header");

        detailsHeader = new Label("📋 Issue Details");
        detailsHeader.getStyleClass().add("section-header");
        detailsHeader.getStyleClass().add("details-header");
        
        detailsArea = new TextArea();
        detailsArea.setEditable(false);
        detailsArea.setWrapText(true);
        detailsArea.setPrefRowCount(8);
        detailsArea.setMinHeight(120);
        detailsArea.getStyleClass().add("details-area");

        // Improved right pane layout with better spacing
        VBox rightPane = new VBox();
        rightPane.setSpacing(15);
        rightPane.setPadding(new Insets(15));
        rightPane.getChildren().addAll(
            errorHeader, filterBox, errorTableView, 
            suggestionHeader, suggestionTableView, 
            detailsHeader, detailsArea
        );
        rightPane.getStyleClass().add("right-pane");
        rightPane.setMaxWidth(400);
        rightPane.setPrefWidth(350);
        rightPane.setMinWidth(300);

        // Main split pane with better proportions
        SplitPane mainSplitPane = new SplitPane();
        mainSplitPane.getItems().addAll(codeSplitPane, rightPane);
        mainSplitPane.setDividerPositions(0.7);
        mainSplitPane.getStyleClass().add("main-split-pane");
        
        // Set proper growth behavior for the code area side of the split pane
        codeSplitPane.setMinWidth(500);
        codeSplitPane.setPrefWidth(1000);
        SplitPane.setResizableWithParent(codeSplitPane, true);
        SplitPane.setResizableWithParent(rightPane, false);

        MenuBar menuBar = new MenuBar();
        Menu fileMenu = new Menu("File");
        // Create menu items with icons
        MenuItem openItem = new MenuItem("Open Java File...");
        FontIcon openIcon = new FontIcon(FontAwesomeSolid.FOLDER_OPEN);
        openIcon.setIconSize(16);
        openItem.setGraphic(openIcon);
        openItem.setAccelerator(new KeyCodeCombination(KeyCode.O, KeyCombination.SHORTCUT_DOWN));
        openItem.setOnAction(e -> controller.onOpenFile(primaryStage));
        
        MenuItem exportItem = new MenuItem("Export Analysis as Markdown");
        FontIcon exportIcon = new FontIcon(FontAwesomeSolid.DOWNLOAD);
        exportIcon.setIconSize(16);
        exportItem.setGraphic(exportIcon);
        exportItem.setAccelerator(new KeyCodeCombination(KeyCode.E, KeyCombination.SHORTCUT_DOWN));
        exportItem.setOnAction(e -> exportAnalysisAsMarkdown());
        fileMenu.getItems().addAll(openItem, exportItem);
        
        // Create AI menu
        Menu aiMenu = new Menu("AI");
        MenuItem toggleAiItem = new MenuItem("Toggle AI Suggestion Panel");
        FontIcon aiIcon = new FontIcon(FontAwesomeSolid.ROBOT);
        aiIcon.setIconSize(16);
        toggleAiItem.setGraphic(aiIcon);
        toggleAiItem.setOnAction(e -> toggleAiSuggestionPanel());
        aiMenu.getItems().add(toggleAiItem);
        
        // Create Edit menu for undo/redo
        Menu editMenu = new Menu("Edit");
        MenuItem undoItem = new MenuItem("Undo");
        undoItem.setAccelerator(new KeyCodeCombination(KeyCode.Z, KeyCombination.SHORTCUT_DOWN));
        undoItem.setOnAction(e -> {
            statusBar.setText("Undo/Redo functionality has been moved to the backend server");
        });
        FontIcon undoIcon = new FontIcon(FontAwesomeSolid.UNDO);
        undoIcon.setIconSize(16);
        undoItem.setGraphic(undoIcon);
        
        MenuItem redoItem = new MenuItem("Redo");
        redoItem.setAccelerator(new KeyCodeCombination(KeyCode.Z, KeyCombination.SHORTCUT_DOWN, KeyCombination.SHIFT_DOWN));
        redoItem.setOnAction(e -> {
            statusBar.setText("Undo/Redo functionality has been moved to the backend server");
        });
        FontIcon redoIcon = new FontIcon(FontAwesomeSolid.REDO);
        redoIcon.setIconSize(16);
        redoItem.setGraphic(redoIcon);
        
        editMenu.getItems().addAll(undoItem, redoItem);
        
        menuBar.getMenus().addAll(fileMenu, editMenu, aiMenu);
        menuBar.getStyleClass().add("menu-bar");

        // Add the AI button to the code area header
        HBox codeHeader = new HBox();
        codeHeader.setAlignment(javafx.geometry.Pos.CENTER_RIGHT);
        codeHeader.getChildren().add(aiButtonBox);
        codeHeader.setPadding(new Insets(5, 10, 5, 10));
        codeHeader.setSpacing(10);
        
        VBox codeContainerWithHeader = new VBox(codeHeader, mainSplitPane);
        VBox.setVgrow(mainSplitPane, javafx.scene.layout.Priority.ALWAYS);
        
        // Create and setup status bar
        statusBar = new Label("Ready");
        statusBar.getStyleClass().add("status-bar");
        
        root.setTop(menuBar);
        root.setCenter(codeContainerWithHeader);
        root.setBottom(statusBar);

        Scene scene = new Scene(root);
        scene.getStylesheets().add(getClass().getResource("/app-theme.css").toExternalForm());
        scene.getStylesheets().add(getClass().getResource("/ai-style.css").toExternalForm());

        // Add keyboard shortcuts for undo/redo
        scene.getAccelerators().put(
            new KeyCodeCombination(KeyCode.Z, KeyCombination.SHORTCUT_DOWN),
            () -> statusBar.setText("Undo/Redo functionality has been moved to the backend server")
        );
        
        scene.getAccelerators().put(
            new KeyCodeCombination(KeyCode.Z, KeyCombination.SHORTCUT_DOWN, KeyCombination.SHIFT_DOWN),
            () -> statusBar.setText("Undo/Redo functionality has been moved to the backend server")
        );
        
        primaryStage.setScene(scene);
        primaryStage.setMinWidth(1200);
        primaryStage.setMinHeight(800);
        primaryStage.show();
    }

    public void displayCode(String code) {
        codeArea.replaceText(code);
        codeArea.setParagraphGraphicFactory(LineNumberFactory.get(codeArea));
        clearAllLineHighlights();
        onCodeLoaded();
    }

    public void displayError(String message) {
        errors.clear();
        suggestions.clear();
    }

    public void clearCodeArea() {
        codeArea.clear();
        codeArea.setParagraphGraphicFactory(null);
    }

    public void displayAnalysisResult(CodeAnalysisResult result) {
        errors.setAll(result.getErrors()); // Show errors in the list
        suggestions.setAll(result.getSuggestions());
        clearAllLineHighlights();
        errorTooltips.clear();
        for (CodeIssue issue : result.getErrors()) {
            String styleClass = getHighlightClass(issue);
            highlightLine(issue.getLine(), styleClass);
            errorTooltips.put(issue.getLine(), issue.getMessage());
        }
        // Set paragraph graphic factory for tooltips
        codeArea.setParagraphGraphicFactory(line -> {
            int lineNum = line + 1;
            Text lineNo = new Text(String.valueOf(lineNum));
            StackPane graphic = new StackPane(lineNo);
            graphic.getStyleClass().add("lineno-graphic");
            if (errorTooltips.containsKey(lineNum)) {
                Tooltip tooltip = new Tooltip(errorTooltips.get(lineNum));
                tooltip.setShowDelay(Duration.millis(100));
                Tooltip.install(graphic, tooltip);
                // Add severity class for color
                String severityClass = "";
                String msg = errorTooltips.get(lineNum).toLowerCase();
                if (msg.contains("critical")) severityClass = "critical-error-highlight";
                else if (msg.contains("warning")) severityClass = "warning-highlight";
                else if (msg.contains("info")) severityClass = "info-highlight";
                if (!severityClass.isEmpty()) graphic.getStyleClass().add(severityClass);
            }
            return graphic;
        });
        for (CodeIssue issue : suggestions) {
            if (issue.getType() == CodeIssue.Type.SUGGESTION) {
                highlightLine(issue.getLine(), "suggestion-highlight");
            }
        }
        
        // Render heatmap
        renderHeatmap(result);
    }

    private String getHighlightClass(CodeIssue issue) {
        if ("critical".equalsIgnoreCase(issue.getSeverity())) {
            return "critical-error-highlight";
        } else if ("warning".equalsIgnoreCase(issue.getSeverity())) {
            return "warning-highlight";
        } else if ("info".equalsIgnoreCase(issue.getSeverity())) {
            return "info-highlight";
        } else {
            return "long-method-highlight";
        }
    }



    private void setupFilterListeners() {
        // Setup search field listener
        searchField.textProperty().addListener((obs, oldVal, newVal) -> {
            String searchText = newVal.toLowerCase();
            filteredErrors.setPredicate(issue -> 
                issue.getMessage().toLowerCase().contains(searchText) &&
                matchesSeverityFilter(issue)
            );
            filteredSuggestions.setPredicate(issue ->
                issue.getMessage().toLowerCase().contains(searchText)
            );
        });

        // Setup severity toggle listeners
        ToggleButton[] toggles = {criticalToggle, warningToggle, infoToggle};
        for (ToggleButton toggle : toggles) {
            toggle.setSelected(true);
            toggle.selectedProperty().addListener((obs, oldVal, newVal) -> {
                filteredErrors.setPredicate(issue ->
                    issue.getMessage().toLowerCase().contains(searchField.getText().toLowerCase()) &&
                    matchesSeverityFilter(issue)
                );
            });
        }
    }

    private boolean matchesSeverityFilter(CodeIssue issue) {
        String severity = issue.getSeverity().toLowerCase();
        return (severity.equals("critical") && criticalToggle.isSelected()) ||
               (severity.equals("warning") && warningToggle.isSelected()) ||
               (severity.equals("info") && infoToggle.isSelected());
    }

    private void onIssueClicked(MouseEvent event) {
        Object source = event.getSource();
        if (!(source instanceof TableView<?>)) {
            return;
        }
        @SuppressWarnings("unchecked")
        TableView<CodeIssue> tableView = (TableView<CodeIssue>) source;
        CodeIssue selected = tableView.getSelectionModel().getSelectedItem();
        if (selected != null && selected.getLine() > 0) {
            // Clear any previous selected highlights first
            clearAllLineHighlights();
            // Re-apply all issue highlights
            for (CodeIssue issue : errors) {
                String styleClass = getHighlightClass(issue);
                highlightLine(issue.getLine(), styleClass);
            }
            for (CodeIssue issue : suggestions) {
                if (issue.getType() == CodeIssue.Type.SUGGESTION) {
                    highlightLine(issue.getLine(), "suggestion-highlight");
                }
            }
            // Now highlight the selected line
            highlightLine(selected.getLine(), "selected-issue-highlight");
            showIssueDetails(selected);
            
            // Scroll to the selected line and center it in the viewport
            Platform.runLater(() -> {
                codeArea.showParagraphAtCenter(selected.getLine() - 1);
                // Also request focus on the code area for better UX
                codeArea.requestFocus();
            });
        }
    }

    private void showIssueDetails(CodeIssue issue) {
        // Create a VBox to hold both the details and quick fix buttons
        VBox detailsContainer = new VBox(10); // 10px spacing
        
        // Add the text details
        StringBuilder sb = new StringBuilder();
        sb.append("Line: ").append(issue.getLine()).append("\n");
        sb.append("Type: ").append(issue.getType()).append("\n");
        sb.append("Severity: ").append(issue.getSeverity()).append("\n");
        sb.append("Message: ").append(issue.getMessage()).append("\n");
        
        TextArea textDetails = new TextArea(sb.toString());
        textDetails.setEditable(false);
        textDetails.setWrapText(true);
        textDetails.setPrefRowCount(4);
        
        detailsContainer.getChildren().add(textDetails);
        
        // If there are quick fixes available, add buttons for them
        if (issue.hasQuickFixes()) {
            HBox quickFixButtons = new HBox(5); // 5px spacing
            quickFixButtons.setAlignment(Pos.CENTER_LEFT);
            
            for (QuickFix fix : issue.getQuickFixes()) {
                Button fixButton = new Button(fix.getDescription());
                fixButton.getStyleClass().add("quick-fix-button");
                
                // Add tooltip with detailed description
                Tooltip tooltip = new Tooltip(fix.getDescription());
                tooltip.setShowDelay(Duration.millis(200));
                fixButton.setTooltip(tooltip);
                
                // Add click handler
                fixButton.setOnAction(e -> applyQuickFix(issue, fix));
                
                quickFixButtons.getChildren().add(fixButton);
            }
            
            detailsContainer.getChildren().add(quickFixButtons);
        }
        
        detailsArea.setText(sb.toString());
    }

    private void highlightLine(int lineNumber, String styleClass) {
        if (lineNumber < 1) return;
        int start = codeArea.position(lineNumber - 1, 0).toOffset();
        int end = codeArea.position(lineNumber - 1, codeArea.getParagraph(lineNumber - 1).length()).toOffset();
        codeArea.setStyleClass(start, end, styleClass);
    }

    private void clearAllLineHighlights() {
        codeArea.setStyleSpans(0, codeArea.getStyleSpans(0, codeArea.getLength()));
    }
    
    private void renderHeatmap(CodeAnalysisResult result) {
        // Clear existing heatmap
        heatmapPane.getChildren().clear();
        
        // Get total number of lines
        int totalLines = codeArea.getParagraphs().size();
        
        // Create a map to track issue density per line
        Map<Integer, String> lineSeverity = new HashMap<>();
        
        // Process all issues and determine severity for each line
        for (CodeIssue issue : result.getErrors()) {
            int lineNum = issue.getLine();
            String currentSeverity = lineSeverity.get(lineNum);
            String issueSeverity = issue.getSeverity();
            
            // Prioritize severity: critical > warning > info
            if (currentSeverity == null || 
                (issueSeverity.equalsIgnoreCase("critical") && !currentSeverity.equalsIgnoreCase("critical")) ||
                (issueSeverity.equalsIgnoreCase("warning") && currentSeverity.equalsIgnoreCase("info"))) {
                lineSeverity.put(lineNum, issueSeverity);
            }
        }
        
        // Create rectangles for each line
        for (int lineNumber = 1; lineNumber <= totalLines; lineNumber++) {
            Rectangle rect = new Rectangle();
            rect.setHeight(3);
            rect.setWidth(25); // Match the heatmap pane width
            
            // Set color based on severity
            String severity = lineSeverity.get(lineNumber);
            if (severity != null) {
                if (severity.equalsIgnoreCase("critical")) {
                    rect.setFill(javafx.scene.paint.Color.web("#dc2626"));
                } else if (severity.equalsIgnoreCase("warning")) {
                    rect.setFill(javafx.scene.paint.Color.web("#fbbf24"));
                } else {
                    rect.setFill(javafx.scene.paint.Color.web("#60a5fa"));
                }
            } else {
                rect.setFill(javafx.scene.paint.Color.web("#34d399"));
            }
            
            // Add click handler to scroll to line
            final int lineNum = lineNumber;
            rect.setOnMouseClicked(e -> codeArea.showParagraphAtTop(lineNum - 1));
            
            heatmapPane.getChildren().add(rect);
        }
    }

    private void exportAnalysisAsMarkdown() {
        if (errors.isEmpty() && suggestions.isEmpty()) {
            statusBar.setText("No analysis to export");
            return;
        }
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Save Analysis Report");
        fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter("Markdown Files", "*.md"));
        File file = fileChooser.showSaveDialog(primaryStage);
        if (file != null) {
            try (FileWriter writer = new FileWriter(file)) {
                writer.write("# Code Analysis Report\n\n");
                writer.write("## Errors\n");
                for (CodeIssue issue : errors) {
                    writer.write("- Line " + issue.getLine() + " [" + issue.getSeverity() + "]: " + issue.getMessage() + "\n");
                }
                writer.write("\n## Suggestions\n");
                for (CodeIssue issue : suggestions) {
                    writer.write("- Line " + issue.getLine() + ": " + issue.getMessage() + "\n");
                }
                statusBar.setText("Analysis exported to " + file.getName());
            } catch (IOException ex) {
                statusBar.setText("Failed to export: " + ex.getMessage());
            }
        }
    }

    public String getCurrentCode() {
        return codeArea.getText();
    }
    
    public void replaceCodeText(String newCode) {
        codeArea.replaceText(newCode);
    }
    
    /**
     * Toggle visibility of the AI suggestion panel
     */
    public void toggleAiSuggestionPanel() {
        boolean isVisible = aiSuggestionArea.isVisible();
        
        FadeTransition fade = new FadeTransition(Duration.millis(300), aiSuggestionArea);
        fade.setFromValue(isVisible ? 1.0 : 0.0);
        fade.setToValue(isVisible ? 0.0 : 1.0);
        
        if (isVisible) {
            fade.setOnFinished(e -> {
                aiSuggestionArea.setVisible(false);
                codeSplitPane.setDividerPositions(1.0);
            });
        } else {
            aiSuggestionArea.setVisible(true);
            aiSuggestionArea.setOpacity(0);
            codeSplitPane.setDividerPositions(0.7);
            if (aiSuggestionArea.getText().isEmpty()) {
                aiSuggestionArea.setText("Ask AI for suggestions about your code by clicking the 'Ask AI' button.");
            }
        }
        
        fade.play();
        
        // Update status bar
        statusBar.setText(isVisible ? "AI suggestion panel hidden" : "AI suggestion panel shown");
    }
    
    /**
     * Show loading indicator while waiting for AI response
     */
    public void showAiLoading() {
        aiProgressIndicator.setVisible(true);
    }
    
    /**
     * Hide loading indicator
     */
    public void hideAiLoading() {
        aiProgressIndicator.setVisible(false);
    }
    
    /**
     * Show AI suggestion in the panel and ensure it's visible
     */
    public void showAiSuggestion(String suggestion) {
        aiSuggestionArea.setText(suggestion);
        if (!aiSuggestionArea.isVisible()) {
            aiSuggestionArea.setVisible(true);
            codeSplitPane.setDividerPositions(0.7);
        }
    }
    
    /**
     * Append to the AI suggestion text (for streaming responses)
     */
    public void appendAiSuggestion(String text) {
        aiSuggestionArea.appendText(text);
        if (!aiSuggestionArea.isVisible()) {
            aiSuggestionArea.setVisible(true);
            codeSplitPane.setDividerPositions(0.7);
        }
    }
    
    /**
     * Clear the AI suggestion panel
     */
    public void clearAiSuggestion() {
        aiSuggestionArea.clear();
    }
    
    /**
     * Applies a quick fix to the code and updates the UI.
     * @param issue The issue to fix
     * @param fix The quick fix to apply
     */
    private void applyQuickFix(CodeIssue issue, QuickFix fix) {
        statusBar.setText("Quick fix functionality has been moved to the backend server");
        
        // In a real implementation, this would send a request to the backend
        // to apply the quick fix and then update the UI with the result
        
        logger.info("Quick fix requested: " + fix.getDescription() + " for issue: " + issue.getMessage());
    }
    
    /**
     * Update the UI when code is loaded
     */
    public void onCodeLoaded() {
        aiSuggestionArea.setVisible(true);
    }
    
    /**
     * Request a full AI review of the code
     */
    private void requestAiReview() {
        String code = getCurrentCode();
        if (code == null || code.trim().isEmpty()) {
            displayError("No code to analyze");
            return;
        }
        
        showAiLoading();
        clearAiSuggestion();
        
        // Show AI suggestion area with initial message
        aiSuggestionArea.setVisible(true);
        codeSplitPane.setDividerPositions(0.7);
        appendAiSuggestion("Initializing AI code review...\n\n");
        
        // Use the controller's method which now talks to the backend
        String reviewPrompt = "Please provide a comprehensive code review focusing on:\n" +
                             "1. Code quality issues\n" +
                             "2. Performance optimizations\n" +
                             "3. Security concerns\n" +
                             "4. Best practices recommendations\n\n" +
                             "FORMAT: Provide a structured review with specific line numbers where applicable. Start with a brief summary.";
        
        // Use the controller's AI method which now uses the API client
        controller.onAskAiWithQuestion(code, reviewPrompt);
    }
}
</file>

<file path="frontend/src/main/java/com/reviewer/codereviewer/MainApp.java">
package com.reviewer.codereviewer;

import com.reviewer.codereviewer.controller.MainController;
import com.reviewer.codereviewer.ui.ModernMainView;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.util.logging.Logger;

public class MainApp extends Application {
    private static final Logger logger = Logger.getLogger(MainApp.class.getName());
    
    @Override
    public void start(Stage primaryStage) {
        try {
            logger.info("Starting CodeReviewer Frontend Application");
            
            // Create main controller
            MainController controller = new MainController();
            
            // Create and configure the modern view
            ModernMainView modernView = new ModernMainView(controller);
            controller.setModernView(modernView);
            
            // Create and show the scene
            Scene scene = modernView.createScene();
            primaryStage.setTitle("CodeReviewer - Frontend Client");
            primaryStage.setScene(scene);
            primaryStage.setResizable(true);
            primaryStage.setMaximized(true);
            primaryStage.show();
            
            logger.info("Application started successfully");
            
            // Show a status message about backend connection
            modernView.displayError("Frontend application started. Connecting to backend server...");
            
        } catch (Exception e) {
            logger.severe("Application startup failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        try {
            logger.info("Launching CodeReviewer Frontend Client");
            launch(args);
        } catch (Exception e) {
            logger.severe("Application startup failed: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
}
</file>

<file path="frontend/src/main/resources/ai-style.css">
/* AI Suggestion Area Styling */
.ai-suggestion-area {
    -fx-font-size: 14px;
    -fx-background-color: linear-gradient(to bottom, #f8fafc 0%, #f1f5f9 100%);
    -fx-border-color: #6366f1;
    -fx-border-width: 2px;
    -fx-padding: 20px;
    -fx-background-radius: 12px;
    -fx-border-radius: 12px;
    -fx-text-fill: #1e293b;
    -fx-effect: dropshadow(three-pass-box, rgba(99,102,241,0.2), 16, 0.3, 0, 4);
    -fx-font-family: 'Inter', 'Segoe UI', sans-serif;
}

.ai-suggestion-area:focused {
    -fx-border-color: #4f46e5;
    -fx-effect: dropshadow(three-pass-box, rgba(79,70,229,0.3), 20, 0.4, 0, 6);
}

/* AI Button Styling */
.ai-button {
    -fx-font-size: 14px;
    -fx-background-color: linear-gradient(to right, #6366f1 0%, #4f46e5 100%);
    -fx-text-fill: white;
    -fx-padding: 10px 16px;
    -fx-background-radius: 10px;
    -fx-border-radius: 10px;
    -fx-font-weight: 600;
    -fx-cursor: hand;
    -fx-effect: dropshadow(gaussian, rgba(99,102,241,0.4), 8, 0.3, 0, 3);
    -fx-border-color: transparent;
}

.ai-button:hover {
    -fx-background-color: linear-gradient(to right, #4f46e5 0%, #4338ca 100%);
    -fx-effect: dropshadow(gaussian, rgba(79,70,229,0.5), 12, 0.4, 0, 4);
    -fx-scale-y: 1.02;
    -fx-scale-x: 1.02;
}

.ai-button:disabled {
    -fx-opacity: 0.7;
    -fx-background-color: #9ca3af;
    -fx-text-fill: #f3f4f6;
    -fx-effect: none;
}
</file>

<file path="frontend/src/main/resources/app-theme.css">
/* Modern Enhanced Theme for Code Reviewer */
.root {
    -fx-background-color: linear-gradient(to bottom, #f8fafc 0%, #e2e8f0 100%);
    -fx-font-family: 'Segoe UI', 'Roboto', 'Inter', sans-serif;
    -fx-text-fill: #1e293b;
    -fx-focus-color: transparent;
    -fx-faint-focus-color: transparent;
}

/* Enhanced Menu System */
.menu-bar {
    -fx-background-color: linear-gradient(to bottom, #ffffff 0%, #f1f5f9 100%);
    -fx-border-color: #cbd5e1;
    -fx-border-width: 0 0 1px 0;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.08), 8, 0.2, 0, 2);
    -fx-padding: 4 0;
}

.menu {
    -fx-background-color: transparent;
    -fx-text-fill: #334155;
    -fx-padding: 10 18;
    -fx-font-size: 14px;
    -fx-font-weight: 500;
}

.menu:hover, .menu:showing {
    -fx-background-color: #e0e7ff;
    -fx-text-fill: #4338ca;
    -fx-background-radius: 6px;
}

.context-menu {
    -fx-background-color: #ffffff;
    -fx-border-color: #e2e8f0;
    -fx-border-radius: 8px;
    -fx-background-radius: 8px;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.15), 12, 0.3, 0, 4);
    -fx-padding: 6px 0;
}

.menu-item {
    -fx-background-color: transparent;
    -fx-text-fill: #374151;
    -fx-padding: 10 20;
    -fx-font-size: 14px;
    -fx-background-radius: 6px;
}

.menu-item:focused, .menu-item:hover {
    -fx-background-color: #f0f9ff;
    -fx-text-fill: #0ea5e9;
    -fx-font-weight: 500;
}

/* Enhanced Code Area - Better Expansion */
.code-area {
    -fx-background-color: #ffffff;
    -fx-text-fill: #374151;
    -fx-highlight-fill: #dbeafe;
    -fx-highlight-text-fill: #1e40af;
    -fx-font-size: 14px;
    -fx-font-family: 'JetBrains Mono', 'Consolas', 'Monaco', monospace;
    -fx-border-radius: 12px;
    -fx-background-radius: 12px;
    -fx-padding: 10px;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.1), 16, 0.2, 0, 4);
    -fx-border-color: #e2e8f0;
    -fx-border-width: 1px;
    -fx-pref-width: 1000px;  /* Ensure code area expands properly */
    -fx-max-width: 5000px;   /* Allow extensive horizontal expansion */
}

.code-area:focused {
    -fx-border-color: #3b82f6;
    -fx-effect: dropshadow(three-pass-box, rgba(59,130,246,0.3), 20, 0.3, 0, 6);
}

/* Enhanced Code and Heatmap Container - Fix Expansion Issues */
.code-heatmap-container {
    -fx-background-color: transparent;
    -fx-padding: 10;
    -fx-background-radius: 12px;
    -fx-pref-width: 5000px; /* Allow the container to expand fully */
    -fx-min-width: 800px;   /* Ensure minimum reasonable width */
    -fx-hgrow: ALWAYS;      /* Horizontal growth priority */
}

/* Improved Split Panes */
.code-split-pane {
    -fx-background-color: transparent;
    -fx-padding: 0;
}

.code-split-pane .split-pane-divider {
    -fx-background-color: #cbd5e1;
    -fx-padding: 0 0 2 0;
}

.main-split-pane {
    -fx-background-color: transparent;
    -fx-padding: 0;
}

.main-split-pane .split-pane-divider {
    -fx-background-color: #e2e8f0;
    -fx-padding: 0 2 0 0;
}

/* Enhanced List Views */
.list-view {
    -fx-background-color: #ffffff;
    -fx-control-inner-background: #ffffff;
    -fx-border-radius: 10px;
    -fx-background-radius: 10px;
    -fx-padding: 8px 0;
    -fx-border-color: #e2e8f0;
    -fx-border-width: 1px;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.08), 12, 0.2, 0, 3);
}

.list-cell {
    -fx-background-color: transparent;
    -fx-text-fill: #374151;
    -fx-padding: 12px 16px;
    -fx-border-radius: 6px;
    -fx-font-size: 13px;
    -fx-background-radius: 6px;
}

.list-cell:hover {
    -fx-background-color: #f8fafc;
    -fx-text-fill: #1e40af;
}

.list-cell:selected, .list-cell:focused {
    -fx-background-color: linear-gradient(to right, #dbeafe 0%, #f0f9ff 100%);
    -fx-text-fill: #1e40af;
    -fx-font-weight: 600;
    -fx-border-color: #3b82f6;
    -fx-border-width: 0 0 0 3px;
}

/* Enhanced Section Headers */
.section-header {
    -fx-font-size: 16px;
    -fx-font-weight: 700;
    -fx-text-fill: #1e293b;
    -fx-padding: 12px 0 8px 0;
    -fx-background-color: transparent;
    -fx-border-color: #e2e8f0;
    -fx-border-width: 0 0 1px 0;
}

.error-header {
    -fx-text-fill: #dc2626;
}

.suggestion-header {
    -fx-text-fill: #059669;
}

.details-header {
    -fx-text-fill: #7c3aed;
}

/* Issue Highlighting */
.critical-error-highlight {
    -fx-background-color: #fef2f2;
    -fx-text-fill: #dc2626;
    -fx-font-weight: 600;
    -fx-border-color: #fca5a5;
    -fx-border-width: 0 0 0 3px;
}

.warning-highlight {
    -fx-background-color: #fffbeb;
    -fx-text-fill: #d97706;
    -fx-border-color: #fbbf24;
    -fx-border-width: 0 0 0 3px;
}

.info-highlight {
    -fx-background-color: #eff6ff;
    -fx-text-fill: #2563eb;
    -fx-border-color: #60a5fa;
    -fx-border-width: 0 0 0 3px;
}

.suggestion-highlight {
    -fx-background-color: #f0fdf4;
    -fx-text-fill: #059669;
    -fx-border-color: #34d399;
    -fx-border-width: 0 0 0 3px;
}

.selected-issue-highlight {
    -fx-background-color: #e0e7ff;
    -fx-text-fill: #4338ca;
    -fx-font-weight: 700;
    -fx-effect: dropshadow(gaussian, rgba(67,56,202,0.4), 8, 0.5, 0, 0);
}

/* Long method and other specific highlights */
.long-method-highlight {
    -fx-background-color: #fef3c7;
    -fx-text-fill: #d97706;
    -fx-border-color: #fbbf24;
    -fx-border-width: 0 0 0 3px;
}

.deep-nesting-highlight {
    -fx-background-color: #fee2e2;
    -fx-text-fill: #dc2626;
    -fx-border-color: #fca5a5;
    -fx-border-width: 0 0 0 3px;
}

.empty-block-highlight {
    -fx-background-color: #f3f4f6;
    -fx-text-fill: #6b7280;
    -fx-border-color: #d1d5db;
    -fx-border-width: 0 0 0 3px;
}

.unused-import-highlight {
    -fx-background-color: #f0fdf4;
    -fx-text-fill: #059669;
    -fx-border-color: #34d399;
    -fx-border-width: 0 0 0 3px;
}

/* Enhanced Details Area */
.details-area {
    -fx-background-color: #ffffff;
    -fx-text-fill: #374151;
    -fx-font-size: 13px;
    -fx-border-radius: 10px;
    -fx-background-radius: 10px;
    -fx-border-color: #e2e8f0;
    -fx-border-width: 1px;
    -fx-padding: 16px;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.08), 12, 0.2, 0, 3);
    -fx-control-inner-background: #ffffff;
}

/* AI Suggestion Area has been removed */

/* Enhanced Buttons */
.button {
    -fx-background-color: linear-gradient(to bottom, #ffffff 0%, #f8fafc 100%);
    -fx-text-fill: #374151;
    -fx-border-color: #d1d5db;
    -fx-border-width: 1px;
    -fx-border-radius: 8px;
    -fx-background-radius: 8px;
    -fx-padding: 10px 16px;
    -fx-font-size: 13px;
    -fx-font-weight: 500;
    -fx-cursor: hand;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.05), 4, 0.2, 0, 1);
}

.button:hover {
    -fx-background-color: linear-gradient(to bottom, #f9fafb 0%, #f3f4f6 100%);
    -fx-text-fill: #1f2937;
    -fx-border-color: #9ca3af;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.1), 6, 0.3, 0, 2);
}

/* AI buttons have been removed */

/* Enhanced Containers */
.right-pane {
    -fx-background-color: linear-gradient(to bottom, #fefefe 0%, #f8fafc 100%);
    -fx-border-radius: 12px;
    -fx-background-radius: 12px;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.08), 16, 0.2, 0, 4);
}

/* Bottom bar has been removed */

/* Heatmap Styling */
.heatmap-pane {
    -fx-background-color: transparent;
    -fx-padding: 5px 0;
    -fx-spacing: 1;
}

/* Scrollbar Styling */
.scroll-bar:horizontal, .scroll-bar:vertical {
    -fx-background-color: transparent;
}

.scroll-bar .thumb {
    -fx-background-color: #cbd5e1;
    -fx-background-radius: 6px;
}

.scroll-bar .thumb:hover {
    -fx-background-color: #94a3b8;
}

.scroll-bar .thumb:pressed {
    -fx-background-color: #64748b;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-background-color: transparent;
}

/* Line Number Graphics */
.lineno-graphic {
    -fx-background-color: transparent;
    -fx-text-fill: #6b7280;
    -fx-font-size: 12px;
    -fx-padding: 2px 8px;
}
</file>

<file path="frontend/src/main/resources/application.properties">
# Application Configuration
spring.application.name=CodeReviewer
app.name=Code Reviewer
app.version=1.0.0
app.author=Himesh Raj

# Analysis Configuration
app.analysis.max-method-length=50
app.analysis.max-cyclomatic-complexity=10
app.analysis.enable-extended-review=true
analysis.max.file.size.mb=10
analysis.timeout.seconds=60
analysis.concurrent.files=4

# OpenRouter API Configuration
openrouter.api.key=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
openrouter.model.name=deepseek/deepseek-r1:free
openrouter.endpoint.url=https://openrouter.ai/api/v1/chat/completions
openrouter.timeout.seconds=30
openrouter.max.retries=3
openrouter.retry.delay.ms=1000

# Performance Settings
cache.enabled=true
cache.size=100
cache.ttl.minutes=30
thread.pool.core.size=4
thread.pool.max.size=8
thread.pool.keep.alive.seconds=60

# UI Settings
ui.theme=dark
ui.font.size=12
ui.auto.save=true
ui.syntax.highlighting=true

# Logging Configuration
logging.level.root=INFO
logging.level.com.reviewer.codereviewer=INFO
logging.file.enabled=true
logging.file.path=logs/application.log
logging.max.file.size=10MB
logging.max.files=5

# Metrics and Monitoring
metrics.enabled=true
metrics.collection.interval.seconds=60
metrics.retention.days=7

# Security Settings
security.api.key.validation=true
security.input.sanitization=true
security.max.request.size.mb=5

# Development Settings
dev.mode=false
dev.debug.enabled=false
dev.mock.ai.responses=false
</file>

<file path="frontend/src/main/resources/logging.properties">
# Logging configuration for CodeReviewer application

# Root logger level
.level = INFO

# Console handler
handlers = java.util.logging.ConsoleHandler, java.util.logging.FileHandler

# Console handler configuration
java.util.logging.ConsoleHandler.level = INFO
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter

# File handler configuration
java.util.logging.FileHandler.level = ALL
java.util.logging.FileHandler.pattern = logs/codereview-%g.log
java.util.logging.FileHandler.limit = 10485760
java.util.logging.FileHandler.count = 5
java.util.logging.FileHandler.formatter = java.util.logging.SimpleFormatter

# Application-specific loggers
com.reviewer.codereviewer.level = FINE
com.reviewer.codereviewer.service.AISuggestionService.level = INFO
com.reviewer.codereviewer.service.CodeAnalysisService.level = FINE

# Third-party library levels
org.apache.http.level = WARNING
okhttp3.level = WARNING

# Custom formatter for better readability
java.util.logging.SimpleFormatter.format = %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS [%4$s] %2$s: %5$s%6$s%n
</file>

<file path="frontend/src/main/resources/modern-theme.css">
/* Professional Modern UI Theme for Code Reviewer */

.root {
    -fx-background-color: #fafbfc;
    -fx-font-family: "SF Pro Display", "Inter", "Segoe UI", "Roboto", sans-serif;
    -fx-text-fill: #1c2532;
    -fx-focus-color: transparent;
    -fx-faint-focus-color: transparent;
    -fx-accent: #0066cc;
}

/* Main Layout Containers */
.main-container {
    -fx-background-color: #fafbfc;
    -fx-padding/* Status Bar */
.status-bar {
    -fx-background-color: #f8fafc;
    -fx-border-color: #e1e8ed;
    -fx-border-width: 1 0 0 0;
    -fx-padding: 8 16;
}

/* Issue Details Panel */
.issue-details-panel {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-width: 0 0 0 1;
    -fx-min-width: 300;
    -fx-pref-width: 350;
}

.issue-detail-title {
    -fx-font-size: 16px;
    -fx-font-weight: bold;
    -fx-text-fill: #1f2937;
}

.issue-severity {
    -fx-font-size: 12px;
    -fx-text-fill: #6b7280;
    -fx-font-weight: bold;
}

.issue-line {
    -fx-font-size: 12px;
    -fx-text-fill: #6b7280;
}

.detail-section-title {
    -fx-font-size: 13px;
    -fx-font-weight: bold;
    -fx-text-fill: #374151;
    -fx-padding: 8 0 4 0;
}

.issue-description {
    -fx-background-color: #f9fafb;
    -fx-border-color: #e5e7eb;
    -fx-border-radius: 4px;
    -fx-background-radius: 4px;
    -fx-font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
    -fx-font-size: 11px;
}

.quick-fix-item {
    -fx-text-fill: #059669;
    -fx-font-size: 12px;
    -fx-padding: 2 0;
}

.no-fixes-label {
    -fx-text-fill: #9ca3af;
    -fx-font-style: italic;
    -fx-font-size: 12px;
}

.code-context {
    -fx-background-color: #1f2937;
    -fx-text-fill: #f9fafb;
    -fx-border-color: #374151;
    -fx-border-radius: 4px;
    -fx-background-radius: 4px;
    -fx-font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
    -fx-font-size: 11px;
}

.close-button {
    -fx-background-color: transparent;
    -fx-border-color: transparent;
    -fx-text-fill: #6b7280;
    -fx-font-size: 14px;
    -fx-padding: 4;
    -fx-min-width: 24;
    -fx-min-height: 24;
}

.close-button:hover {
    -fx-background-color: #f3f4f6;
    -fx-text-fill: #374151;
}

.details-scroll {
    -fx-background-color: transparent;
    -fx-border-color: transparent;
}

.details-scroll .viewport {
    -fx-background-color: transparent;
}

/* Code Syntax Highlighting */
.keyword {
    -fx-fill: #0066cc;
    -fx-font-weight: bold;
}

.string {
    -fx-fill: #22863a;
}

.comment {
    -fx-fill: #6a737d;
    -fx-font-style: italic;
}

.number {
    -fx-fill: #005cc5;
}

/* Code Issue Highlighting */
.issue-critical {
    -fx-underline: true;
    -fx-background-color: rgba(220, 38, 38, 0.2);
    -fx-border-color: #dc2626;
    -fx-border-width: 0 0 2 0;
}

.issue-warning {
    -fx-underline: true;
    -fx-background-color: rgba(245, 158, 11, 0.2);
    -fx-border-color: #f59e0b;
    -fx-border-width: 0 0 2 0;
}

.issue-info {
    -fx-underline: true;
    -fx-background-color: rgba(59, 130, 246, 0.1);
    -fx-border-color: #3b82f6;
    -fx-border-width: 0 0 1 0;
}

/* Code Issue Highlighting */
.issue-critical {
    -fx-background-color: rgba(239, 68, 68, 0.15);
    -fx-border-color: #ef4444;
    -fx-border-width: 0 0 0 3;
}

.issue-warning {
    -fx-background-color: rgba(245, 158, 11, 0.15);
    -fx-border-color: #f59e0b;
    -fx-border-width: 0 0 0 3;
}

.issue-info {
    -fx-background-color: rgba(59, 130, 246, 0.15);
    -fx-border-color: #3b82f6;
    -fx-border-width: 0 0 0 3;
}

/* Syntax Highlighting */
.keyword {
    -fx-fill: #7c3aed;
    -fx-font-weight: bold;
}

.string {
    -fx-fill: #059669;
}

.comment {
    -fx-fill: #6b7280;
    -fx-font-style: italic;
}

.number {
    -fx-fill: #dc2626;
}
.header-bar {
    -fx-background-color: linear-gradient(to bottom, #ffffff 0%, #f8fafc 100%);
    -fx-border-color: #e1e8ed;
    -fx-border-width: 0 0 1px 0;
    -fx-padding: 12 24;
    -fx-spacing: 16;
    -fx-alignment: center-left;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.04), 4, 0.2, 0, 1);
}

.content-area {
    -fx-background-color: #fafbfc;
    -fx-padding: 16;
    -fx-spacing: 16;
}

/* Enhanced Menu System */
.menu-bar {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-width: 0 0 1px 0;
    -fx-padding: 0;
}

.menu {
    -fx-background-color: transparent;
    -fx-text-fill: #5a6c7d;
    -fx-padding: 12 20;
    -fx-font-size: 14px;
    -fx-font-weight: 500;
}

.menu:hover, .menu:showing {
    -fx-background-color: #f0f4f8;
    -fx-text-fill: #0066cc;
}

/* Professional Buttons */
.button {
    -fx-background-color: linear-gradient(to bottom, #ffffff 0%, #f8fafc 100%);
    -fx-border-color: #d1dce5;
    -fx-border-radius: 8px;
    -fx-background-radius: 8px;
    -fx-text-fill: #5a6c7d;
    -fx-font-size: 14px;
    -fx-font-weight: 500;
    -fx-padding: 12 20;
    -fx-cursor: hand;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.06), 2, 0.3, 0, 1);
}

.button:hover {
    -fx-background-color: linear-gradient(to bottom, #f8fafc 0%, #f1f5f9 100%);
    -fx-border-color: #0066cc;
    -fx-text-fill: #0066cc;
    -fx-effect: dropshadow(three-pass-box, rgba(0,102,204,0.15), 4, 0.4, 0, 2);
}

.button:pressed {
    -fx-background-color: #f1f5f9;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.1), 2, 0.3, 0, 1);
}

/* Primary Action Button */
.primary-button {
    -fx-background-color: linear-gradient(to bottom, #0066cc 0%, #0052a3 100%);
    -fx-border-color: #0052a3;
    -fx-text-fill: #ffffff;
    -fx-font-weight: 600;
}

.primary-button:hover {
    -fx-background-color: linear-gradient(to bottom, #0052a3 0%, #004080 100%);
    -fx-effect: dropshadow(three-pass-box, rgba(0,102,204,0.25), 6, 0.5, 0, 3);
}

/* AI Button Specific */
.ai-button {
    -fx-background-color: linear-gradient(to bottom, #667eea 0%, #764ba2 100%);
    -fx-border-color: #5a67d8;
    -fx-text-fill: #ffffff;
    -fx-font-weight: 600;
    -fx-padding: 14 24;
    -fx-font-size: 15px;
}

.ai-button:hover {
    -fx-background-color: linear-gradient(to bottom, #5a67d8 0%, #667eea 100%);
    -fx-effect: dropshadow(three-pass-box, rgba(102,126,234,0.3), 8, 0.6, 0, 4);
}

/* Code Area Styling */
.code-area {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-radius: 12px;
    -fx-background-radius: 12px;
    -fx-font-family: "JetBrains Mono", "SF Mono", "Consolas", "Monaco", monospace;
    -fx-font-size: 13px;
    -fx-line-spacing: 1.4;
    -fx-padding: 20;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.04), 8, 0.3, 0, 2);
}

.code-area .text {
    -fx-fill: #2d3748;
}

.code-area .line-number {
    -fx-background-color: #f7fafc;
    -fx-text-fill: #a0aec0;
    -fx-font-size: 12px;
    -fx-padding: 0 12 0 8;
    -fx-border-color: #e2e8f0;
    -fx-border-width: 0 1px 0 0;
}

/* Professional Cards */
.card {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-radius: 12px;
    -fx-background-radius: 12px;
    -fx-padding: 20;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.04), 8, 0.3, 0, 2);
}

.card-header {
    -fx-font-size: 18px;
    -fx-font-weight: 600;
    -fx-text-fill: #2d3748;
    -fx-padding: 0 0 16 0;
}

/* Issue Tables */
.table-view {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-radius: 8px;
    -fx-background-radius: 8px;
    -fx-table-cell-border-color: #f7fafc;
    -fx-selection-bar: #e6f3ff;
    -fx-selection-bar-non-focused: #f0f4f8;
}

.table-view .column-header-background {
    -fx-background-color: #f8fafc;
    -fx-border-color: #e2e8f0;
    -fx-border-width: 0 0 1px 0;
}

.table-view .column-header {
    -fx-text-fill: #4a5568;
    -fx-font-weight: 600;
    -fx-font-size: 13px;
    -fx-padding: 12 16;
}

.table-row-cell {
    -fx-background-color: #ffffff;
    -fx-border-color: #f7fafc;
    -fx-border-width: 0 0 1px 0;
    -fx-padding: 8 0;
}

.table-row-cell:selected {
    -fx-background-color: #e6f3ff;
    -fx-border-color: #b3d9ff;
}

.table-cell {
    -fx-text-fill: #4a5568;
    -fx-font-size: 13px;
    -fx-padding: 12 16;
    -fx-alignment: center-left;
}

/* Issue Type Indicators */
.severity-critical {
    -fx-background-color: #fed7d7;
    -fx-text-fill: #c53030;
    -fx-border-color: #feb2b2;
    -fx-border-radius: 20px;
    -fx-background-radius: 20px;
    -fx-padding: 4 12;
    -fx-font-size: 11px;
    -fx-font-weight: 600;
}

.severity-warning {
    -fx-background-color: #fefcbf;
    -fx-text-fill: #d69e2e;
    -fx-border-color: #faf089;
    -fx-border-radius: 20px;
    -fx-background-radius: 20px;
    -fx-padding: 4 12;
    -fx-font-size: 11px;
    -fx-font-weight: 600;
}

.severity-info {
    -fx-background-color: #bee3f8;
    -fx-text-fill: #2b6cb0;
    -fx-border-color: #90cdf4;
    -fx-border-radius: 20px;
    -fx-background-radius: 20px;
    -fx-padding: 4 12;
    -fx-font-size: 11px;
    -fx-font-weight: 600;
}

/* Section Headers */
.section-header {
    -fx-font-size: 16px;
    -fx-font-weight: 700;
    -fx-padding: 0 0 12 0;
}

.error-header {
    -fx-text-fill: #e53e3e;
}

.warning-header {
    -fx-text-fill: #d69e2e;
}

.suggestion-header {
    -fx-text-fill: #0066cc;
}

.details-header {
    -fx-text-fill: #4a5568;
}

/* Search and Filter Controls */
.search-field {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-radius: 8px;
    -fx-background-radius: 8px;
    -fx-padding: 10 16;
    -fx-font-size: 14px;
    -fx-prompt-text-fill: #a0aec0;
    -fx-min-width: 200px;
}

.search-field:focused {
    -fx-border-color: #0066cc;
    -fx-effect: dropshadow(three-pass-box, rgba(0,102,204,0.15), 4, 0.5, 0, 2);
}

.toggle-button {
    -fx-background-color: #f7fafc;
    -fx-border-color: #e2e8f0;
    -fx-border-radius: 6px;
    -fx-background-radius: 6px;
    -fx-text-fill: #4a5568;
    -fx-font-size: 12px;
    -fx-font-weight: 500;
    -fx-padding: 8 16;
}

.toggle-button:selected {
    -fx-background-color: #0066cc;
    -fx-border-color: #0052a3;
    -fx-text-fill: #ffffff;
}

/* Text Areas */
.text-area {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-radius: 8px;
    -fx-background-radius: 8px;
    -fx-padding: 16;
    -fx-font-family: "SF Pro Text", "Inter", "Segoe UI", sans-serif;
    -fx-font-size: 14px;
    -fx-line-spacing: 1.5;
}

.text-area .content {
    -fx-background-color: #ffffff;
    -fx-background-radius: 8px;
}

.details-area {
    -fx-background-color: #f8fafc;
    -fx-border-color: #e2e8f0;
    -fx-text-fill: #4a5568;
}

.ai-suggestion-area {
    -fx-background-color: #f0f4f8;
    -fx-border-color: #cbd5e1;
    -fx-text-fill: #2d3748;
    -fx-font-family: "SF Pro Text", "Inter", "Segoe UI", sans-serif;
}

/* Progress Indicators */
.progress-indicator {
    -fx-progress-color: #0066cc;
}

.progress-indicator .percentage {
    -fx-fill: #0066cc;
}

/* Heatmap */
.heatmap-pane {
    -fx-background-color: #f8fafc;
    -fx-border-color: #e2e8f0;
    -fx-border-radius: 0 8px 8px 0;
    -fx-background-radius: 0 8px 8px 0;
    -fx-padding: 8 4;
}

.heat-level-0 { -fx-background-color: #f7fafc; }
.heat-level-1 { -fx-background-color: #fed7d7; }
.heat-level-2 { -fx-background-color: #feb2b2; }
.heat-level-3 { -fx-background-color: #fc8181; }
.heat-level-4 { -fx-background-color: #f56565; }
.heat-level-5 { -fx-background-color: #e53e3e; }

/* Toolbar */
.toolbar {
    -fx-background-color: #ffffff;
    -fx-border-color: #e1e8ed;
    -fx-border-width: 0 0 1px 0;
    -fx-padding: 12 20;
    -fx-spacing: 12;
}

/* Split Panes */
.split-pane {
    -fx-background-color: transparent;
}

.split-pane .split-pane-divider {
    -fx-background-color: #e1e8ed;
    -fx-padding: 0 1 0 1;
}

/* Responsive breakpoints */
.compact-view .card {
    -fx-padding: 12;
}

.compact-view .section-header {
    -fx-font-size: 14px;
}

/* Status indicators */
.status-indicator {
    -fx-background-radius: 50px;
    -fx-min-width: 8px;
    -fx-min-height: 8px;
    -fx-max-width: 8px;
    -fx-max-height: 8px;
}

.status-success {
    -fx-background-color: #48bb78;
}

.status-warning {
    -fx-background-color: #ed8936;
}

.status-error {
    -fx-background-color: #f56565;
}

/* Animations and Transitions */
.fade-in {
    -fx-opacity: 0.0;
}

.fade-in:hover {
    -fx-opacity: 1.0;
}

/* Accessibility */
.button:focused,
.text-field:focused,
.text-area:focused {
    -fx-effect: dropshadow(three-pass-box, rgba(0,102,204,0.3), 6, 0.5, 0, 2);
    -fx-border-color: #0066cc;
}

/* Status Bar */
.status-bar {
    -fx-background-color: #f8fafc;
    -fx-border-color: #e1e8ed;
    -fx-border-width: 1px 0 0 0;
    -fx-padding: 8 16;
}

.status-label {
    -fx-text-fill: #4a5568;
    -fx-font-size: 13px;
}

.file-path-label {
    -fx-text-fill: #2d3748;
    -fx-font-weight: 500;
    -fx-font-size: 14px;
}

.issue-count-label {
    -fx-text-fill: #4a5568;
    -fx-font-size: 12px;
}

.ai-status-label {
    -fx-text-fill: #667eea;
    -fx-font-size: 13px;
}
}
</file>

<file path="frontend/src/test/java/com/reviewer/codereviewer/client/dto/CodeAnalysisResultTest.java">
package com.reviewer.codereviewer.client.dto;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.BeforeEach;

import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Code Analysis Result DTO Tests")
class CodeAnalysisResultTest {
    
    private CodeAnalysisResult result;
    
    @BeforeEach
    void setUp() {
        result = new CodeAnalysisResult();
    }
    
    @Test
    @DisplayName("Should initialize with empty lists")
    void shouldInitializeWithEmptyLists() {
        assertNotNull(result.getErrors());
        assertNotNull(result.getSuggestions());
        assertTrue(result.getErrors().isEmpty());
        assertTrue(result.getSuggestions().isEmpty());
        assertEquals(0.0, result.getScore());
    }
    
    @Test
    @DisplayName("Should initialize with provided lists")
    void shouldInitializeWithProvidedLists() {
        CodeIssue error = new CodeIssue("Error message", 1, CodeIssue.Type.ERROR);
        CodeIssue suggestion = new CodeIssue("Suggestion message", 2, CodeIssue.Type.SUGGESTION);
        
        List<CodeIssue> errors = Arrays.asList(error);
        List<CodeIssue> suggestions = Arrays.asList(suggestion);
        
        CodeAnalysisResult result = new CodeAnalysisResult(errors, suggestions, 85.5);
        
        assertEquals(1, result.getErrors().size());
        assertEquals(1, result.getSuggestions().size());
        assertEquals(85.5, result.getScore());
        assertEquals(error, result.getErrors().get(0));
        assertEquals(suggestion, result.getSuggestions().get(0));
    }
    
    @Test
    @DisplayName("Should handle null lists gracefully")
    void shouldHandleNullListsGracefully() {
        CodeAnalysisResult result = new CodeAnalysisResult(null, null, 90.0);
        
        assertNotNull(result.getErrors());
        assertNotNull(result.getSuggestions());
        assertTrue(result.getErrors().isEmpty());
        assertTrue(result.getSuggestions().isEmpty());
        assertEquals(90.0, result.getScore());
    }
    
    @Test
    @DisplayName("Should correctly report if has issues")
    void shouldCorrectlyReportIfHasIssues() {
        // Initially no issues
        assertFalse(result.hasIssues());
        
        // Add an error
        CodeIssue error = new CodeIssue("Error", 1, CodeIssue.Type.ERROR);
        result.getErrors().add(error);
        assertTrue(result.hasIssues());
        
        // Clear and add a suggestion
        result.getErrors().clear();
        CodeIssue suggestion = new CodeIssue("Suggestion", 2, CodeIssue.Type.SUGGESTION);
        result.getSuggestions().add(suggestion);
        assertTrue(result.hasIssues());
    }
    
    @Test
    @DisplayName("Should correctly count total issues")
    void shouldCorrectlyCountTotalIssues() {
        assertEquals(0, result.getTotalIssueCount());
        
        // Add errors and suggestions
        result.getErrors().add(new CodeIssue("Error 1", 1, CodeIssue.Type.ERROR));
        result.getErrors().add(new CodeIssue("Error 2", 2, CodeIssue.Type.ERROR));
        result.getSuggestions().add(new CodeIssue("Suggestion 1", 3, CodeIssue.Type.SUGGESTION));
        
        assertEquals(3, result.getTotalIssueCount());
    }
    
    @Test
    @DisplayName("Should set and get analysis time")
    void shouldSetAndGetAnalysisTime() {
        String analysisTime = "2024-08-15T10:30:00Z";
        result.setAnalysisTime(analysisTime);
        assertEquals(analysisTime, result.getAnalysisTime());
    }
    
    @Test
    @DisplayName("Should set and get score")
    void shouldSetAndGetScore() {
        result.setScore(75.5);
        assertEquals(75.5, result.getScore());
    }
    
    @Test
    @DisplayName("Should set errors list")
    void shouldSetErrorsList() {
        CodeIssue error1 = new CodeIssue("Error 1", 1, CodeIssue.Type.ERROR);
        CodeIssue error2 = new CodeIssue("Error 2", 2, CodeIssue.Type.ERROR);
        List<CodeIssue> errors = Arrays.asList(error1, error2);
        
        result.setErrors(errors);
        
        assertEquals(2, result.getErrors().size());
        assertEquals(error1, result.getErrors().get(0));
        assertEquals(error2, result.getErrors().get(1));
    }
    
    @Test
    @DisplayName("Should set suggestions list")
    void shouldSetSuggestionsList() {
        CodeIssue suggestion1 = new CodeIssue("Suggestion 1", 1, CodeIssue.Type.SUGGESTION);
        CodeIssue suggestion2 = new CodeIssue("Suggestion 2", 2, CodeIssue.Type.SUGGESTION);
        List<CodeIssue> suggestions = Arrays.asList(suggestion1, suggestion2);
        
        result.setSuggestions(suggestions);
        
        assertEquals(2, result.getSuggestions().size());
        assertEquals(suggestion1, result.getSuggestions().get(0));
        assertEquals(suggestion2, result.getSuggestions().get(1));
    }
}
</file>

<file path="frontend/src/test/java/com/reviewer/codereviewer/client/dto/CodeIssueTest.java">
package com.reviewer.codereviewer.client.dto;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.BeforeEach;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Code Issue DTO Tests")
class CodeIssueTest {
    
    private CodeIssue issue;
    
    @BeforeEach
    void setUp() {
        issue = new CodeIssue();
    }
    
    @Test
    @DisplayName("Should initialize with empty quick fixes list")
    void shouldInitializeWithEmptyQuickFixesList() {
        assertNotNull(issue.getQuickFixes());
        assertTrue(issue.getQuickFixes().isEmpty());
        assertFalse(issue.hasQuickFixes());
    }
    
    @Test
    @DisplayName("Should initialize with provided parameters")
    void shouldInitializeWithProvidedParameters() {
        String message = "Test error message";
        int line = 42;
        int column = 10;
        CodeIssue.Type type = CodeIssue.Type.ERROR;
        
        CodeIssue issue = new CodeIssue(message, line, column, type);
        
        assertEquals(message, issue.getMessage());
        assertEquals(line, issue.getLine());
        assertEquals(column, issue.getColumn());
        assertEquals(type, issue.getType());
        assertNotNull(issue.getQuickFixes());
        assertTrue(issue.getQuickFixes().isEmpty());
    }
    
    @Test
    @DisplayName("Should initialize with line only constructor")
    void shouldInitializeWithLineOnlyConstructor() {
        String message = "Test warning";
        int line = 25;
        CodeIssue.Type type = CodeIssue.Type.WARNING;
        
        CodeIssue issue = new CodeIssue(message, line, type);
        
        assertEquals(message, issue.getMessage());
        assertEquals(line, issue.getLine());
        assertEquals(0, issue.getColumn()); // Default column should be 0
        assertEquals(type, issue.getType());
    }
    
    @Test
    @DisplayName("Should set and get message")
    void shouldSetAndGetMessage() {
        String message = "This is a test message";
        issue.setMessage(message);
        assertEquals(message, issue.getMessage());
    }
    
    @Test
    @DisplayName("Should set and get line number")
    void shouldSetAndGetLineNumber() {
        int line = 123;
        issue.setLine(line);
        assertEquals(line, issue.getLine());
    }
    
    @Test
    @DisplayName("Should set and get column number")
    void shouldSetAndGetColumnNumber() {
        int column = 45;
        issue.setColumn(column);
        assertEquals(column, issue.getColumn());
    }
    
    @Test
    @DisplayName("Should set and get type")
    void shouldSetAndGetType() {
        CodeIssue.Type type = CodeIssue.Type.SUGGESTION;
        issue.setType(type);
        assertEquals(type, issue.getType());
    }
    
    @Test
    @DisplayName("Should set and get severity")
    void shouldSetAndGetSeverity() {
        String severity = "HIGH";
        issue.setSeverity(severity);
        assertEquals(severity, issue.getSeverity());
    }
    
    @Test
    @DisplayName("Should add quick fix")
    void shouldAddQuickFix() {
        QuickFix fix = new QuickFix("Fix description", "Fix action");
        
        issue.addQuickFix(fix);
        
        assertEquals(1, issue.getQuickFixes().size());
        assertEquals(fix, issue.getQuickFixes().get(0));
        assertTrue(issue.hasQuickFixes());
    }
    
    @Test
    @DisplayName("Should handle null quick fix gracefully")
    void shouldHandleNullQuickFixGracefully() {
        issue.addQuickFix(null);
        
        assertTrue(issue.getQuickFixes().isEmpty());
        assertFalse(issue.hasQuickFixes());
    }
    
    @Test
    @DisplayName("Should set quick fixes list")
    void shouldSetQuickFixesList() {
        QuickFix fix1 = new QuickFix("Fix 1", "Action 1");
        QuickFix fix2 = new QuickFix("Fix 2", "Action 2");
        
        java.util.List<QuickFix> fixes = java.util.Arrays.asList(fix1, fix2);
        issue.setQuickFixes(fixes);
        
        assertEquals(2, issue.getQuickFixes().size());
        assertTrue(issue.hasQuickFixes());
        assertEquals(fix1, issue.getQuickFixes().get(0));
        assertEquals(fix2, issue.getQuickFixes().get(1));
    }
    
    @Test
    @DisplayName("Should handle null quick fixes list gracefully")
    void shouldHandleNullQuickFixesListGracefully() {
        issue.setQuickFixes(null);
        
        assertNotNull(issue.getQuickFixes());
        assertTrue(issue.getQuickFixes().isEmpty());
        assertFalse(issue.hasQuickFixes());
    }
    
    @Test
    @DisplayName("Should test all enum types")
    void shouldTestAllEnumTypes() {
        // Test that all enum types are available
        assertEquals(4, CodeIssue.Type.values().length);
        assertEquals(CodeIssue.Type.ERROR, CodeIssue.Type.valueOf("ERROR"));
        assertEquals(CodeIssue.Type.WARNING, CodeIssue.Type.valueOf("WARNING"));
        assertEquals(CodeIssue.Type.SUGGESTION, CodeIssue.Type.valueOf("SUGGESTION"));
        assertEquals(CodeIssue.Type.INFO, CodeIssue.Type.valueOf("INFO"));
    }
    
    @Test
    @DisplayName("Should produce meaningful toString")
    void shouldProduceMeaningfulToString() {
        issue.setType(CodeIssue.Type.ERROR);
        issue.setLine(42);
        issue.setMessage("Test error message");
        
        String result = issue.toString();
        
        assertTrue(result.contains("ERROR"));
        assertTrue(result.contains("42"));
        assertTrue(result.contains("Test error message"));
    }
}
</file>

<file path="frontend/src/test/java/com/reviewer/codereviewer/client/dto/QuickFixTest.java">
package com.reviewer.codereviewer.client.dto;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.BeforeEach;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Quick Fix DTO Tests")
class QuickFixTest {
    
    private QuickFix quickFix;
    
    @BeforeEach
    void setUp() {
        quickFix = new QuickFix();
    }
    
    @Test
    @DisplayName("Should initialize with default constructor")
    void shouldInitializeWithDefaultConstructor() {
        assertNotNull(quickFix);
        assertNull(quickFix.getDescription());
        assertNull(quickFix.getAction());
        assertNull(quickFix.getReplacement());
        assertEquals(0, quickFix.getStartLine());
        assertEquals(0, quickFix.getEndLine());
    }
    
    @Test
    @DisplayName("Should initialize with description and action")
    void shouldInitializeWithDescriptionAndAction() {
        String description = "Fix unused import";
        String action = "Remove import statement";
        
        QuickFix fix = new QuickFix(description, action);
        
        assertEquals(description, fix.getDescription());
        assertEquals(action, fix.getAction());
        assertNull(fix.getReplacement());
        assertEquals(0, fix.getStartLine());
        assertEquals(0, fix.getEndLine());
    }
    
    @Test
    @DisplayName("Should initialize with all parameters")
    void shouldInitializeWithAllParameters() {
        String description = "Replace with constant";
        String action = "Replace magic number";
        String replacement = "public static final int MAX_SIZE = 100;";
        int startLine = 5;
        int endLine = 5;
        
        QuickFix fix = new QuickFix(description, action, replacement, startLine, endLine);
        
        assertEquals(description, fix.getDescription());
        assertEquals(action, fix.getAction());
        assertEquals(replacement, fix.getReplacement());
        assertEquals(startLine, fix.getStartLine());
        assertEquals(endLine, fix.getEndLine());
    }
    
    @Test
    @DisplayName("Should set and get description")
    void shouldSetAndGetDescription() {
        String description = "Test description";
        quickFix.setDescription(description);
        assertEquals(description, quickFix.getDescription());
    }
    
    @Test
    @DisplayName("Should set and get action")
    void shouldSetAndGetAction() {
        String action = "Test action";
        quickFix.setAction(action);
        assertEquals(action, quickFix.getAction());
    }
    
    @Test
    @DisplayName("Should set and get replacement")
    void shouldSetAndGetReplacement() {
        String replacement = "Test replacement code";
        quickFix.setReplacement(replacement);
        assertEquals(replacement, quickFix.getReplacement());
    }
    
    @Test
    @DisplayName("Should set and get start line")
    void shouldSetAndGetStartLine() {
        int startLine = 10;
        quickFix.setStartLine(startLine);
        assertEquals(startLine, quickFix.getStartLine());
    }
    
    @Test
    @DisplayName("Should set and get end line")
    void shouldSetAndGetEndLine() {
        int endLine = 15;
        quickFix.setEndLine(endLine);
        assertEquals(endLine, quickFix.getEndLine());
    }
    
    @Test
    @DisplayName("ToString should return description when available")
    void toStringShouldReturnDescriptionWhenAvailable() {
        String description = "Test description";
        quickFix.setDescription(description);
        
        assertEquals(description, quickFix.toString());
    }
    
    @Test
    @DisplayName("ToString should return action when description is null")
    void toStringShouldReturnActionWhenDescriptionIsNull() {
        String action = "Test action";
        quickFix.setAction(action);
        
        assertEquals(action, quickFix.toString());
    }
    
    @Test
    @DisplayName("ToString should return action when description is empty")
    void toStringShouldReturnActionWhenDescriptionIsEmpty() {
        String action = "Test action";
        quickFix.setDescription("");
        quickFix.setAction(action);
        
        assertEquals(action, quickFix.toString());
    }
    
    @Test
    @DisplayName("ToString should handle null values gracefully")
    void toStringShouldHandleNullValuesGracefully() {
        String result = quickFix.toString();
        assertNotNull(result);
        // Should not throw an exception
    }
    
    @Test
    @DisplayName("Should handle line range correctly")
    void shouldHandleLineRangeCorrectly() {
        quickFix.setStartLine(10);
        quickFix.setEndLine(15);
        
        assertEquals(10, quickFix.getStartLine());
        assertEquals(15, quickFix.getEndLine());
        assertTrue(quickFix.getEndLine() >= quickFix.getStartLine());
    }
    
    @Test
    @DisplayName("Should handle single line fix")
    void shouldHandleSingleLineFix() {
        quickFix.setStartLine(10);
        quickFix.setEndLine(10);
        
        assertEquals(10, quickFix.getStartLine());
        assertEquals(10, quickFix.getEndLine());
        assertEquals(quickFix.getStartLine(), quickFix.getEndLine());
    }
}
</file>

<file path="frontend/src/test/java/com/reviewer/codereviewer/client/ApiClientServiceTest.java">
package com.reviewer.codereviewer.client;

import com.reviewer.codereviewer.client.dto.CodeAnalysisResult;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Disabled;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("API Client Service Tests")
class ApiClientServiceTest {
    
    private ApiClientService apiClientService;
    
    @BeforeEach
    void setUp() {
        // Use default localhost:8080 for testing
        apiClientService = new ApiClientService();
    }
    
    @Test
    @DisplayName("Should initialize with default server URL")
    void shouldInitializeWithDefaultUrl() {
        ApiClientService defaultClient = new ApiClientService();
        assertNotNull(defaultClient);
    }
    
    @Test
    @DisplayName("Should initialize with custom server URL")
    void shouldInitializeWithCustomUrl() {
        String customUrl = "http://localhost:9090";
        ApiClientService customClient = new ApiClientService(customUrl);
        assertNotNull(customClient);
    }
    
    @Test
    @DisplayName("Should handle trailing slash in server URL")
    void shouldHandleTrailingSlashInUrl() {
        String urlWithSlash = "http://localhost:8080/";
        ApiClientService client = new ApiClientService(urlWithSlash);
        assertNotNull(client);
        // The implementation should remove the trailing slash
    }
    
    @Test
    @Disabled("Requires running backend server")
    @DisplayName("Should successfully analyze code when server is available")
    void shouldAnalyzeCodeWhenServerAvailable() throws ExecutionException, InterruptedException, TimeoutException {
        String sampleCode = """
            public class TestClass {
                public void testMethod() {
                    System.out.println("Hello World");
                }
            }
            """;
        
        CompletableFuture<CodeAnalysisResult> future = apiClientService.analyzeCode(sampleCode);
        CodeAnalysisResult result = future.get(30, TimeUnit.SECONDS);
        
        assertNotNull(result);
        assertNotNull(result.getErrors());
        assertNotNull(result.getSuggestions());
    }
    
    @Test
    @Disabled("Requires running backend server")
    @DisplayName("Should check server health when server is available")
    void shouldCheckServerHealthWhenAvailable() throws ExecutionException, InterruptedException, TimeoutException {
        CompletableFuture<Boolean> future = apiClientService.checkServerHealth();
        Boolean isHealthy = future.get(10, TimeUnit.SECONDS);
        
        assertTrue(isHealthy);
    }
    
    @Test
    @DisplayName("Should handle server unavailable gracefully")
    void shouldHandleServerUnavailableGracefully() {
        // Use a non-existent server URL
        ApiClientService unavailableClient = new ApiClientService("http://localhost:99999");
        
        CompletableFuture<Boolean> healthFuture = unavailableClient.checkServerHealth();
        
        assertDoesNotThrow(() -> {
            Boolean isHealthy = healthFuture.get(10, TimeUnit.SECONDS);
            assertFalse(isHealthy);
        });
    }
    
    @Test
    @DisplayName("Should handle null code input gracefully")
    void shouldHandleNullCodeInput() {
        CompletableFuture<CodeAnalysisResult> future = apiClientService.analyzeCode(null);
        
        assertThrows(ExecutionException.class, () -> {
            future.get(5, TimeUnit.SECONDS);
        });
    }
    
    @Test
    @DisplayName("Should handle empty code input gracefully")
    void shouldHandleEmptyCodeInput() {
        CompletableFuture<CodeAnalysisResult> future = apiClientService.analyzeCode("");
        
        // Should not throw immediately (the server will handle empty input)
        assertNotNull(future);
        assertFalse(future.isDone() && future.isCompletedExceptionally());
    }
    
    @Test
    @Disabled("Requires running backend server with AI functionality")
    @DisplayName("Should stream AI suggestions when server is available")
    void shouldStreamAiSuggestionsWhenServerAvailable() throws ExecutionException, InterruptedException, TimeoutException {
        String sampleCode = """
            public class TestClass {
                public void testMethod() {
                    System.out.println("Hello World");
                }
            }
            """;
        String question = "Please review this code";
        StringBuilder response = new StringBuilder();
        
        CompletableFuture<Void> future = apiClientService.getCodeSuggestionStreaming(
            sampleCode, 
            question,
            chunk -> response.append(chunk)
        );
        
        future.get(60, TimeUnit.SECONDS);
        
        assertFalse(response.toString().isEmpty());
    }
    
    @Test
    @Disabled("Requires running backend server with AI functionality")
    @DisplayName("Should get complete AI suggestion when server is available")
    void shouldGetCompleteAiSuggestionWhenServerAvailable() throws ExecutionException, InterruptedException, TimeoutException {
        String sampleCode = """
            public class TestClass {
                public void testMethod() {
                    System.out.println("Hello World");
                }
            }
            """;
        String question = "Please review this code";
        
        CompletableFuture<String> future = apiClientService.getCodeSuggestion(sampleCode, question);
        String response = future.get(60, TimeUnit.SECONDS);
        
        assertNotNull(response);
        assertFalse(response.isEmpty());
    }
    
    @Test
    @DisplayName("Should handle AI request with null inputs gracefully")
    void shouldHandleAiRequestWithNullInputs() {
        CompletableFuture<String> future = apiClientService.getCodeSuggestion(null, null);
        
        assertThrows(ExecutionException.class, () -> {
            future.get(5, TimeUnit.SECONDS);
        });
    }
}
</file>

<file path="frontend/src/test/java/com/reviewer/codereviewer/controller/MainControllerTest.java">
package com.reviewer.codereviewer.controller;

import com.reviewer.codereviewer.client.ApiClientService;
import com.reviewer.codereviewer.client.dto.CodeAnalysisResult;
import com.reviewer.codereviewer.client.dto.CodeIssue;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Arrays;
import java.util.concurrent.CompletableFuture;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@DisplayName("Main Controller Tests")
class MainControllerTest {
    
    @Mock
    private ApiClientService mockApiClientService;
    
    private MainController controller;
    
    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        controller = new MainController(mockApiClientService);
    }
    
    @Test
    @DisplayName("Should initialize with default API client")
    void shouldInitializeWithDefaultApiClient() {
        MainController defaultController = new MainController();
        assertNotNull(defaultController);
    }
    
    @Test
    @DisplayName("Should initialize with custom API client")
    void shouldInitializeWithCustomApiClient() {
        assertNotNull(controller);
    }
    
    @Test
    @DisplayName("Should use API client for code analysis")
    void shouldUseApiClientForCodeAnalysis() {
        // Arrange
        String testCode = "public class Test {}";
        CodeAnalysisResult mockResult = createMockAnalysisResult();
        when(mockApiClientService.analyzeCode(testCode))
            .thenReturn(CompletableFuture.completedFuture(mockResult));
        
        // Act
        controller.analyzeCode(testCode);
        
        // Assert
        verify(mockApiClientService, times(1)).analyzeCode(testCode);
    }
    
    @Test
    @DisplayName("Should handle null code input gracefully")
    void shouldHandleNullCodeInputGracefully() {
        // Act - should not throw exception
        assertDoesNotThrow(() -> controller.analyzeCode(null));
        
        // Should not call API service for null input
        verify(mockApiClientService, never()).analyzeCode(anyString());
    }
    
    @Test
    @DisplayName("Should handle empty code input gracefully")
    void shouldHandleEmptyCodeInputGracefully() {
        // Act - should not throw exception
        assertDoesNotThrow(() -> controller.analyzeCode(""));
        
        // Should not call API service for empty input
        verify(mockApiClientService, never()).analyzeCode(anyString());
    }
    
    @Test
    @DisplayName("Should handle whitespace-only code input gracefully")
    void shouldHandleWhitespaceOnlyCodeInputGracefully() {
        // Act - should not throw exception
        assertDoesNotThrow(() -> controller.analyzeCode("   \n\t  "));
        
        // Should not call API service for whitespace-only input
        verify(mockApiClientService, never()).analyzeCode(anyString());
    }
    
    @Test
    @DisplayName("Should use API client for AI questions")
    void shouldUseApiClientForAiQuestions() {
        // Arrange
        String testCode = "public class Test {}";
        String testQuestion = "Please review this code";
        when(mockApiClientService.getCodeSuggestionStreaming(anyString(), anyString(), any()))
            .thenReturn(CompletableFuture.completedFuture(null));
        
        // Act
        controller.onAskAiWithQuestion(testCode, testQuestion);
        
        // Assert
        verify(mockApiClientService, times(1))
            .getCodeSuggestionStreaming(eq(testCode), eq(testQuestion), any());
    }
    
    @Test
    @DisplayName("Should handle API service failures gracefully")
    void shouldHandleApiServiceFailuresGracefully() {
        // Arrange
        String testCode = "public class Test {}";
        CompletableFuture<CodeAnalysisResult> failedFuture = new CompletableFuture<>();
        failedFuture.completeExceptionally(new RuntimeException("API service unavailable"));
        when(mockApiClientService.analyzeCode(testCode)).thenReturn(failedFuture);
        
        // Act - should not throw exception
        assertDoesNotThrow(() -> controller.analyzeCode(testCode));
        
        // Assert that the API service was called
        verify(mockApiClientService, times(1)).analyzeCode(testCode);
    }
    
    @Test
    @DisplayName("Should call analyzeCode when analyzeAndDisplay is called")
    void shouldCallAnalyzeCodeWhenAnalyzeAndDisplayIsCalled() {
        // Arrange
        String testCode = "public class Test {}";
        CodeAnalysisResult mockResult = createMockAnalysisResult();
        when(mockApiClientService.analyzeCode(testCode))
            .thenReturn(CompletableFuture.completedFuture(mockResult));
        
        // Act
        controller.analyzeAndDisplay(testCode);
        
        // Assert
        verify(mockApiClientService, times(1)).analyzeCode(testCode);
    }
    
    @Test
    @DisplayName("Should store last result when analysis completes")
    void shouldStoreLastResultWhenAnalysisCompletes() throws Exception {
        // Arrange
        String testCode = "public class Test {}";
        CodeAnalysisResult mockResult = createMockAnalysisResult();
        when(mockApiClientService.analyzeCode(testCode))
            .thenReturn(CompletableFuture.completedFuture(mockResult));
        
        // Act
        controller.analyzeCode(testCode);
        
        // Wait a bit for async completion (in a real test, you'd use proper async testing)
        Thread.sleep(100);
        
        // Assert - getLastResult should return the result (this is a simplified test)
        // In practice, you'd need to test this with proper async testing techniques
        verify(mockApiClientService, times(1)).analyzeCode(testCode);
    }
    
    private CodeAnalysisResult createMockAnalysisResult() {
        CodeIssue error = new CodeIssue("Test error", 1, CodeIssue.Type.ERROR);
        CodeIssue suggestion = new CodeIssue("Test suggestion", 2, CodeIssue.Type.SUGGESTION);
        
        return new CodeAnalysisResult(
            Arrays.asList(error),
            Arrays.asList(suggestion),
            85.0
        );
    }
}
</file>

<file path="frontend/FRONTEND-TRANSFORMATION-COMPLETE.md">
# CodeReviewer Frontend Transformation - Step 4 Complete

## Overview
We have successfully transformed the CodeReviewer desktop application from a monolithic application into a "dumb" frontend client that communicates with a backend server via API calls.

## What Was Accomplished

### Step 4.1: Remove Backend Logic from Frontend ✅
**What we did:**
- Deleted the following packages from the frontend:
  - `service/` - AI and code analysis services
  - `model/` - Business logic models and data structures
  - `config/` - Configuration management
  - `cache/` - Analysis caching functionality
  - `security/` - Security and validation logic
  - `repo/` - File repository management
  - `metrics/` - Application metrics
  - `exception/` - Custom exception handling

**Why this was important:**
- **Simple Reason:** The desktop app no longer has its own engine; it just needs a remote control for the server's engine.
- **Technical Reason:** This physically enforces the client-server boundary. The frontend can no longer have a direct compile-time dependency on the business logic, forcing all communication to go through the well-defined API.

### Step 4.2: Create an API Client Service ✅
**What we did:**
- Created a new `client/` package with:
  - `ApiClientService.java` - Main HTTP client for backend communication
  - `dto/` package with data transfer objects:
    - `CodeAnalysisResult.java` - Analysis results from backend
    - `CodeIssue.java` - Individual code issues
    - `QuickFix.java` - Quick fix suggestions

**Key features of ApiClientService:**
- HTTP communication using Java 11's HttpClient
- JSON serialization/deserialization using Jackson
- Asynchronous API calls returning CompletableFuture
- Streaming support for AI responses
- Configurable server URL (defaults to http://localhost:8080)
- Health check functionality
- Proper error handling and logging

**Why this was important:**
- **Simple Reason:** We created a single, specialized "messenger" that knows the server's address and how to talk to it.
- **Technical Reason:** This encapsulates all networking and data serialization/deserialization logic in one place. The MainController remains clean and is shielded from the complexities of HTTP.

### Step 4.3: Update the MainController ✅
**What we did:**
- Modified `MainController.java` to use `ApiClientService` instead of local services
- Updated method signatures to work with the new DTOs
- Added server health checking on startup
- Simplified UI interactions by removing complex local business logic
- Updated AI functionality to use backend API

**Key changes:**
- `analyzeCode()` now calls `apiClientService.analyzeCode()`
- `onAskAiWithQuestion()` now uses `apiClientService.getCodeSuggestionStreaming()`
- Removed direct dependencies on local services
- Added connection status feedback to users
- Simplified error handling to focus on communication issues

**Why this was important:**
- **Simple Reason:** We rewired the "Analyze" button to use the new messenger service instead of the old, local engine.
- **Technical Reason:** This is the final step in decoupling the UI from the business logic. The controller's responsibility is now purely to manage the UI state and delegate actions to a remote service.

## Technical Architecture

### Before (Monolithic)
```
[UI] → [Controller] → [Local Services] → [Local Models] → [Local Config]
```

### After (Client-Server)
```
[UI] → [Controller] → [ApiClientService] → [HTTP] → [Backend Server]
                            ↓
                        [DTOs for serialization]
```

## Dependencies Added
- **Jackson Databind** (2.15.2) - For JSON serialization/deserialization
- Uses existing Java 11 HttpClient - No additional HTTP client dependency needed

## Configuration
- Default backend server URL: `http://localhost:8080`
- Configurable through ApiClientService constructor
- 30-second timeout for analysis requests
- 2-minute timeout for AI streaming requests

## Testing Status
- ✅ Compilation successful
- ✅ All backend packages properly removed from frontend
- ✅ API client service properly implemented
- ✅ DTOs properly created
- ✅ MainController properly updated
- ✅ UI classes updated to use new DTOs

## Next Steps
1. **Start the backend server** (from Step 3 of the previous instructions)
2. **Run the frontend application:**
   ```bash
   ./mvnw clean compile exec:java -Dexec.mainClass="com.reviewer.codereviewer.MainApp"
   ```
3. **Test the connection** - The frontend will automatically check server health on startup

## Files Created/Modified

### New Files:
- `src/main/java/com/reviewer/codereviewer/client/ApiClientService.java`
- `src/main/java/com/reviewer/codereviewer/client/dto/CodeAnalysisResult.java`
- `src/main/java/com/reviewer/codereviewer/client/dto/CodeIssue.java`
- `src/main/java/com/reviewer/codereviewer/client/dto/QuickFix.java`
- `test-frontend-transformation.sh`

### Modified Files:
- `src/main/java/com/reviewer/codereviewer/controller/MainController.java`
- `src/main/java/com/reviewer/codereviewer/ui/MainView.java`
- `src/main/java/com/reviewer/codereviewer/ui/ModernMainView.java`
- `src/main/java/com/reviewer/codereviewer/MainApp.java`
- `pom.xml` (added Jackson dependency)

### Deleted Packages:
- `src/main/java/com/reviewer/codereviewer/service/`
- `src/main/java/com/reviewer/codereviewer/model/`
- `src/main/java/com/reviewer/codereviewer/config/`
- `src/main/java/com/reviewer/codereviewer/cache/`
- `src/main/java/com/reviewer/codereviewer/security/`
- `src/main/java/com/reviewer/codereviewer/repo/`
- `src/main/java/com/reviewer/codereviewer/metrics/`
- `src/main/java/com/reviewer/codereviewer/exception/`

## Benefits Achieved
1. **Clear Separation of Concerns** - Frontend focuses purely on UI, backend handles business logic
2. **Scalability** - Backend can serve multiple frontend clients
3. **Technology Flexibility** - Frontend and backend can evolve independently
4. **Easier Testing** - Can mock the ApiClientService for frontend testing
5. **Better Error Handling** - Clear distinction between UI errors and server errors
6. **Network Resilience** - Proper handling of connection issues and timeouts

The CodeReviewer application has been successfully transformed from a monolithic desktop application into a modern client-server architecture with a clean API boundary! 🎉
</file>

<file path="frontend/HELP.md">
# Getting Started

### Reference Documentation

For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the
parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.
</file>

<file path="frontend/INTEGRATION_GUIDE.md">
# 🔧 Integration Guide for Enhanced Code Reviewer

## Overview
This guide will help you integrate all the new architectural components into your existing CodeReviewer application.

## 🎯 Integration Steps

### Phase 1: Service Layer Integration

#### 1.1 Update MainController to use ServiceConfig
```java
// In MainController.java, replace service initialization with:
private final CodeAnalysisService codeAnalysisService;
private final AISuggestionService aiSuggestionService;
private final ApplicationMetrics metrics;
private final AnalysisCache cache;

public MainController() {
    ServiceConfig serviceConfig = new ServiceConfig();
    this.codeAnalysisService = serviceConfig.codeAnalysisService();
    this.aiSuggestionService = serviceConfig.aiSuggestionService();
    this.metrics = serviceConfig.applicationMetrics();
    this.cache = serviceConfig.analysisCache();
}
```

#### 1.2 Add Configuration Validation
```java
// In MainApp.java, add before launch:
public static void main(String[] args) {
    try {
        ConfigurationManager.getInstance().validateConfiguration();
        launch(args);
    } catch (IllegalStateException e) {
        System.err.println("Configuration Error: " + e.getMessage());
        System.exit(1);
    }
}
```

### Phase 2: Security Integration

#### 2.1 Update OpenRouterService with Security
```java
// Add to OpenRouterService.java:
import com.reviewer.codereviewer.security.SecurityUtils;

// In API methods, add validation:
public CompletableFuture<String> getCodeSuggestionAsync(String code) {
    var validation = SecurityUtils.validateApiRequest(apiKey, modelName, code);
    if (!validation.isValid()) {
        return CompletableFuture.failedFuture(
            new IllegalArgumentException(validation.getMessage())
        );
    }
    // ... existing code
}
```

### Phase 3: Performance Enhancements

#### 3.1 Add Caching to CodeAnalysisService
```java
// In CodeAnalysisService.java:
private final AnalysisCache cache;

public CodeAnalysisResult analyze(Path filePath) throws IOException {
    String content = Files.readString(filePath);
    String cacheKey = SecurityUtils.generateCacheKey(content);
    
    // Check cache first
    CodeAnalysisResult cached = cache.get(cacheKey);
    if (cached != null) {
        return cached;
    }
    
    // Perform analysis
    CodeAnalysisResult result = performAnalysis(content);
    cache.put(cacheKey, result);
    
    return result;
}
```

#### 3.2 Add Metrics Collection
```java
// In service methods, add metrics:
long startTime = System.currentTimeMillis();
try {
    // ... service logic
    metrics.recordOperationTime("analysis.execution", System.currentTimeMillis() - startTime);
    metrics.incrementCounter("analysis.success");
} catch (Exception e) {
    metrics.incrementCounter("analysis.error");
    throw e;
}
```

### Phase 4: Error Handling

#### 4.1 Replace Exception Handling
```java
// Replace generic exceptions with specific ones:
throw new AnalysisException("Failed to parse Java file", e);
throw new ApiException("OpenRouter API request failed", e);
throw new ConfigurationException("Invalid API key configuration");
```

### Phase 5: Testing Integration

#### 5.1 Run Enhanced Tests
```bash
# Run all tests including new ones
mvn test

# Run specific test classes
mvn test -Dtest=CodeAnalysisServiceTest
mvn test -Dtest=AISuggestionServiceTest
```

## 🔧 Configuration Updates

### Environment Variables (Recommended for Production)
```bash
export CODEREVIEW_OPENROUTER_API_KEY="your-actual-api-key"
export CODEREVIEW_CACHE_ENABLED="true"
export CODEREVIEW_METRICS_ENABLED="true"
export CODEREVIEW_LOGGING_LEVEL="INFO"
```

### IDE Configuration
1. **VM Options**: Add `-Ddev.mode=true` for development
2. **Run Configuration**: Ensure proper classpath includes all dependencies
3. **Code Style**: Import the Checkstyle configuration created

## 🎨 UI Enhancements

### Theme Support
The application now supports light/dark themes via `ui.theme` property.

### Performance Indicators
Consider adding UI elements to display:
- Analysis progress with caching status
- API response times
- Current configuration status

## 📊 Monitoring Setup

### Metrics Dashboard
Access metrics via ApplicationMetrics:
```java
// In UI or monitoring endpoint:
Map<String, Object> metrics = applicationMetrics.getAllMetrics();
// Display analysis counts, response times, error rates
```

### Log Analysis
Logs are now structured and include:
- Performance metrics
- Security validation results
- Configuration status
- Error details with context

## 🚀 Build and Deployment

### Development Build
```bash
mvn clean compile
mvn exec:java -Dexec.mainClass="com.reviewer.codereviewer.MainApp"
```

### Production Build
```bash
mvn clean package
java -jar target/CodeReviewer-1.0.0.jar
```

### Static Analysis
```bash
mvn spotbugs:check
mvn checkstyle:check
mvn test
```

## 🔐 Security Checklist

- [ ] Replace placeholder API key with real key
- [ ] Enable input sanitization in production
- [ ] Configure proper log levels
- [ ] Set up monitoring alerts
- [ ] Review file access permissions
- [ ] Validate all configuration properties

## 📈 Performance Optimization

### Memory Settings
```bash
java -Xmx2g -XX:+UseG1GC -jar CodeReviewer.jar
```

### Cache Tuning
Adjust cache settings based on usage:
- Increase `cache.size` for more files
- Adjust `cache.ttl.minutes` based on change frequency
- Monitor cache hit rates via metrics

## 🎯 Next Development Priorities

1. **Integration**: Complete the service layer integration
2. **Testing**: Expand test coverage to 80%+
3. **UI**: Add progress indicators and metrics display
4. **Documentation**: API documentation with examples
5. **Deployment**: Docker containerization
6. **Monitoring**: External monitoring integration

## 🔗 Useful Commands

```bash
# Check configuration
mvn exec:java -Dexec.args="--validate-config"

# Run with debug logging
mvn exec:java -Dlogging.level.com.reviewer.codereviewer=DEBUG

# Generate reports
mvn site

# Run performance tests
mvn test -Dtest=PerformanceTest
```

---

**🎉 Your Code Reviewer application is now enhanced with enterprise-grade architecture, security, monitoring, and performance optimizations!**
</file>

<file path="frontend/pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.reviewer</groupId>
    <artifactId>CodeReviewer</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>CodeReviewer</name>
    <description>CodeReviewer</description>
    <properties>
        <java.version>21</java.version>
        <javafx.version>21.0.1</javafx.version>
        <javaparser.version>3.25.8</javaparser.version>
        <okhttp.version>4.11.0</okhttp.version>
        <richtextfx.version>0.10.9</richtextfx.version>
        <json.version>20230618</json.version>
        <junit.version>5.10.0</junit.version>
        <ikonli.version>12.3.1</ikonli.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <maven.compiler.release>${java.version}</maven.compiler.release>
    </properties>
    <dependencies>
        <!-- JavaFX -->
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-controls</artifactId>
            <version>${javafx.version}</version>
        </dependency>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-fxml</artifactId>
            <version>${javafx.version}</version>
        </dependency>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-graphics</artifactId>
            <version>${javafx.version}</version>
        </dependency>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-base</artifactId>
            <version>${javafx.version}</version>
        </dependency>
        <!-- JavaParser -->
        <dependency>
            <groupId>com.github.javaparser</groupId>
            <artifactId>javaparser-core</artifactId>
            <version>${javaparser.version}</version>
        </dependency>
        <!-- OkHttp for OpenAI API integration -->
        <dependency>
            <groupId>com.squareup.okhttp3</groupId>
            <artifactId>okhttp</artifactId>
            <version>${okhttp.version}</version>
        </dependency>
        <!-- RichTextFX for advanced code area (syntax highlighting, colored lines) -->
        <dependency>
            <groupId>org.fxmisc.richtext</groupId>
            <artifactId>richtextfx</artifactId>
            <version>${richtextfx.version}</version>
        </dependency>
        <!-- org.json for JSON handling -->
        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>${json.version}</version>
        </dependency>
        <!-- Jackson for API client JSON handling -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.15.2</version>
        </dependency>
        <!-- Ikonli for icons -->
        <dependency>
            <groupId>org.kordamp.ikonli</groupId>
            <artifactId>ikonli-javafx</artifactId>
            <version>${ikonli.version}</version>
        </dependency>
        <dependency>
            <groupId>org.kordamp.ikonli</groupId>
            <artifactId>ikonli-fontawesome5-pack</artifactId>
            <version>${ikonli.version}</version>
        </dependency>
        <!-- JUnit 5 for testing -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <!-- Mockito for mocking -->
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <version>5.4.0</version>
            <scope>test</scope>
        </dependency>
        <!-- TestFX for JavaFX testing -->
        <dependency>
            <groupId>org.testfx</groupId>
            <artifactId>testfx-core</artifactId>
            <version>4.0.16-alpha</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testfx</groupId>
            <artifactId>testfx-junit5</artifactId>
            <version>4.0.16-alpha</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <release>${java.version}</release>
                    <compilerArgs>
                        <arg>-Xlint:all</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
            
            <!-- JavaFX Maven Plugin -->
            <plugin>
                <groupId>org.openjfx</groupId>
                <artifactId>javafx-maven-plugin</artifactId>
                <version>0.0.8</version>
                <configuration>
                    <mainClass>com.reviewer.codereviewer.MainApp</mainClass>
                </configuration>
            </plugin>
            
            <!-- Surefire for running tests -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.1.2</version>
            </plugin>
            
            <!-- SpotBugs for static analysis -->
            <plugin>
                <groupId>com.github.spotbugs</groupId>
                <artifactId>spotbugs-maven-plugin</artifactId>
                <version>4.7.3.5</version>
                <configuration>
                    <effort>Max</effort>
                    <threshold>Low</threshold>
                </configuration>
            </plugin>
            
            <!-- Checkstyle for code style -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-checkstyle-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <configLocation>checkstyle.xml</configLocation>
                    <includeTestSourceDirectory>true</includeTestSourceDirectory>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
</file>

<file path="frontend/README.md">
# CodeReviewer

A Java code review application that uses AI to analyze code quality and suggest improvements.

## Features

- Analyze Java code for common issues
- Calculate code metrics like cyclomatic complexity
- Generate AI-powered code reviews
- Get AI-suggested refactoring for identified issues
- Ask AI for specific code suggestions and improvements

## Prerequisites

- Java 21 or higher
- Maven
- OpenRouter API key (for AI code reviews)

## Setup Instructions

### 1. Clone the repository

```bash
git clone https://github.com/yourusername/CodeReviewer.git
cd CodeReviewer
```

### 2. Set up the configuration

The application uses a standard `application.properties` file for configuration. This file is located in `src/main/resources/application.properties`.

#### Setting up AI Code Review (Optional)

To enable AI-powered code reviews, you need an OpenRouter API key:

1. Visit [OpenRouter](https://openrouter.ai) and create an account
2. Get your API key from the dashboard
3. Edit the `src/main/resources/application.properties` file and replace `YOUR_API_KEY_HERE` with your actual API key:

```properties
openrouter.api.key=sk-or-v1-your_actual_api_key_here
```

**Note**: If you don't configure an API key, the application will still work and provide:
- Static code analysis
- General code review tips and best practices
- Code statistics and metrics

The AI features will show helpful fallback suggestions instead of making API calls.

### 3. Build the project

```bash
mvn clean compile
```

### 4. Run the application

Using Maven:

```bash
mvn javafx:run
```

Or directly through your IDE by running the `MainApp` class.

## Using the Application

1. Launch the application
2. Open a Java file using the "Open File" button
3. Review the automatic code analysis results in the right panel
4. Use the AI features:
   - **AI Review**: Click "🔍 AI Review" for a comprehensive code review
   - **Ask AI**: Click "💬 Ask AI" and type a specific question about your code
   - Both features provide real-time streaming responses
5. If AI is not configured, you'll get helpful fallback suggestions and best practices
6. Click on specific issues in the analysis panel to see detailed information
7. Use the heatmap on the left to quickly identify problematic areas in your code

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request
</file>

<file path="frontend/test-frontend-transformation.sh">
#!/bin/bash

echo "=== CodeReviewer Frontend Transformation Test ==="
echo ""

echo "1. Testing basic compilation..."
./mvnw compile -q
if [ $? -eq 0 ]; then
    echo "✅ Compilation successful"
else
    echo "❌ Compilation failed"
    exit 1
fi

echo ""
echo "2. Checking package structure..."
echo "Frontend packages (should exist):"
find src/main/java/com/reviewer/codereviewer -type d -name "client" 2>/dev/null && echo "✅ client package exists" || echo "❌ client package missing"
find src/main/java/com/reviewer/codereviewer -type d -name "controller" 2>/dev/null && echo "✅ controller package exists" || echo "❌ controller package missing"
find src/main/java/com/reviewer/codereviewer -type d -name "ui" 2>/dev/null && echo "✅ ui package exists" || echo "❌ ui package missing"

echo ""
echo "Backend packages (should be removed from source):"
find src/main/java/com/reviewer/codereviewer -type d -name "service" 2>/dev/null && echo "❌ service package still exists" || echo "✅ service package removed"
find src/main/java/com/reviewer/codereviewer -type d -name "model" 2>/dev/null && echo "❌ model package still exists" || echo "✅ model package removed"
find src/main/java/com/reviewer/codereviewer -type d -name "config" 2>/dev/null && echo "❌ config package still exists" || echo "✅ config package removed"

echo ""
echo "3. Checking key files..."
[ -f "src/main/java/com/reviewer/codereviewer/client/ApiClientService.java" ] && echo "✅ ApiClientService.java exists" || echo "❌ ApiClientService.java missing"
[ -f "src/main/java/com/reviewer/codereviewer/client/dto/CodeAnalysisResult.java" ] && echo "✅ CodeAnalysisResult DTO exists" || echo "❌ CodeAnalysisResult DTO missing"
[ -f "src/main/java/com/reviewer/codereviewer/controller/MainController.java" ] && echo "✅ MainController.java exists" || echo "❌ MainController.java missing"

echo ""
echo "4. Testing ApiClientService dependencies..."
grep -q "import com.fasterxml.jackson" src/main/java/com/reviewer/codereviewer/client/ApiClientService.java 2>/dev/null && echo "✅ Jackson imports found" || echo "❌ Jackson imports missing"
grep -q "HttpClient" src/main/java/com/reviewer/codereviewer/client/ApiClientService.java 2>/dev/null && echo "✅ HTTP client usage found" || echo "❌ HTTP client usage missing"

echo ""
echo "5. Testing MainController transformation..."
grep -q "ApiClientService" src/main/java/com/reviewer/codereviewer/controller/MainController.java 2>/dev/null && echo "✅ ApiClientService usage found" || echo "❌ ApiClientService usage missing"
grep -q "client.dto" src/main/java/com/reviewer/codereviewer/controller/MainController.java 2>/dev/null && echo "✅ DTO imports found" || echo "❌ DTO imports missing"

echo ""
echo "=== Transformation Summary ==="
echo "✅ Frontend successfully transformed into a 'dumb' client"
echo "✅ Backend logic removed from frontend"
echo "✅ API client service created for server communication"
echo "✅ MainController updated to use API client"
echo "✅ DTOs created for API communication"
echo ""
echo "🎉 Frontend transformation complete!"
echo ""
echo "Next steps:"
echo "1. Start the backend server (Step 3 from the previous instructions)"
echo "2. Run this frontend application with: ./mvnw clean compile exec:java"
echo "3. The frontend will connect to the backend API at http://localhost:8080"
</file>

<file path="scripts/build-all.sh">
#!/bin/bash

echo "🏗️  Building CodeReviewer Application"
echo "======================================"

# Build backend
echo "📦 Building Backend..."
cd backend
mvn clean package -DskipTests
if [ $? -ne 0 ]; then
    echo "❌ Backend build failed"
    exit 1
fi
cd ..

# Build frontend
echo "📦 Building Frontend..."
cd frontend
mvn clean compile
if [ $? -ne 0 ]; then
    echo "❌ Frontend build failed"
    exit 1
fi
cd ..

echo "✅ Build completed successfully!"
echo "🚀 To run:"
echo "   Backend: cd backend && mvn spring-boot:run"
echo "   Frontend: cd frontend && mvn javafx:run"
</file>

<file path="scripts/start-dev.sh">
#!/bin/bash

echo "🚀 Starting CodeReviewer Development Environment"
echo "================================================"

# Function to kill background processes on exit
cleanup() {
    echo "🛑 Stopping services..."
    jobs -p | xargs -r kill
    exit
}
trap cleanup EXIT

# Start backend in background
echo "🔧 Starting Backend Server..."
cd backend
mvn spring-boot:run &
BACKEND_PID=$!
cd ..

# Wait for backend to start
echo "⏳ Waiting for backend to start..."
sleep 10

# Check if backend is running
if ! kill -0 $BACKEND_PID 2>/dev/null; then
    echo "❌ Backend failed to start"
    exit 1
fi

echo "✅ Backend started successfully"
echo "🖥️  Starting Frontend..."

# Start frontend
cd frontend
mvn javafx:run
</file>

<file path=".gitignore">
# Root level ignores
*.log
*.tmp
.DS_Store
.vscode/
.idea/

# Backend (Maven + Spring Boot)
backend/target/
backend/*.jar
backend/*.war
backend/.mvn/
backend/mvnw
backend/mvnw.cmd
backend/logs/

# Frontend (Maven + JavaFX)
frontend/target/
frontend/*.jar
frontend/.mvn/
frontend/mvnw
frontend/mvnw.cmd

# Java
*.class
*.jar
*.war
*.ear
*.zip
*.tar.gz
*.rar

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Configuration files with secrets
backend/src/main/resources/application-secrets.properties
frontend/src/main/resources/config/application-private.properties
*.key
*.pem

# Build and dependency directories
node_modules/
dist/
build/

# Docker
.dockerignore
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  codereviewer-backend:
    build: ./backend
    container_name: codereviewer-backend
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=production
      - OPENROUTER_API_KEY=${OPENROUTER_API_KEY:-YOUR_API_KEY_HERE}
      - OPENROUTER_MODEL_NAME=${OPENROUTER_MODEL_NAME:-mistralai/mixtral-8x7b-instruct}
      - JAVA_OPTS=-Xmx512m -Xms256m
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/code-review/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - codereviewer-network

networks:
  codereviewer-network:
    driver: bridge
</file>

<file path="README.md">
# CodeReviewer - AI-Powered Java Code Analysis Tool

A comprehensive Java code review application that combines static analysis with AI-powered insights.

## 🏗️ Architecture

- **Backend**: Spring Boot REST API (Java 17)
- **Frontend**: JavaFX Desktop Application (Java 21)
- **AI Integration**: OpenRouter API with Mistral AI

## 🚀 Quick Start

### Prerequisites
- Java 17+ (for backend)
- Java 21+ (for frontend)
- Maven 3.6+
- Docker (optional)

### Development Setup

1. **Clone the repository**
   ```bash
   git clone <your-repo-url>
   cd CodeReviewer
   ```

2. **Start Backend**
   ```bash
   cd backend
   mvn spring-boot:run
   ```

3. **Start Frontend**
   ```bash
   cd frontend
   mvn javafx:run
   ```

## 📁 Project Structure

```
CodeReviewer/
├── backend/           # Spring Boot API Server
├── frontend/          # JavaFX Desktop Client
├── docs/             # Documentation
├── scripts/          # Build and deployment scripts
└── docker-compose.yml # Full-stack deployment
```

## 🔧 Features

### Static Code Analysis
- Method complexity analysis
- Nesting depth detection
- Poor variable naming detection
- Magic number identification
- Unused import detection

### AI-Powered Reviews
- Comprehensive code review suggestions
- Refactoring recommendations
- Best practice guidance

### Modern UI
- Professional JavaFX interface
- Code visualization with heatmaps
- Real-time issue highlighting
- Advanced filtering and search
</file>

</files>
